
build/stepper.elf:	file format elf32-littlearm

Disassembly of section .boot2:

10000000 <__flash_binary_start>:
10000000: 00 b5 32 4b  	.word	0x4b32b500
10000004: 21 20 58 60  	.word	0x60582021
10000008: 98 68 02 21  	.word	0x21026898
1000000c: 88 43 98 60  	.word	0x60984388
10000010: d8 60 18 61  	.word	0x611860d8
10000014: 58 61 2e 4b  	.word	0x4b2e6158
10000018: 00 21 99 60  	.word	0x60992100
1000001c: 02 21 59 61  	.word	0x61592102
10000020: 01 21 f0 22  	.word	0x22f02101
10000024: 99 50 2b 49  	.word	0x492b5099
10000028: 19 60 01 21  	.word	0x21016019
1000002c: 99 60 35 20  	.word	0x20356099
10000030: 00 f0 44 f8  	.word	0xf844f000
10000034: 02 22 90 42  	.word	0x42902202
10000038: 14 d0 06 21  	.word	0x2106d014
1000003c: 19 66 00 f0  	.word	0xf0006619
10000040: 34 f8 19 6e  	.word	0x6e19f834
10000044: 01 21 19 66  	.word	0x66192101
10000048: 00 20 18 66  	.word	0x66182000
1000004c: 1a 66 00 f0  	.word	0xf000661a
10000050: 2c f8 19 6e  	.word	0x6e19f82c
10000054: 19 6e 19 6e  	.word	0x6e196e19
10000058: 05 20 00 f0  	.word	0xf0002005
1000005c: 2f f8 01 21  	.word	0x2101f82f
10000060: 08 42 f9 d1  	.word	0xd1f94208
10000064: 00 21 99 60  	.word	0x60992100
10000068: 1b 49 19 60  	.word	0x6019491b
1000006c: 00 21 59 60  	.word	0x60592100
10000070: 1a 49 1b 48  	.word	0x481b491a
10000074: 01 60 01 21  	.word	0x21016001
10000078: 99 60 eb 21  	.word	0x21eb6099
1000007c: 19 66 a0 21  	.word	0x21a06619
10000080: 19 66 00 f0  	.word	0xf0006619
10000084: 12 f8 00 21  	.word	0x2100f812
10000088: 99 60 16 49  	.word	0x49166099
1000008c: 14 48 01 60  	.word	0x60014814
10000090: 01 21 99 60  	.word	0x60992101
10000094: 01 bc 00 28  	.word	0x2800bc01
10000098: 00 d0 00 47  	.word	0x4700d000
1000009c: 12 48 13 49  	.word	0x49134812
100000a0: 08 60 03 c8  	.word	0xc8036008
100000a4: 80 f3 08 88  	.word	0x8808f380
100000a8: 08 47 03 b5  	.word	0xb5034708
100000ac: 99 6a 04 20  	.word	0x20046a99
100000b0: 01 42 fb d0  	.word	0xd0fb4201
100000b4: 01 20 01 42  	.word	0x42012001
100000b8: f8 d1 03 bd  	.word	0xbd03d1f8
100000bc: 02 b5 18 66  	.word	0x6618b502
100000c0: 18 66 ff f7  	.word	0xf7ff6618
100000c4: f2 ff 18 6e  	.word	0x6e18fff2
100000c8: 18 6e 02 bd  	.word	0xbd026e18
100000cc: 00 00 02 40  	.word	0x40020000
100000d0: 00 00 00 18  	.word	0x18000000
100000d4: 00 00 07 00  	.word	0x00070000
100000d8: 00 03 5f 00  	.word	0x005f0300
100000dc: 21 22 00 00  	.word	0x00002221
100000e0: f4 00 00 18  	.word	0x180000f4
100000e4: 22 20 00 a0  	.word	0xa0002022
100000e8: 00 01 00 10  	.word	0x10000100
100000ec: 08 ed 00 e0  	.word	0xe000ed08
100000f0: 00 00 00 00  	.word	0x00000000
100000f4: 00 00 00 00  	.word	0x00000000
100000f8: 00 00 00 00  	.word	0x00000000
100000fc: 74 b2 4e 7a  	.word	0x7a4eb274

Disassembly of section .text:

10000100 <__vectors>:
10000100: 00 20 04 20  	.word	0x20042000
10000104: f7 01 00 10  	.word	0x100001f7
10000108: c3 01 00 10  	.word	0x100001c3
1000010c: c5 01 00 10  	.word	0x100001c5
10000110: c1 01 00 10  	.word	0x100001c1
10000114: c1 01 00 10  	.word	0x100001c1
10000118: c1 01 00 10  	.word	0x100001c1
1000011c: c1 01 00 10  	.word	0x100001c1
10000120: c1 01 00 10  	.word	0x100001c1
10000124: c1 01 00 10  	.word	0x100001c1
10000128: c1 01 00 10  	.word	0x100001c1
1000012c: c7 01 00 10  	.word	0x100001c7
10000130: c1 01 00 10  	.word	0x100001c1
10000134: c1 01 00 10  	.word	0x100001c1
10000138: c9 01 00 10  	.word	0x100001c9
1000013c: cb 01 00 10  	.word	0x100001cb
10000140: cd 01 00 10  	.word	0x100001cd
10000144: cd 01 00 10  	.word	0x100001cd
10000148: cd 01 00 10  	.word	0x100001cd
1000014c: cd 01 00 10  	.word	0x100001cd
10000150: cd 01 00 10  	.word	0x100001cd
10000154: cd 01 00 10  	.word	0x100001cd
10000158: cd 01 00 10  	.word	0x100001cd
1000015c: cd 01 00 10  	.word	0x100001cd
10000160: cd 01 00 10  	.word	0x100001cd
10000164: cd 01 00 10  	.word	0x100001cd
10000168: cd 01 00 10  	.word	0x100001cd
1000016c: cd 01 00 10  	.word	0x100001cd
10000170: cd 01 00 10  	.word	0x100001cd
10000174: cd 01 00 10  	.word	0x100001cd
10000178: cd 01 00 10  	.word	0x100001cd
1000017c: cd 01 00 10  	.word	0x100001cd
10000180: cd 01 00 10  	.word	0x100001cd
10000184: cd 01 00 10  	.word	0x100001cd
10000188: cd 01 00 10  	.word	0x100001cd
1000018c: cd 01 00 10  	.word	0x100001cd
10000190: cd 01 00 10  	.word	0x100001cd
10000194: cd 01 00 10  	.word	0x100001cd
10000198: cd 01 00 10  	.word	0x100001cd
1000019c: cd 01 00 10  	.word	0x100001cd
100001a0: cd 01 00 10  	.word	0x100001cd
100001a4: cd 01 00 10  	.word	0x100001cd
100001a8: cd 01 00 10  	.word	0x100001cd
100001ac: cd 01 00 10  	.word	0x100001cd
100001b0: cd 01 00 10  	.word	0x100001cd
100001b4: cd 01 00 10  	.word	0x100001cd
100001b8: cd 01 00 10  	.word	0x100001cd
100001bc: cd 01 00 10  	.word	0x100001cd

100001c0 <isr_invalid>:
; decl_isr_bkpt isr_invalid
100001c0: be00         	bkpt	#0x0

100001c2 <isr_nmi>:
; decl_isr_bkpt isr_nmi
100001c2: be00         	bkpt	#0x0

100001c4 <isr_hardfault>:
; decl_isr_bkpt isr_hardfault
100001c4: be00         	bkpt	#0x0

100001c6 <isr_svcall>:
; decl_isr_bkpt isr_svcall
100001c6: be00         	bkpt	#0x0

100001c8 <isr_pendsv>:
; decl_isr_bkpt isr_pendsv
100001c8: be00         	bkpt	#0x0

100001ca <isr_systick>:
; decl_isr_bkpt isr_systick
100001ca: be00         	bkpt	#0x0

100001cc <isr_irq9>:
;     mrs  r0, ipsr
100001cc: f3ef 8005    	mrs	r0, ipsr
;     subs r0, #16
100001d0: 3810         	subs	r0, #0x10

100001d2 <unhandled_user_irq_num_in_r0>:
;     bkpt #0
100001d2: be00         	bkpt	#0x0

100001d4 <binary_info_header>:
100001d4: f2 eb 88 71  	.word	0x7188ebf2
100001d8: 84 46 00 10  	.word	0x10004684
100001dc: a4 46 00 10  	.word	0x100046a4
100001e0: 38 02 00 10  	.word	0x10000238
100001e4: 90 a3 1a e7  	.word	0xe71aa390

100001e8 <_entry_point>:
;     ldr r0, =BOOTROM_VTABLE_OFFSET
100001e8: 481e         	ldr	r0, [pc, #0x78]         @ 0x10000264 <data_cpy_table+0x2c>

100001ea <_enter_vtable_in_r0>:
;     ldr r1, =(PPB_BASE + ARM_CPU_PREFIXED(VTOR_OFFSET))
100001ea: 491f         	ldr	r1, [pc, #0x7c]         @ 0x10000268 <data_cpy_table+0x30>
;     str r0, [r1]
100001ec: 6008         	str	r0, [r1]
;     ldmia r0!, {r1, r2}
100001ee: c806         	ldm	r0!, {r1, r2}
;     msr msp, r1
100001f0: f381 8808    	msr	msp, r1
;     bx r2
100001f4: 4710         	bx	r2

100001f6 <_reset_handler>:
;     ldr r0, =(SIO_BASE + SIO_CPUID_OFFSET)
100001f6: 481d         	ldr	r0, [pc, #0x74]         @ 0x1000026c <data_cpy_table+0x34>
;     ldr r0, [r0]
100001f8: 6800         	ldr	r0, [r0]
;     cmp r0, #0
100001fa: 2800         	cmp	r0, #0x0
;     beq 1f
100001fc: d001         	beq	0x10000202 <hold_non_core0_in_bootrom+0x4> @ imm = #0x2

100001fe <hold_non_core0_in_bootrom>:
;     ldr r0, =BOOTROM_VTABLE_OFFSET
100001fe: 4819         	ldr	r0, [pc, #0x64]         @ 0x10000264 <data_cpy_table+0x2c>
;     b _enter_vtable_in_r0
10000200: e7f3         	b	0x100001ea <_enter_vtable_in_r0> @ imm = #-0x1a
;     adr r4, data_cpy_table
10000202: a40d         	adr	r4, #52 <hold_non_core0_in_bootrom+0x15>
;     ldmia r4!, {r1-r3}
10000204: cc0e         	ldm	r4!, {r1, r2, r3}
;     cmp r1, #0
10000206: 2900         	cmp	r1, #0x0
;     beq 2f
10000208: d002         	beq	0x10000210 <hold_non_core0_in_bootrom+0x12> @ imm = #0x4
;     bl data_cpy
1000020a: f000 f812    	bl	0x10000232 <data_cpy>   @ imm = #0x24
;     b 1b
1000020e: e7f9         	b	0x10000204 <hold_non_core0_in_bootrom+0x6> @ imm = #-0xe
;     ldr r1, =__bss_start__
10000210: 4917         	ldr	r1, [pc, #0x5c]         @ 0x10000270 <data_cpy_table+0x38>
;     ldr r2, =__bss_end__
10000212: 4a18         	ldr	r2, [pc, #0x60]         @ 0x10000274 <data_cpy_table+0x3c>
;     movs r0, #0
10000214: 2000         	movs	r0, #0x0
;     b bss_fill_test
10000216: e000         	b	0x1000021a <bss_fill_test> @ imm = #0x0

10000218 <bss_fill_loop>:
;     stm r1!, {r0}
10000218: c101         	stm	r1!, {r0}

1000021a <bss_fill_test>:
;     cmp r1, r2
1000021a: 4291         	cmp	r1, r2
;     bne bss_fill_loop
1000021c: d1fc         	bne	0x10000218 <bss_fill_loop> @ imm = #-0x8

1000021e <platform_entry>:
;     ldr r1, =runtime_init
1000021e: 4916         	ldr	r1, [pc, #0x58]         @ 0x10000278 <data_cpy_table+0x40>
;     blx r1
10000220: 4788         	blx	r1
;     ldr r1, =main
10000222: 4916         	ldr	r1, [pc, #0x58]         @ 0x1000027c <data_cpy_table+0x44>
;     blx r1
10000224: 4788         	blx	r1
;     ldr r1, =exit
10000226: 4916         	ldr	r1, [pc, #0x58]         @ 0x10000280 <data_cpy_table+0x48>
;     blx r1
10000228: 4788         	blx	r1
;     bkpt #0
1000022a: be00         	bkpt	#0x0
;     b 1b
1000022c: e7fd         	b	0x1000022a <platform_entry+0xc> @ imm = #-0x6

1000022e <data_cpy_loop>:
;     ldm r1!, {r0}
1000022e: c901         	ldm	r1!, {r0}
;     stm r2!, {r0}
10000230: c201         	stm	r2!, {r0}

10000232 <data_cpy>:
;     cmp r2, r3
10000232: 429a         	cmp	r2, r3
;     blo data_cpy_loop
10000234: d3fb         	blo	0x1000022e <data_cpy_loop> @ imm = #-0xa
;     bx lr
10000236: 4770         	bx	lr

10000238 <data_cpy_table>:
10000238: a4 46 00 10  	.word	0x100046a4
1000023c: c0 00 00 20  	.word	0x200000c0
10000240: e8 01 00 20  	.word	0x200001e8
10000244: cc 47 00 10  	.word	0x100047cc
10000248: 00 00 04 20  	.word	0x20040000
1000024c: 00 00 04 20  	.word	0x20040000
10000250: cc 47 00 10  	.word	0x100047cc
10000254: 00 10 04 20  	.word	0x20041000
10000258: 00 10 04 20  	.word	0x20041000
1000025c: 00 00 00 00  	.word	0x00000000
;     bx lr
10000260: 4770         	bx	lr
10000262: 00 00        	.short	0x0000
10000264: 00 00 00 00  	.word	0x00000000
10000268: 08 ed 00 e0  	.word	0xe000ed08
1000026c: 00 00 00 d0  	.word	0xd0000000
10000270: e8 01 00 20  	.word	0x200001e8
10000274: d0 05 00 20  	.word	0x200005d0
10000278: 9d 3c 00 10  	.word	0x10003c9d
1000027c: d5 02 00 10  	.word	0x100002d5
10000280: 95 3c 00 10  	.word	0x10003c95

10000284 <_init>:
10000284: b5f8         	push	{r3, r4, r5, r6, r7, lr}
10000286: 46c0         	mov	r8, r8

10000288 <register_tm_clones>:
10000288: 4806         	ldr	r0, [pc, #0x18]         @ 0x100002a4 <register_tm_clones+0x1c>
1000028a: 4907         	ldr	r1, [pc, #0x1c]         @ 0x100002a8 <register_tm_clones+0x20>
1000028c: 1a09         	subs	r1, r1, r0
1000028e: 108b         	asrs	r3, r1, #0x2
10000290: 0fc9         	lsrs	r1, r1, #0x1f
10000292: 18c9         	adds	r1, r1, r3
10000294: b510         	push	{r4, lr}
10000296: 1049         	asrs	r1, r1, #0x1
10000298: d003         	beq	0x100002a2 <register_tm_clones+0x1a> @ imm = #0x6
1000029a: 4b04         	ldr	r3, [pc, #0x10]         @ 0x100002ac <register_tm_clones+0x24>
1000029c: 2b00         	cmp	r3, #0x0
1000029e: d000         	beq	0x100002a2 <register_tm_clones+0x1a> @ imm = #0x0
100002a0: 4798         	blx	r3
100002a2: bd10         	pop	{r4, pc}
100002a4: e8 01 00 20  	.word	0x200001e8
100002a8: e8 01 00 20  	.word	0x200001e8
100002ac: 00 00 00 00  	.word	0x00000000

100002b0 <frame_dummy>:
100002b0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x100002c8 <frame_dummy+0x18>
100002b2: b510         	push	{r4, lr}
100002b4: 2b00         	cmp	r3, #0x0
100002b6: d003         	beq	0x100002c0 <frame_dummy+0x10> @ imm = #0x6
100002b8: 4904         	ldr	r1, [pc, #0x10]         @ 0x100002cc <frame_dummy+0x1c>
100002ba: 4805         	ldr	r0, [pc, #0x14]         @ 0x100002d0 <frame_dummy+0x20>
100002bc: e000         	b	0x100002c0 <frame_dummy+0x10> @ imm = #0x0
100002be: bf00         	nop
100002c0: f7ff ffe2    	bl	0x10000288 <register_tm_clones> @ imm = #-0x3c
100002c4: bd10         	pop	{r4, pc}
100002c6: 46c0         	mov	r8, r8
100002c8: 00 00 00 00  	.word	0x00000000
100002cc: a0 05 00 20  	.word	0x200005a0
100002d0: 80 41 00 10  	.word	0x10004180

100002d4 <main>:
; {
100002d4: b510         	push	{r4, lr}
;     stdio_init_all();
100002d6: f003 fe07    	bl	0x10003ee8 <stdio_init_all> @ imm = #0x3c0e
;     run();
100002da: f000 f803    	bl	0x100002e4 <run>        @ imm = #0x6
; }
100002de: 2000         	movs	r0, #0x0
100002e0: bd10         	pop	{r4, pc}
100002e2: 46c0         	mov	r8, r8

100002e4 <run>:
; {
100002e4: b5f0         	push	{r4, r5, r6, r7, lr}
100002e6: 46de         	mov	lr, r11
100002e8: 4657         	mov	r7, r10
100002ea: 464e         	mov	r6, r9
100002ec: 4645         	mov	r5, r8
100002ee: b5e0         	push	{r5, r6, r7, lr}
;     gpio_init(LED_PIN);
100002f0: 2019         	movs	r0, #0x19
; {
100002f2: b0a5         	sub	sp, #0x94
;     gpio_init(LED_PIN);
100002f4: f000 fa1c    	bl	0x10000730 <gpio_init>  @ imm = #0x438
;     sio_hw->gpio_oe_set = mask;
100002f8: 23d0         	movs	r3, #0xd0
100002fa: 2280         	movs	r2, #0x80
100002fc: 061b         	lsls	r3, r3, #0x18
100002fe: 0492         	lsls	r2, r2, #0x12
10000300: 625a         	str	r2, [r3, #0x24]
;         if (!stepper_init(&steppers[i],
10000302: 2303         	movs	r3, #0x3
10000304: ae08         	add	r6, sp, #0x20
;     for (uint i = 0; i < num_steppers; i++)
10000306: 2500         	movs	r5, #0x0
;         printf("Stepper motor %d initialized on pins %d,%d,%d,%d\n",
10000308: 46b2         	mov	r10, r6
;         if (!stepper_init(&steppers[i],
1000030a: 469b         	mov	r11, r3
;         printf("Stepper motor %d initialized on pins %d,%d,%d,%d\n",
1000030c: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x100003f0 <run+0x10c>
1000030e: 4c39         	ldr	r4, [pc, #0xe4]         @ 0x100003f4 <run+0x110>
10000310: 9303         	str	r3, [sp, #0xc]
;                           stepper_pins[i][2], stepper_pins[i][3],
10000312: 68a3         	ldr	r3, [r4, #0x8]
;                           stepper_pins[i][0], stepper_pins[i][1],
10000314: 6827         	ldr	r7, [r4]
;                           stepper_pins[i][2], stepper_pins[i][3],
10000316: 4698         	mov	r8, r3
10000318: 68e3         	ldr	r3, [r4, #0xc]
;                           stepper_pins[i][0], stepper_pins[i][1],
1000031a: 6866         	ldr	r6, [r4, #0x4]
;                           stepper_pins[i][2], stepper_pins[i][3],
1000031c: 4699         	mov	r9, r3
;         if (!stepper_init(&steppers[i],
1000031e: 465b         	mov	r3, r11
10000320: 9301         	str	r3, [sp, #0x4]
10000322: 464b         	mov	r3, r9
10000324: 0032         	movs	r2, r6
10000326: 9300         	str	r3, [sp]
10000328: 0039         	movs	r1, r7
1000032a: 4643         	mov	r3, r8
1000032c: 4650         	mov	r0, r10
1000032e: f000 f971    	bl	0x10000614 <stepper_init> @ imm = #0x2e2
;             printf("Failed to initialize stepper motor %d\n", i + 1);
10000332: 3501         	adds	r5, #0x1
;         if (!stepper_init(&steppers[i],
10000334: 2800         	cmp	r0, #0x0
10000336: d04d         	beq	0x100003d4 <run+0xf0>   @ imm = #0x9a
;         printf("Stepper motor %d initialized on pins %d,%d,%d,%d\n",
10000338: 464b         	mov	r3, r9
1000033a: 9301         	str	r3, [sp, #0x4]
1000033c: 4643         	mov	r3, r8
1000033e: 003a         	movs	r2, r7
10000340: 9300         	str	r3, [sp]
10000342: 0029         	movs	r1, r5
10000344: 0033         	movs	r3, r6
10000346: 9803         	ldr	r0, [sp, #0xc]
10000348: f003 fe9e    	bl	0x10004088 <stdio_printf> @ imm = #0x3d3c
;     for (uint i = 0; i < num_steppers; i++)
1000034c: 231c         	movs	r3, #0x1c
1000034e: 469c         	mov	r12, r3
10000350: 3410         	adds	r4, #0x10
10000352: 44e2         	add	r10, r12
10000354: 2d04         	cmp	r5, #0x4
10000356: d1dc         	bne	0x10000312 <run+0x2e>   @ imm = #-0x48
;     printf("All stepper motors initialized successfully!\n");
10000358: 4827         	ldr	r0, [pc, #0x9c]         @ 0x100003f8 <run+0x114>
1000035a: f003 fe11    	bl	0x10003f80 <stdio_puts> @ imm = #0x3c22
;     printf("Starting LED blink and stepper motor control loop...\n");
1000035e: 4827         	ldr	r0, [pc, #0x9c]         @ 0x100003fc <run+0x118>
10000360: f003 fe0e    	bl	0x10003f80 <stdio_puts> @ imm = #0x3c1c
;     uint cycle_count = 0;
10000364: 4b26         	ldr	r3, [pc, #0x98]         @ 0x10000400 <run+0x11c>
10000366: 4f27         	ldr	r7, [pc, #0x9c]         @ 0x10000404 <run+0x120>
10000368: 4698         	mov	r8, r3
1000036a: ab0f         	add	r3, sp, #0x3c
1000036c: 469b         	mov	r11, r3
1000036e: ab16         	add	r3, sp, #0x58
10000370: 469a         	mov	r10, r3
10000372: ab1d         	add	r3, sp, #0x74
10000374: 4699         	mov	r9, r3
;     sio_hw->gpio_set = mask;
10000376: 003b         	movs	r3, r7
10000378: 26d0         	movs	r6, #0xd0
1000037a: 4647         	mov	r7, r8
;     uint cycle_count = 0;
1000037c: 2400         	movs	r4, #0x0
;     sio_hw->gpio_set = mask;
1000037e: 4698         	mov	r8, r3
10000380: 0636         	lsls	r6, r6, #0x18
10000382: 2580         	movs	r5, #0x80
10000384: 04ad         	lsls	r5, r5, #0x12
;     printf("LED ON\n");
10000386: 0038         	movs	r0, r7
;     sio_hw->gpio_set = mask;
10000388: 6175         	str	r5, [r6, #0x14]
;     printf("LED ON\n");
1000038a: f003 fdf9    	bl	0x10003f80 <stdio_puts> @ imm = #0x3bf2
;     sleep_ms(LED_BLINK_DELAY_MS);
1000038e: 20fa         	movs	r0, #0xfa
10000390: 0040         	lsls	r0, r0, #0x1
10000392: f000 fd57    	bl	0x10000e44 <sleep_ms>   @ imm = #0xaae
;     printf("LED OFF\n");
10000396: 4640         	mov	r0, r8
;     sio_hw->gpio_clr = mask;
10000398: 61b5         	str	r5, [r6, #0x18]
;     printf("LED OFF\n");
1000039a: f003 fdf1    	bl	0x10003f80 <stdio_puts> @ imm = #0x3be2
;     sleep_ms(LED_BLINK_DELAY_MS);
1000039e: 20fa         	movs	r0, #0xfa
100003a0: 0040         	lsls	r0, r0, #0x1
100003a2: f000 fd4f    	bl	0x10000e44 <sleep_ms>   @ imm = #0xa9e
100003a6: 2105         	movs	r1, #0x5
100003a8: 0020         	movs	r0, r4
100003aa: f001 f917    	bl	0x100015dc <divmod_u32u32> @ imm = #0x122e
;         if (cycle_count % STEPPER_CYCLE_INTERVAL == 0)
100003ae: 2900         	cmp	r1, #0x0
100003b0: d10e         	bne	0x100003d0 <run+0xec>   @ imm = #0x1c
;         stepper_ptrs[i] = &steppers[i];
100003b2: ab08         	add	r3, sp, #0x20
100003b4: 9304         	str	r3, [sp, #0x10]
100003b6: 465b         	mov	r3, r11
100003b8: 9305         	str	r3, [sp, #0x14]
100003ba: 4653         	mov	r3, r10
100003bc: 9306         	str	r3, [sp, #0x18]
100003be: 464b         	mov	r3, r9
100003c0: 9307         	str	r3, [sp, #0x1c]
;     stepper_demo_sequence(stepper_ptrs, num_steppers, STEPPER_DEMO_ANGLE, STEPPER_PAUSE_MS);
100003c2: 23fa         	movs	r3, #0xfa
100003c4: 4a10         	ldr	r2, [pc, #0x40]         @ 0x10000408 <run+0x124>
100003c6: 005b         	lsls	r3, r3, #0x1
100003c8: 3104         	adds	r1, #0x4
100003ca: a804         	add	r0, sp, #0x10
100003cc: f000 f970    	bl	0x100006b0 <stepper_demo_sequence> @ imm = #0x2e0
;         cycle_count++;
100003d0: 3401         	adds	r4, #0x1
;         led_blink_cycle(LED_PIN);
100003d2: e7d6         	b	0x10000382 <run+0x9e>   @ imm = #-0x54
;             printf("Failed to initialize stepper motor %d\n", i + 1);
100003d4: 0029         	movs	r1, r5
100003d6: 480d         	ldr	r0, [pc, #0x34]         @ 0x1000040c <run+0x128>
100003d8: f003 fe56    	bl	0x10004088 <stdio_printf> @ imm = #0x3cac
;         printf("Stepper motor initialization failed. Exiting...\n");
100003dc: 480c         	ldr	r0, [pc, #0x30]         @ 0x10000410 <run+0x12c>
100003de: f003 fdcf    	bl	0x10003f80 <stdio_puts> @ imm = #0x3b9e
; }
100003e2: b025         	add	sp, #0x94
100003e4: bcf0         	pop	{r4, r5, r6, r7}
100003e6: 46bb         	mov	r11, r7
100003e8: 46b2         	mov	r10, r6
100003ea: 46a9         	mov	r9, r5
100003ec: 46a0         	mov	r8, r4
100003ee: bdf0         	pop	{r4, r5, r6, r7, pc}
100003f0: ec 41 00 10  	.word	0x100041ec
100003f4: d4 43 00 10  	.word	0x100043d4
100003f8: 20 42 00 10  	.word	0x10004220
100003fc: 50 42 00 10  	.word	0x10004250
10000400: 80 41 00 10  	.word	0x10004180
10000404: 8c 41 00 10  	.word	0x1000418c
10000408: 00 00 34 42  	.word	0x42340000
1000040c: 94 41 00 10  	.word	0x10004194
10000410: bc 41 00 10  	.word	0x100041bc

10000414 <stepper_rotate_multiple_degrees.part.0>:
; void stepper_rotate_multiple_degrees(stepper_motor_t *motors[], uint num_motors,
10000414: b5f0         	push	{r4, r5, r6, r7, lr}
10000416: 46de         	mov	lr, r11
10000418: 464e         	mov	r6, r9
1000041a: 4657         	mov	r7, r10
1000041c: 4645         	mov	r5, r8
1000041e: b5e0         	push	{r5, r6, r7, lr}
10000420: 0004         	movs	r4, r0
10000422: b085         	sub	sp, #0x14
10000424: 1c10         	adds	r0, r2, #0x0
10000426: 000e         	movs	r6, r1
;     uint steps = (uint)((degrees / 360.0f) * STEPS_PER_REVOLUTION);
10000428: 4978         	ldr	r1, [pc, #0x1e0]        @ 0x1000060c <stepper_rotate_multiple_degrees.part.0+0x1f8>
; void stepper_rotate_multiple_degrees(stepper_motor_t *motors[], uint num_motors,
1000042a: 469b         	mov	r11, r3
;     uint steps = (uint)((degrees / 360.0f) * STEPS_PER_REVOLUTION);
1000042c: f001 ff1d    	bl	0x1000226a <__wrap___aeabi_fdiv> @ imm = #0x1e3a
10000430: 218a         	movs	r1, #0x8a
10000432: 05c9         	lsls	r1, r1, #0x17
10000434: f001 ff2d    	bl	0x10002292 <fdiv_fsub_nan_helper> @ imm = #0x1e5a
10000438: f001 ff32    	bl	0x100022a0 <float2uint_z> @ imm = #0x1e64
;     for (uint step = 0; step < steps; step++)
1000043c: 2300         	movs	r3, #0x0
;     uint steps = (uint)((degrees / 360.0f) * STEPS_PER_REVOLUTION);
1000043e: 4682         	mov	r10, r0
;     for (uint step = 0; step < steps; step++)
10000440: 4699         	mov	r9, r3
10000442: 2800         	cmp	r0, #0x0
10000444: d006         	beq	0x10000454 <stepper_rotate_multiple_degrees.part.0+0x40> @ imm = #0xc
;         for (uint i = 0; i < num_motors; i++)
10000446: 2e00         	cmp	r6, #0x0
10000448: d10b         	bne	0x10000462 <stepper_rotate_multiple_degrees.part.0+0x4e> @ imm = #0x16
1000044a: 4652         	mov	r2, r10
1000044c: 464b         	mov	r3, r9
;     for (uint step = 0; step < steps; step++)
1000044e: 3301         	adds	r3, #0x1
10000450: 429a         	cmp	r2, r3
10000452: d1fc         	bne	0x1000044e <stepper_rotate_multiple_degrees.part.0+0x3a> @ imm = #-0x8
; }
10000454: b005         	add	sp, #0x14
10000456: bcf0         	pop	{r4, r5, r6, r7}
10000458: 46bb         	mov	r11, r7
1000045a: 46b2         	mov	r10, r6
1000045c: 46a9         	mov	r9, r5
1000045e: 46a0         	mov	r8, r4
10000460: bdf0         	pop	{r4, r5, r6, r7, pc}
10000462: 00b7         	lsls	r7, r6, #0x2
;     gpio_put(motor->pin1, step_sequence[step][0]);
10000464: 4d6a         	ldr	r5, [pc, #0x1a8]        @ 0x10000610 <stepper_rotate_multiple_degrees.part.0+0x1fc>
10000466: 193f         	adds	r7, r7, r4
;                     motor->current_step = (motor->current_step + 1) % 8;
10000468: 2307         	movs	r3, #0x7
1000046a: 469c         	mov	r12, r3
1000046c: 465b         	mov	r3, r11
1000046e: 46b8         	mov	r8, r7
;     uint32_t mask = 1ul << gpio;
10000470: 2001         	movs	r0, #0x1
10000472: 464f         	mov	r7, r9
; void stepper_rotate_multiple_degrees(stepper_motor_t *motors[], uint num_motors,
10000474: 0021         	movs	r1, r4
10000476: 2b00         	cmp	r3, #0x0
10000478: d05c         	beq	0x10000534 <stepper_rotate_multiple_degrees.part.0+0x120> @ imm = #0xb8
;     sio_hw->gpio_set = mask;
1000047a: 23d0         	movs	r3, #0xd0
1000047c: 061b         	lsls	r3, r3, #0x18
1000047e: 4699         	mov	r9, r3
10000480: 4653         	mov	r3, r10
10000482: 9301         	str	r3, [sp, #0x4]
10000484: 4643         	mov	r3, r8
10000486: 46b2         	mov	r10, r6
10000488: 9702         	str	r7, [sp, #0x8]
1000048a: 9300         	str	r3, [sp]
1000048c: 9403         	str	r4, [sp, #0xc]
;             stepper_motor_t *motor = motors[i];
1000048e: 680b         	ldr	r3, [r1]
;             if (motor != NULL && motor->enabled)
10000490: 2b00         	cmp	r3, #0x0
10000492: d033         	beq	0x100004fc <stepper_rotate_multiple_degrees.part.0+0xe8> @ imm = #0x66
10000494: 7e1a         	ldrb	r2, [r3, #0x18]
10000496: 2a00         	cmp	r2, #0x0
10000498: d030         	beq	0x100004fc <stepper_rotate_multiple_degrees.part.0+0xe8> @ imm = #0x60
;                     motor->current_step = (motor->current_step - 1 + 8) % 8;
1000049a: 4666         	mov	r6, r12
1000049c: 695a         	ldr	r2, [r3, #0x14]
1000049e: 3207         	adds	r2, #0x7
100004a0: 17d4         	asrs	r4, r2, #0x1f
100004a2: 0f64         	lsrs	r4, r4, #0x1d
100004a4: 1912         	adds	r2, r2, r4
100004a6: 4032         	ands	r2, r6
;     uint32_t mask = 1ul << gpio;
100004a8: 0006         	movs	r6, r0
;                     motor->current_step = (motor->current_step - 1 + 8) % 8;
100004aa: 1b12         	subs	r2, r2, r4
;     uint32_t mask = 1ul << gpio;
100004ac: 681c         	ldr	r4, [r3]
100004ae: 615a         	str	r2, [r3, #0x14]
100004b0: 40a6         	lsls	r6, r4
;     gpio_put(motor->pin1, step_sequence[step][0]);
100004b2: 0094         	lsls	r4, r2, #0x2
;     uint32_t mask = 1ul << gpio;
100004b4: 46b0         	mov	r8, r6
;     if (value)
100004b6: 5d2e         	ldrb	r6, [r5, r4]
100004b8: 2e00         	cmp	r6, #0x0
100004ba: d100         	bne	0x100004be <stepper_rotate_multiple_degrees.part.0+0xaa> @ imm = #0x0
100004bc: e088         	b	0x100005d0 <stepper_rotate_multiple_degrees.part.0+0x1bc> @ imm = #0x110
;     sio_hw->gpio_set = mask;
100004be: 464e         	mov	r6, r9
100004c0: 4647         	mov	r7, r8
100004c2: 6177         	str	r7, [r6, #0x14]
;     uint32_t mask = 1ul << gpio;
100004c4: 0007         	movs	r7, r0
100004c6: 685e         	ldr	r6, [r3, #0x4]
100004c8: 40b7         	lsls	r7, r6
;     gpio_put(motor->pin2, step_sequence[step][1]);
100004ca: 192e         	adds	r6, r5, r4
;     if (value)
100004cc: 7876         	ldrb	r6, [r6, #0x1]
100004ce: 2e00         	cmp	r6, #0x0
100004d0: d07b         	beq	0x100005ca <stepper_rotate_multiple_degrees.part.0+0x1b6> @ imm = #0xf6
;     sio_hw->gpio_set = mask;
100004d2: 464e         	mov	r6, r9
100004d4: 6177         	str	r7, [r6, #0x14]
;     uint32_t mask = 1ul << gpio;
100004d6: 0007         	movs	r7, r0
100004d8: 689e         	ldr	r6, [r3, #0x8]
100004da: 40b7         	lsls	r7, r6
;     gpio_put(motor->pin3, step_sequence[step][2]);
100004dc: 192e         	adds	r6, r5, r4
;     if (value)
100004de: 78b6         	ldrb	r6, [r6, #0x2]
100004e0: 2e00         	cmp	r6, #0x0
100004e2: d06f         	beq	0x100005c4 <stepper_rotate_multiple_degrees.part.0+0x1b0> @ imm = #0xde
;     sio_hw->gpio_set = mask;
100004e4: 464e         	mov	r6, r9
100004e6: 6177         	str	r7, [r6, #0x14]
;     uint32_t mask = 1ul << gpio;
100004e8: 0007         	movs	r7, r0
;     gpio_put(motor->pin4, step_sequence[step][3]);
100004ea: 192c         	adds	r4, r5, r4
;     uint32_t mask = 1ul << gpio;
100004ec: 68de         	ldr	r6, [r3, #0xc]
;     if (value)
100004ee: 78e4         	ldrb	r4, [r4, #0x3]
;     uint32_t mask = 1ul << gpio;
100004f0: 40b7         	lsls	r7, r6
;     if (value)
100004f2: 2c00         	cmp	r4, #0x0
100004f4: d063         	beq	0x100005be <stepper_rotate_multiple_degrees.part.0+0x1aa> @ imm = #0xc6
;     sio_hw->gpio_set = mask;
100004f6: 464c         	mov	r4, r9
100004f8: 6167         	str	r7, [r4, #0x14]
;     motor->current_step = step;
100004fa: 615a         	str	r2, [r3, #0x14]
;         for (uint i = 0; i < num_motors; i++)
100004fc: 9b00         	ldr	r3, [sp]
100004fe: 3104         	adds	r1, #0x4
10000500: 428b         	cmp	r3, r1
10000502: d1c4         	bne	0x1000048e <stepper_rotate_multiple_degrees.part.0+0x7a> @ imm = #-0x78
10000504: 4698         	mov	r8, r3
10000506: 9b01         	ldr	r3, [sp, #0x4]
10000508: 4656         	mov	r6, r10
1000050a: 469a         	mov	r10, r3
;         for (uint i = 0; i < num_motors; i++)
1000050c: 2300         	movs	r3, #0x0
1000050e: 9f02         	ldr	r7, [sp, #0x8]
10000510: 9c03         	ldr	r4, [sp, #0xc]
;             if (motors[i] != NULL && motors[i]->enabled)
10000512: 009a         	lsls	r2, r3, #0x2
10000514: 58a2         	ldr	r2, [r4, r2]
10000516: 2a00         	cmp	r2, #0x0
10000518: d002         	beq	0x10000520 <stepper_rotate_multiple_degrees.part.0+0x10c> @ imm = #0x4
1000051a: 7e11         	ldrb	r1, [r2, #0x18]
1000051c: 2900         	cmp	r1, #0x0
1000051e: d168         	bne	0x100005f2 <stepper_rotate_multiple_degrees.part.0+0x1de> @ imm = #0xd0
;         for (uint i = 0; i < num_motors; i++)
10000520: 3301         	adds	r3, #0x1
10000522: 429e         	cmp	r6, r3
10000524: d1f5         	bne	0x10000512 <stepper_rotate_multiple_degrees.part.0+0xfe> @ imm = #-0x16
;     for (uint step = 0; step < steps; step++)
10000526: 3701         	adds	r7, #0x1
10000528: 45ba         	cmp	r10, r7
1000052a: d093         	beq	0x10000454 <stepper_rotate_multiple_degrees.part.0+0x40> @ imm = #-0xda
1000052c: 465b         	mov	r3, r11
; void stepper_rotate_multiple_degrees(stepper_motor_t *motors[], uint num_motors,
1000052e: 0021         	movs	r1, r4
10000530: 2b00         	cmp	r3, #0x0
10000532: d1a2         	bne	0x1000047a <stepper_rotate_multiple_degrees.part.0+0x66> @ imm = #-0xbc
;     sio_hw->gpio_clr = mask;
10000534: 23d0         	movs	r3, #0xd0
10000536: 061b         	lsls	r3, r3, #0x18
10000538: 4699         	mov	r9, r3
1000053a: 4653         	mov	r3, r10
1000053c: 9301         	str	r3, [sp, #0x4]
1000053e: 4643         	mov	r3, r8
10000540: 46b2         	mov	r10, r6
10000542: 9702         	str	r7, [sp, #0x8]
10000544: 9300         	str	r3, [sp]
10000546: 9403         	str	r4, [sp, #0xc]
;             stepper_motor_t *motor = motors[i];
10000548: 680b         	ldr	r3, [r1]
;             if (motor != NULL && motor->enabled)
1000054a: 2b00         	cmp	r3, #0x0
1000054c: d032         	beq	0x100005b4 <stepper_rotate_multiple_degrees.part.0+0x1a0> @ imm = #0x64
1000054e: 7e1a         	ldrb	r2, [r3, #0x18]
10000550: 2a00         	cmp	r2, #0x0
10000552: d02f         	beq	0x100005b4 <stepper_rotate_multiple_degrees.part.0+0x1a0> @ imm = #0x5e
;                     motor->current_step = (motor->current_step + 1) % 8;
10000554: 4666         	mov	r6, r12
10000556: 695a         	ldr	r2, [r3, #0x14]
10000558: 3201         	adds	r2, #0x1
1000055a: 17d4         	asrs	r4, r2, #0x1f
1000055c: 0f64         	lsrs	r4, r4, #0x1d
1000055e: 1912         	adds	r2, r2, r4
10000560: 4032         	ands	r2, r6
;     uint32_t mask = 1ul << gpio;
10000562: 0006         	movs	r6, r0
;                     motor->current_step = (motor->current_step + 1) % 8;
10000564: 1b12         	subs	r2, r2, r4
;     uint32_t mask = 1ul << gpio;
10000566: 681c         	ldr	r4, [r3]
10000568: 615a         	str	r2, [r3, #0x14]
1000056a: 40a6         	lsls	r6, r4
;     gpio_put(motor->pin1, step_sequence[step][0]);
1000056c: 0094         	lsls	r4, r2, #0x2
;     uint32_t mask = 1ul << gpio;
1000056e: 46b0         	mov	r8, r6
;     if (value)
10000570: 5d2e         	ldrb	r6, [r5, r4]
10000572: 2e00         	cmp	r6, #0x0
10000574: d039         	beq	0x100005ea <stepper_rotate_multiple_degrees.part.0+0x1d6> @ imm = #0x72
;     sio_hw->gpio_set = mask;
10000576: 464e         	mov	r6, r9
10000578: 4647         	mov	r7, r8
1000057a: 6177         	str	r7, [r6, #0x14]
;     uint32_t mask = 1ul << gpio;
1000057c: 0007         	movs	r7, r0
1000057e: 685e         	ldr	r6, [r3, #0x4]
10000580: 40b7         	lsls	r7, r6
;     gpio_put(motor->pin2, step_sequence[step][1]);
10000582: 192e         	adds	r6, r5, r4
;     if (value)
10000584: 7876         	ldrb	r6, [r6, #0x1]
10000586: 2e00         	cmp	r6, #0x0
10000588: d02c         	beq	0x100005e4 <stepper_rotate_multiple_degrees.part.0+0x1d0> @ imm = #0x58
;     sio_hw->gpio_set = mask;
1000058a: 464e         	mov	r6, r9
1000058c: 6177         	str	r7, [r6, #0x14]
;     uint32_t mask = 1ul << gpio;
1000058e: 0007         	movs	r7, r0
10000590: 689e         	ldr	r6, [r3, #0x8]
10000592: 40b7         	lsls	r7, r6
;     gpio_put(motor->pin3, step_sequence[step][2]);
10000594: 192e         	adds	r6, r5, r4
;     if (value)
10000596: 78b6         	ldrb	r6, [r6, #0x2]
10000598: 2e00         	cmp	r6, #0x0
1000059a: d020         	beq	0x100005de <stepper_rotate_multiple_degrees.part.0+0x1ca> @ imm = #0x40
;     sio_hw->gpio_set = mask;
1000059c: 464e         	mov	r6, r9
1000059e: 6177         	str	r7, [r6, #0x14]
;     uint32_t mask = 1ul << gpio;
100005a0: 0007         	movs	r7, r0
;     gpio_put(motor->pin4, step_sequence[step][3]);
100005a2: 192c         	adds	r4, r5, r4
;     uint32_t mask = 1ul << gpio;
100005a4: 68de         	ldr	r6, [r3, #0xc]
;     if (value)
100005a6: 78e4         	ldrb	r4, [r4, #0x3]
;     uint32_t mask = 1ul << gpio;
100005a8: 40b7         	lsls	r7, r6
;     if (value)
100005aa: 2c00         	cmp	r4, #0x0
100005ac: d014         	beq	0x100005d8 <stepper_rotate_multiple_degrees.part.0+0x1c4> @ imm = #0x28
;     sio_hw->gpio_set = mask;
100005ae: 464c         	mov	r4, r9
100005b0: 6167         	str	r7, [r4, #0x14]
;     motor->current_step = step;
100005b2: 615a         	str	r2, [r3, #0x14]
;         for (uint i = 0; i < num_motors; i++)
100005b4: 9b00         	ldr	r3, [sp]
100005b6: 3104         	adds	r1, #0x4
100005b8: 428b         	cmp	r3, r1
100005ba: d1c5         	bne	0x10000548 <stepper_rotate_multiple_degrees.part.0+0x134> @ imm = #-0x76
100005bc: e7a2         	b	0x10000504 <stepper_rotate_multiple_degrees.part.0+0xf0> @ imm = #-0xbc
;     sio_hw->gpio_clr = mask;
100005be: 464c         	mov	r4, r9
100005c0: 61a7         	str	r7, [r4, #0x18]
100005c2: e79a         	b	0x100004fa <stepper_rotate_multiple_degrees.part.0+0xe6> @ imm = #-0xcc
100005c4: 464e         	mov	r6, r9
100005c6: 61b7         	str	r7, [r6, #0x18]
100005c8: e78e         	b	0x100004e8 <stepper_rotate_multiple_degrees.part.0+0xd4> @ imm = #-0xe4
100005ca: 464e         	mov	r6, r9
100005cc: 61b7         	str	r7, [r6, #0x18]
100005ce: e782         	b	0x100004d6 <stepper_rotate_multiple_degrees.part.0+0xc2> @ imm = #-0xfc
100005d0: 464e         	mov	r6, r9
100005d2: 4647         	mov	r7, r8
100005d4: 61b7         	str	r7, [r6, #0x18]
100005d6: e775         	b	0x100004c4 <stepper_rotate_multiple_degrees.part.0+0xb0> @ imm = #-0x116
100005d8: 464c         	mov	r4, r9
100005da: 61a7         	str	r7, [r4, #0x18]
; }
100005dc: e7e9         	b	0x100005b2 <stepper_rotate_multiple_degrees.part.0+0x19e> @ imm = #-0x2e
;     sio_hw->gpio_clr = mask;
100005de: 464e         	mov	r6, r9
100005e0: 61b7         	str	r7, [r6, #0x18]
; }
100005e2: e7dd         	b	0x100005a0 <stepper_rotate_multiple_degrees.part.0+0x18c> @ imm = #-0x46
;     sio_hw->gpio_clr = mask;
100005e4: 464e         	mov	r6, r9
100005e6: 61b7         	str	r7, [r6, #0x18]
; }
100005e8: e7d1         	b	0x1000058e <stepper_rotate_multiple_degrees.part.0+0x17a> @ imm = #-0x5e
;     sio_hw->gpio_clr = mask;
100005ea: 464e         	mov	r6, r9
100005ec: 4647         	mov	r7, r8
100005ee: 61b7         	str	r7, [r6, #0x18]
; }
100005f0: e7c4         	b	0x1000057c <stepper_rotate_multiple_degrees.part.0+0x168> @ imm = #-0x78
;                 sleep_ms(motors[i]->step_delay);
100005f2: 6910         	ldr	r0, [r2, #0x10]
100005f4: f000 fc26    	bl	0x10000e44 <sleep_ms>   @ imm = #0x84c
;     for (uint step = 0; step < steps; step++)
100005f8: 2301         	movs	r3, #0x1
;                 sleep_ms(motors[i]->step_delay);
100005fa: 46b9         	mov	r9, r7
;     for (uint step = 0; step < steps; step++)
100005fc: 469c         	mov	r12, r3
100005fe: 44e1         	add	r9, r12
;                 sleep_ms(motors[i]->step_delay);
10000600: 4647         	mov	r7, r8
;     for (uint step = 0; step < steps; step++)
10000602: 45ca         	cmp	r10, r9
10000604: d000         	beq	0x10000608 <stepper_rotate_multiple_degrees.part.0+0x1f4> @ imm = #0x0
10000606: e72f         	b	0x10000468 <stepper_rotate_multiple_degrees.part.0+0x54> @ imm = #-0x1a2
10000608: e724         	b	0x10000454 <stepper_rotate_multiple_degrees.part.0+0x40> @ imm = #-0x1b8
1000060a: 46c0         	mov	r8, r8
1000060c: 00 00 b4 43  	.word	0x43b40000
10000610: 14 44 00 10  	.word	0x10004414

10000614 <stepper_init>:
; {
10000614: b5f8         	push	{r3, r4, r5, r6, r7, lr}
10000616: 4647         	mov	r7, r8
10000618: 46ce         	mov	lr, r9
1000061a: 0004         	movs	r4, r0
1000061c: b580         	push	{r7, lr}
1000061e: 4690         	mov	r8, r2
10000620: 000f         	movs	r7, r1
10000622: 001e         	movs	r6, r3
;     if (motor == NULL)
10000624: 2800         	cmp	r0, #0x0
10000626: d040         	beq	0x100006aa <stepper_init+0x96> @ imm = #0x80
;     motor->pin3 = pin3;
10000628: 6083         	str	r3, [r0, #0x8]
;     motor->pin4 = pin4;
1000062a: 9b08         	ldr	r3, [sp, #0x20]
;     motor->enabled = true;
1000062c: 2501         	movs	r5, #0x1
;     motor->pin4 = pin4;
1000062e: 60c3         	str	r3, [r0, #0xc]
;     motor->step_delay = step_delay;
10000630: 9b09         	ldr	r3, [sp, #0x24]
;     motor->pin1 = pin1;
10000632: 6001         	str	r1, [r0]
;     motor->step_delay = step_delay;
10000634: 6103         	str	r3, [r0, #0x10]
;     motor->current_step = 0;
10000636: 2300         	movs	r3, #0x0
;     motor->pin2 = pin2;
10000638: 6042         	str	r2, [r0, #0x4]
;     motor->current_step = 0;
1000063a: 6143         	str	r3, [r0, #0x14]
;     motor->enabled = true;
1000063c: 7605         	strb	r5, [r0, #0x18]
;     gpio_init(pin1);
1000063e: 0008         	movs	r0, r1
;     motor->current_step = 0;
10000640: 4699         	mov	r9, r3
;     gpio_init(pin1);
10000642: f000 f875    	bl	0x10000730 <gpio_init>  @ imm = #0xea
;     gpio_init(pin2);
10000646: 4640         	mov	r0, r8
10000648: f000 f872    	bl	0x10000730 <gpio_init>  @ imm = #0xe4
;     gpio_init(pin3);
1000064c: 0030         	movs	r0, r6
1000064e: f000 f86f    	bl	0x10000730 <gpio_init>  @ imm = #0xde
;     gpio_init(pin4);
10000652: 9808         	ldr	r0, [sp, #0x20]
10000654: f000 f86c    	bl	0x10000730 <gpio_init>  @ imm = #0xd8
;     uint32_t mask = 1ul << gpio;
10000658: 002b         	movs	r3, r5
;     sio_hw->gpio_oe_set = mask;
1000065a: 21d0         	movs	r1, #0xd0
;     uint32_t mask = 1ul << gpio;
1000065c: 40bb         	lsls	r3, r7
;     sio_hw->gpio_oe_set = mask;
1000065e: 0609         	lsls	r1, r1, #0x18
10000660: 624b         	str	r3, [r1, #0x24]
;     uint32_t mask = 1ul << gpio;
10000662: 4642         	mov	r2, r8
10000664: 002b         	movs	r3, r5
10000666: 4093         	lsls	r3, r2
;     sio_hw->gpio_oe_set = mask;
10000668: 624b         	str	r3, [r1, #0x24]
;     uint32_t mask = 1ul << gpio;
1000066a: 002b         	movs	r3, r5
1000066c: 40b3         	lsls	r3, r6
;     sio_hw->gpio_oe_set = mask;
1000066e: 624b         	str	r3, [r1, #0x24]
;     uint32_t mask = 1ul << gpio;
10000670: 002b         	movs	r3, r5
10000672: 9a08         	ldr	r2, [sp, #0x20]
10000674: 4093         	lsls	r3, r2
;     sio_hw->gpio_oe_set = mask;
10000676: 624b         	str	r3, [r1, #0x24]
;     if (!motor->enabled)
10000678: 7e23         	ldrb	r3, [r4, #0x18]
1000067a: 2b00         	cmp	r3, #0x0
1000067c: d010         	beq	0x100006a0 <stepper_init+0x8c> @ imm = #0x20
;     uint32_t mask = 1ul << gpio;
1000067e: 002a         	movs	r2, r5
10000680: 6823         	ldr	r3, [r4]
10000682: 409a         	lsls	r2, r3
;     sio_hw->gpio_set = mask;
10000684: 614a         	str	r2, [r1, #0x14]
;     uint32_t mask = 1ul << gpio;
10000686: 002a         	movs	r2, r5
10000688: 6863         	ldr	r3, [r4, #0x4]
1000068a: 409a         	lsls	r2, r3
;     sio_hw->gpio_clr = mask;
1000068c: 618a         	str	r2, [r1, #0x18]
;     uint32_t mask = 1ul << gpio;
1000068e: 002a         	movs	r2, r5
10000690: 68a3         	ldr	r3, [r4, #0x8]
10000692: 409a         	lsls	r2, r3
10000694: 68e3         	ldr	r3, [r4, #0xc]
;     sio_hw->gpio_clr = mask;
10000696: 618a         	str	r2, [r1, #0x18]
;     uint32_t mask = 1ul << gpio;
10000698: 409d         	lsls	r5, r3
;     motor->current_step = step;
1000069a: 464b         	mov	r3, r9
;     sio_hw->gpio_clr = mask;
1000069c: 618d         	str	r5, [r1, #0x18]
;     motor->current_step = step;
1000069e: 6163         	str	r3, [r4, #0x14]
;     return true;
100006a0: 2001         	movs	r0, #0x1
; }
100006a2: bcc0         	pop	{r6, r7}
100006a4: 46b9         	mov	r9, r7
100006a6: 46b0         	mov	r8, r6
100006a8: bdf8         	pop	{r3, r4, r5, r6, r7, pc}
;         return false;
100006aa: 2000         	movs	r0, #0x0
100006ac: e7f9         	b	0x100006a2 <stepper_init+0x8e> @ imm = #-0xe
100006ae: 46c0         	mov	r8, r8

100006b0 <stepper_demo_sequence>:
; {
100006b0: b5f8         	push	{r3, r4, r5, r6, r7, lr}
100006b2: 46ce         	mov	lr, r9
100006b4: 4647         	mov	r7, r8
100006b6: 0004         	movs	r4, r0
100006b8: 000d         	movs	r5, r1
100006ba: 4690         	mov	r8, r2
100006bc: 4699         	mov	r9, r3
100006be: b580         	push	{r7, lr}
;     if (motors == NULL || num_motors == 0)
100006c0: 2800         	cmp	r0, #0x0
100006c2: d001         	beq	0x100006c8 <stepper_demo_sequence+0x18> @ imm = #0x2
100006c4: 2900         	cmp	r1, #0x0
100006c6: d103         	bne	0x100006d0 <stepper_demo_sequence+0x20> @ imm = #0x6
; }
100006c8: bcc0         	pop	{r6, r7}
100006ca: 46b9         	mov	r9, r7
100006cc: 46b0         	mov	r8, r6
100006ce: bdf8         	pop	{r3, r4, r5, r6, r7, pc}
;     printf("Running stepper motor demonstration sequence...\n");
100006d0: 4813         	ldr	r0, [pc, #0x4c]         @ 0x10000720 <stepper_demo_sequence+0x70>
100006d2: f003 fc55    	bl	0x10003f80 <stdio_puts> @ imm = #0x38aa
;     printf("Rotating all motors clockwise %.1f degrees\n", degrees);
100006d6: 4640         	mov	r0, r8
100006d8: f001 fde8    	bl	0x100022ac <__wrap___aeabi_f2d> @ imm = #0x1bd0
100006dc: 0006         	movs	r6, r0
100006de: 000f         	movs	r7, r1
100006e0: 0032         	movs	r2, r6
100006e2: 000b         	movs	r3, r1
100006e4: 480f         	ldr	r0, [pc, #0x3c]         @ 0x10000724 <stepper_demo_sequence+0x74>
100006e6: f003 fccf    	bl	0x10004088 <stdio_printf> @ imm = #0x399e
;     if (motors == NULL || num_motors == 0)
100006ea: 0029         	movs	r1, r5
100006ec: 4642         	mov	r2, r8
100006ee: 2300         	movs	r3, #0x0
100006f0: 0020         	movs	r0, r4
100006f2: f7ff fe8f    	bl	0x10000414 <stepper_rotate_multiple_degrees.part.0> @ imm = #-0x2e2
;     sleep_ms(pause_ms);
100006f6: 4648         	mov	r0, r9
100006f8: f000 fba4    	bl	0x10000e44 <sleep_ms>   @ imm = #0x748
;     printf("Rotating all motors counter-clockwise %.1f degrees\n", degrees);
100006fc: 0032         	movs	r2, r6
100006fe: 003b         	movs	r3, r7
10000700: 4809         	ldr	r0, [pc, #0x24]         @ 0x10000728 <stepper_demo_sequence+0x78>
10000702: f003 fcc1    	bl	0x10004088 <stdio_printf> @ imm = #0x3982
;     if (motors == NULL || num_motors == 0)
10000706: 2301         	movs	r3, #0x1
10000708: 4642         	mov	r2, r8
1000070a: 0029         	movs	r1, r5
1000070c: 0020         	movs	r0, r4
1000070e: f7ff fe81    	bl	0x10000414 <stepper_rotate_multiple_degrees.part.0> @ imm = #-0x2fe
;     sleep_ms(pause_ms);
10000712: 4648         	mov	r0, r9
10000714: f000 fb96    	bl	0x10000e44 <sleep_ms>   @ imm = #0x72c
;     printf("Demonstration sequence complete\n");
10000718: 4804         	ldr	r0, [pc, #0x10]         @ 0x1000072c <stepper_demo_sequence+0x7c>
1000071a: f003 fc31    	bl	0x10003f80 <stdio_puts> @ imm = #0x3862
1000071e: e7d3         	b	0x100006c8 <stepper_demo_sequence+0x18> @ imm = #-0x5a
10000720: 88 42 00 10  	.word	0x10004288
10000724: b8 42 00 10  	.word	0x100042b8
10000728: e4 42 00 10  	.word	0x100042e4
1000072c: 18 43 00 10  	.word	0x10004318

10000730 <gpio_init>:
;     uint32_t mask = 1ul << gpio;
10000730: 2301         	movs	r3, #0x1
;     sio_hw->gpio_oe_clr = mask;
10000732: 22d0         	movs	r2, #0xd0
;     uint32_t mask = 1ul << gpio;
10000734: 4083         	lsls	r3, r0
;     sio_hw->gpio_oe_clr = mask;
10000736: 0612         	lsls	r2, r2, #0x18
10000738: 6293         	str	r3, [r2, #0x28]
;     sio_hw->gpio_clr = mask;
1000073a: 6193         	str	r3, [r2, #0x18]
;     hw_write_masked(&pads_bank0_hw->io[gpio],
1000073c: 4a09         	ldr	r2, [pc, #0x24]         @ 0x10000764 <gpio_init+0x34>
1000073e: 0083         	lsls	r3, r0, #0x2
10000740: 189a         	adds	r2, r3, r2
;     hw_xor_bits(addr, (*addr ^ values) & write_mask);
10000742: 6811         	ldr	r1, [r2]
10000744: 2240         	movs	r2, #0x40
10000746: 4051         	eors	r1, r2
10000748: 3280         	adds	r2, #0x80
1000074a: 400a         	ands	r2, r1
;     *(io_rw_32 *) hw_xor_alias_untyped((volatile void *) addr) = mask;
1000074c: 4906         	ldr	r1, [pc, #0x18]         @ 0x10000768 <gpio_init+0x38>
;     io_bank0_hw->io[gpio].ctrl = fn << IO_BANK0_GPIO0_CTRL_FUNCSEL_LSB;
1000074e: 00c0         	lsls	r0, r0, #0x3
;     *(io_rw_32 *) hw_xor_alias_untyped((volatile void *) addr) = mask;
10000750: 468c         	mov	r12, r1
10000752: 4463         	add	r3, r12
10000754: 601a         	str	r2, [r3]
;     io_bank0_hw->io[gpio].ctrl = fn << IO_BANK0_GPIO0_CTRL_FUNCSEL_LSB;
10000756: 4b05         	ldr	r3, [pc, #0x14]         @ 0x1000076c <gpio_init+0x3c>
10000758: 469c         	mov	r12, r3
1000075a: 2305         	movs	r3, #0x5
1000075c: 4460         	add	r0, r12
1000075e: 6043         	str	r3, [r0, #0x4]
; }
10000760: 4770         	bx	lr
10000762: 46c0         	mov	r8, r8
10000764: 04 c0 01 40  	.word	0x4001c004
10000768: 04 d0 01 40  	.word	0x4001d004
1000076c: 00 40 01 40  	.word	0x40014000

10000770 <panic>:
; void __attribute__((noreturn)) __printflike(1, 0) panic(const char *fmt, ...) {
10000770: b40f         	push	{r0, r1, r2, r3}
10000772: b500         	push	{lr}
;     puts("\n*** PANIC ***\n");
10000774: 4808         	ldr	r0, [pc, #0x20]         @ 0x10000798 <panic+0x28>
; void __attribute__((noreturn)) __printflike(1, 0) panic(const char *fmt, ...) {
10000776: b083         	sub	sp, #0xc
;     puts("\n*** PANIC ***\n");
10000778: f003 fc02    	bl	0x10003f80 <stdio_puts> @ imm = #0x3804
;     if (fmt) {
1000077c: 9b04         	ldr	r3, [sp, #0x10]
1000077e: 2b00         	cmp	r3, #0x0
10000780: d007         	beq	0x10000792 <panic+0x22> @ imm = #0xe
;         va_start(args, fmt);
10000782: a905         	add	r1, sp, #0x14
;         weak_raw_vprintf(fmt, args);
10000784: 0018         	movs	r0, r3
;         va_start(args, fmt);
10000786: 9101         	str	r1, [sp, #0x4]
;         weak_raw_vprintf(fmt, args);
10000788: f003 fa6a    	bl	0x10003c60 <weak_raw_vprintf> @ imm = #0x34d4
;         puts("\n");
1000078c: 4803         	ldr	r0, [pc, #0xc]          @ 0x1000079c <panic+0x2c>
1000078e: f003 fbf7    	bl	0x10003f80 <stdio_puts> @ imm = #0x37ee
;     _exit(1);
10000792: 2001         	movs	r0, #0x1
10000794: f003 fa7c    	bl	0x10003c90 <_exit>      @ imm = #0x34f8
10000798: 38 43 00 10  	.word	0x10004338
1000079c: 48 43 00 10  	.word	0x10004348

100007a0 <hw_claim_or_assert>:
; void hw_claim_or_assert(uint8_t *bits, uint bit_index, const char *message) {
100007a0: b570         	push	{r4, r5, r6, lr}
;     pico_default_asm_volatile (
100007a2: f3ef 8c10    	mrs	r12, primask
100007a6: b672         	cpsid i
;     while (__builtin_expect(!*lock, 0)) { // read from spinlock register (tries to acquire the lock)
100007a8: 4d0d         	ldr	r5, [pc, #0x34]         @ 0x100007e0 <hw_claim_or_assert+0x40>
100007aa: 682b         	ldr	r3, [r5]
100007ac: 2b00         	cmp	r3, #0x0
100007ae: d0fc         	beq	0x100007aa <hw_claim_or_assert+0xa> @ imm = #-0x8
;     pico_default_asm_volatile ("dmb" : : : "memory");
100007b0: f3bf 8f5f    	dmb	sy
;     return (bits[bit_index >> 3u] & (1u << (bit_index & 7u)));
100007b4: 2407         	movs	r4, #0x7
100007b6: 08cb         	lsrs	r3, r1, #0x3
100007b8: 18c6         	adds	r6, r0, r3
100007ba: 5cc0         	ldrb	r0, [r0, r3]
100007bc: 2301         	movs	r3, #0x1
100007be: 400c         	ands	r4, r1
100007c0: 40a3         	lsls	r3, r4
100007c2: 001c         	movs	r4, r3
100007c4: 4004         	ands	r4, r0
;     if (hw_is_claimed(bits, bit_index)) {
100007c6: 4203         	tst	r3, r0
100007c8: d107         	bne	0x100007da <hw_claim_or_assert+0x3a> @ imm = #0xe
;         bits[bit_index >> 3u] |= (uint8_t)(1u << (bit_index & 7u));
100007ca: 4318         	orrs	r0, r3
100007cc: 7030         	strb	r0, [r6]
;     pico_default_asm_volatile ("dmb" : : : "memory");
100007ce: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
100007d2: 602c         	str	r4, [r5]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
100007d4: f38c 8810    	msr	primask, r12
; }
100007d8: bd70         	pop	{r4, r5, r6, pc}
;         panic(message, bit_index);
100007da: 0010         	movs	r0, r2
100007dc: f7ff ffc8    	bl	0x10000770 <panic>      @ imm = #-0x70
100007e0: 2c 01 00 d0  	.word	0xd000012c

100007e4 <next_striped_spin_lock_num>:
;     uint rc = striped_spin_lock_num++;
100007e4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x100007f8 <next_striped_spin_lock_num+0x14>
100007e6: 7810         	ldrb	r0, [r2]
100007e8: 1c43         	adds	r3, r0, #0x1
100007ea: b2db         	uxtb	r3, r3
;     if (striped_spin_lock_num > PICO_SPINLOCK_ID_STRIPED_LAST) {
100007ec: 2b17         	cmp	r3, #0x17
100007ee: d900         	bls	0x100007f2 <next_striped_spin_lock_num+0xe> @ imm = #0x0
100007f0: 2310         	movs	r3, #0x10
;     uint rc = striped_spin_lock_num++;
100007f2: 7013         	strb	r3, [r2]
; }
100007f4: 4770         	bx	lr
100007f6: 46c0         	mov	r8, r8
100007f8: 98 01 00 20  	.word	0x20000198

100007fc <spin_locks_reset>:
;     *lock = 0; // write to spinlock register (release lock)
100007fc: 2100         	movs	r1, #0x0
; void spin_locks_reset(void) {
100007fe: 4b04         	ldr	r3, [pc, #0x10]         @ 0x10000810 <spin_locks_reset+0x14>
;     for (uint i = 0; i < NUM_SPIN_LOCKS; i++) {
10000800: 4a04         	ldr	r2, [pc, #0x10]         @ 0x10000814 <spin_locks_reset+0x18>
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000802: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
10000806: c302         	stm	r3!, {r1}
;     for (uint i = 0; i < NUM_SPIN_LOCKS; i++) {
10000808: 4293         	cmp	r3, r2
1000080a: d1fa         	bne	0x10000802 <spin_locks_reset+0x6> @ imm = #-0xc
; }
1000080c: 4770         	bx	lr
1000080e: 46c0         	mov	r8, r8
10000810: 00 01 00 d0  	.word	0xd0000100
10000814: 80 01 00 d0  	.word	0xd0000180

10000818 <runtime_init_per_core_irq_priorities>:
;         *p++ = prio4;
10000818: 4b05         	ldr	r3, [pc, #0x14]         @ 0x10000830 <runtime_init_per_core_irq_priorities+0x18>
1000081a: 4a06         	ldr	r2, [pc, #0x18]         @ 0x10000834 <runtime_init_per_core_irq_priorities+0x1c>
1000081c: 6013         	str	r3, [r2]
1000081e: 4a06         	ldr	r2, [pc, #0x18]         @ 0x10000838 <runtime_init_per_core_irq_priorities+0x20>
10000820: 6013         	str	r3, [r2]
10000822: 6053         	str	r3, [r2, #0x4]
10000824: 6093         	str	r3, [r2, #0x8]
10000826: 60d3         	str	r3, [r2, #0xc]
10000828: 6113         	str	r3, [r2, #0x10]
1000082a: 6153         	str	r3, [r2, #0x14]
1000082c: 6193         	str	r3, [r2, #0x18]
; }
1000082e: 4770         	bx	lr
10000830: 80 80 80 80  	.word	0x80808080
10000834: 00 e4 00 e0  	.word	0xe000e400
10000838: 04 e4 00 e0  	.word	0xe000e404

1000083c <irq_set_enabled>:
;     irq_set_mask_n_enabled(num / 32, 1u << (num % 32), enabled);
1000083c: 231f         	movs	r3, #0x1f
1000083e: 4018         	ands	r0, r3
10000840: 3b1e         	subs	r3, #0x1e
10000842: 4083         	lsls	r3, r0
;     if (enabled) {
10000844: 2900         	cmp	r1, #0x0
10000846: d005         	beq	0x10000854 <irq_set_enabled+0x18> @ imm = #0xa
;         nvic_hw->icpr = mask;
10000848: 21c0         	movs	r1, #0xc0
1000084a: 4a04         	ldr	r2, [pc, #0x10]         @ 0x1000085c <irq_set_enabled+0x20>
1000084c: 0049         	lsls	r1, r1, #0x1
1000084e: 5053         	str	r3, [r2, r1]
;         nvic_hw->iser = mask;
10000850: 6013         	str	r3, [r2]
; }
10000852: 4770         	bx	lr
;         nvic_hw->icer = mask;
10000854: 2280         	movs	r2, #0x80
10000856: 4901         	ldr	r1, [pc, #0x4]          @ 0x1000085c <irq_set_enabled+0x20>
10000858: 508b         	str	r3, [r1, r2]
; }
1000085a: e7fa         	b	0x10000852 <irq_set_enabled+0x16> @ imm = #-0xc
1000085c: 00 e1 00 e0  	.word	0xe000e100

10000860 <irq_set_exclusive_handler>:
; void irq_set_exclusive_handler(uint num, irq_handler_t handler) {
10000860: b570         	push	{r4, r5, r6, lr}
10000862: 000d         	movs	r5, r1
;     pico_default_asm_volatile (
10000864: f3ef 8610    	mrs	r6, primask
10000868: b672         	cpsid i
;     while (__builtin_expect(!*lock, 0)) { // read from spinlock register (tries to acquire the lock)
1000086a: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x100008a8 <irq_set_exclusive_handler+0x48>
1000086c: 6813         	ldr	r3, [r2]
1000086e: 2b00         	cmp	r3, #0x0
10000870: d0fc         	beq	0x1000086c <irq_set_exclusive_handler+0xc> @ imm = #-0x8
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000872: f3bf 8f5f    	dmb	sy
;     return (irq_handler_t *) scb_hw->vtor;
10000876: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x100008ac <irq_set_exclusive_handler+0x4c>
;     return get_vtable()[VTABLE_FIRST_IRQ + num];
10000878: 3010         	adds	r0, #0x10
;     return (irq_handler_t *) scb_hw->vtor;
1000087a: 689b         	ldr	r3, [r3, #0x8]
;     return get_vtable()[VTABLE_FIRST_IRQ + num];
1000087c: 0084         	lsls	r4, r0, #0x2
1000087e: 591b         	ldr	r3, [r3, r4]
;     hard_assert(current == __unhandled_user_irq || current == handler);
10000880: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x100008b0 <irq_set_exclusive_handler+0x50>
10000882: 4293         	cmp	r3, r2
10000884: d003         	beq	0x1000088e <irq_set_exclusive_handler+0x2e> @ imm = #0x6
10000886: 429d         	cmp	r5, r3
10000888: d001         	beq	0x1000088e <irq_set_exclusive_handler+0x2e> @ imm = #0x2
;         hard_assertion_failure();
1000088a: f000 fda1    	bl	0x100013d0 <hard_assertion_failure> @ imm = #0xb42
;     return (irq_handler_t *) scb_hw->vtor;
1000088e: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x100008ac <irq_set_exclusive_handler+0x4c>
10000890: 689b         	ldr	r3, [r3, #0x8]
;     get_vtable()[VTABLE_FIRST_IRQ + num] = handler;
10000892: 511d         	str	r5, [r3, r4]
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000894: f3bf 8f5f    	dmb	sy
10000898: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
1000089c: 2200         	movs	r2, #0x0
1000089e: 4b02         	ldr	r3, [pc, #0x8]          @ 0x100008a8 <irq_set_exclusive_handler+0x48>
100008a0: 601a         	str	r2, [r3]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
100008a2: f386 8810    	msr	primask, r6
; }
100008a6: bd70         	pop	{r4, r5, r6, pc}
100008a8: 24 01 00 d0  	.word	0xd0000124
100008ac: 00 ed 00 e0  	.word	0xe000ed00
100008b0: cd 01 00 10  	.word	0x100001cd

100008b4 <lock_init>:
;     return (spin_lock_t *) (SIO_BASE + SIO_SPINLOCK0_OFFSET + lock_num * 4);
100008b4: 4b02         	ldr	r3, [pc, #0x8]          @ 0x100008c0 <lock_init+0xc>
100008b6: 469c         	mov	r12, r3
100008b8: 4461         	add	r1, r12
100008ba: 0089         	lsls	r1, r1, #0x2
;     core->spin_lock = spin_lock_instance(lock_num);
100008bc: 6001         	str	r1, [r0]
; }
100008be: 4770         	bx	lr
100008c0: 40 00 00 34  	.word	0x34000040

100008c4 <runtime_init_mutex>:
; void __weak runtime_init_mutex(void) {
100008c4: b570         	push	{r4, r5, r6, lr}
;     for (lock_core_t *l = &__mutex_array_start; l < &__mutex_array_end; ) {
100008c6: 4c11         	ldr	r4, [pc, #0x44]         @ 0x1000090c <runtime_init_mutex+0x48>
100008c8: 4d11         	ldr	r5, [pc, #0x44]         @ 0x10000910 <runtime_init_mutex+0x4c>
100008ca: 42ac         	cmp	r4, r5
100008cc: d20f         	bhs	0x100008ee <runtime_init_mutex+0x2a> @ imm = #0x1e
;     mtx->owner = LOCK_INVALID_OWNER_ID;
100008ce: 26ff         	movs	r6, #0xff
;         if (l->spin_lock) {
100008d0: 6823         	ldr	r3, [r4]
100008d2: 2b00         	cmp	r3, #0x0
100008d4: d00c         	beq	0x100008f0 <runtime_init_mutex+0x2c> @ imm = #0x18
;     lock_init(&mtx->core, next_striped_spin_lock_num());
100008d6: f7ff ff85    	bl	0x100007e4 <next_striped_spin_lock_num> @ imm = #-0xf6
100008da: 0001         	movs	r1, r0
100008dc: 0020         	movs	r0, r4
100008de: f7ff ffe9    	bl	0x100008b4 <lock_init>  @ imm = #-0x2e
;     mtx->owner = LOCK_INVALID_OWNER_ID;
100008e2: 80a6         	strh	r6, [r4, #0x4]
;     pico_default_asm_volatile ("dmb" : : : "memory");
100008e4: f3bf 8f5f    	dmb	sy
;             l = &rm[1].core; // next
100008e8: 3408         	adds	r4, #0x8
;     for (lock_core_t *l = &__mutex_array_start; l < &__mutex_array_end; ) {
100008ea: 42ac         	cmp	r4, r5
100008ec: d3f0         	blo	0x100008d0 <runtime_init_mutex+0xc> @ imm = #-0x20
; }
100008ee: bd70         	pop	{r4, r5, r6, pc}
;     lock_init(&mtx->core, next_striped_spin_lock_num());
100008f0: f7ff ff78    	bl	0x100007e4 <next_striped_spin_lock_num> @ imm = #-0x110
100008f4: 0001         	movs	r1, r0
100008f6: 0020         	movs	r0, r4
100008f8: f7ff ffdc    	bl	0x100008b4 <lock_init>  @ imm = #-0x48
;     mtx->owner = LOCK_INVALID_OWNER_ID;
100008fc: 7126         	strb	r6, [r4, #0x4]
;     pico_default_asm_volatile ("dmb" : : : "memory");
100008fe: f3bf 8f5f    	dmb	sy
;             l = &m[1].core; // next
10000902: 3408         	adds	r4, #0x8
;     for (lock_core_t *l = &__mutex_array_start; l < &__mutex_array_end; ) {
10000904: 42ac         	cmp	r4, r5
10000906: d3e3         	blo	0x100008d0 <runtime_init_mutex+0xc> @ imm = #-0x3a
10000908: e7f1         	b	0x100008ee <runtime_init_mutex+0x2a> @ imm = #-0x1e
1000090a: 46c0         	mov	r8, r8
1000090c: e0 01 00 20  	.word	0x200001e0
10000910: e8 01 00 20  	.word	0x200001e8

10000914 <sleep_until_callback>:
;     uint32_t save = spin_lock_blocking(sleep_notifier.spin_lock);
10000914: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x10000940 <sleep_until_callback+0x2c>
10000916: 6819         	ldr	r1, [r3]
;     pico_default_asm_volatile (
10000918: f3ef 8010    	mrs	r0, primask
1000091c: b672         	cpsid i
;     while (__builtin_expect(!*lock, 0)) { // read from spinlock register (tries to acquire the lock)
1000091e: 680a         	ldr	r2, [r1]
10000920: 2a00         	cmp	r2, #0x0
10000922: d0fc         	beq	0x1000091e <sleep_until_callback+0xa> @ imm = #-0x8
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000924: f3bf 8f5f    	dmb	sy
;     lock_internal_spin_unlock_with_notify(&sleep_notifier, save);
10000928: 681b         	ldr	r3, [r3]
;     pico_default_asm_volatile ("dmb" : : : "memory");
1000092a: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
1000092e: 2200         	movs	r2, #0x0
10000930: 601a         	str	r2, [r3]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
10000932: f380 8810    	msr	primask, r0
;     pico_default_asm_volatile ("sev");
10000936: bf40         	sev
; }
10000938: 2000         	movs	r0, #0x0
1000093a: 2100         	movs	r1, #0x0
1000093c: 4770         	bx	lr
1000093e: 46c0         	mov	r8, r8
10000940: cc 05 00 20  	.word	0x200005cc

10000944 <alarm_pool_irq_handler>:
; static void alarm_pool_irq_handler(void) {
10000944: b5f0         	push	{r4, r5, r6, r7, lr}
10000946: 46de         	mov	lr, r11
10000948: 4657         	mov	r7, r10
1000094a: 464e         	mov	r6, r9
1000094c: 4645         	mov	r5, r8
1000094e: b5e0         	push	{r5, r6, r7, lr}
10000950: b087         	sub	sp, #0x1c
;     pico_default_asm_volatile ( "mrs %0, ipsr" : "=l" (exception));
10000952: f3ef 8305    	mrs	r3, ipsr
;     *alarm_num = TIMER_ALARM_NUM_FROM_IRQ(irq_num);
10000956: 2203         	movs	r2, #0x3
;     hw_clear_bits(&timer_hw_from_timer(timer)->intf, 1u << alarm_num);
10000958: 2501         	movs	r5, #0x1
1000095a: 401a         	ands	r2, r3
1000095c: 4095         	lsls	r5, r2
;     alarm_pool_t *pool = pools[timer_num][timer_alarm_num];
1000095e: 0091         	lsls	r1, r2, #0x2
10000960: 4688         	mov	r8, r1
;     hw_clear_bits(&timer_hw_from_timer(timer)->intf, 1u << alarm_num);
10000962: 46a9         	mov	r9, r5
;     alarm_pool_t *pool = pools[timer_num][timer_alarm_num];
10000964: 4bb3         	ldr	r3, [pc, #0x2cc]        @ 0x10000c34 <alarm_pool_irq_handler+0x2f0>
10000966: 9203         	str	r2, [sp, #0xc]
10000968: 585c         	ldr	r4, [r3, r1]
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
1000096a: 4bb3         	ldr	r3, [pc, #0x2cc]        @ 0x10000c38 <alarm_pool_irq_handler+0x2f4>
1000096c: 601d         	str	r5, [r3]
;                     if (earliest_entry->callback == repeating_timer_marker) {
1000096e: 4bb3         	ldr	r3, [pc, #0x2cc]        @ 0x10000c3c <alarm_pool_irq_handler+0x2f8>
10000970: 9304         	str	r3, [sp, #0x10]
;     timer_hw_from_timer(timer)->intr = 1u << alarm_num;
10000972: 464b         	mov	r3, r9
10000974: 48b2         	ldr	r0, [pc, #0x2c8]        @ 0x10000c40 <alarm_pool_irq_handler+0x2fc>
10000976: 6343         	str	r3, [r0, #0x34]
;         int16_t earliest_index = pool->ordered_head;
10000978: 2308         	movs	r3, #0x8
1000097a: 5ee5         	ldrsh	r5, [r4, r3]
;         if (earliest_index >= 0) {
1000097c: 2d00         	cmp	r5, #0x0
1000097e: da37         	bge	0x100009f0 <alarm_pool_irq_handler+0xac> @ imm = #0x6e
;         if (pool->new_head >= 0) {
10000980: 88a3         	ldrh	r3, [r4, #0x4]
10000982: b21b         	sxth	r3, r3
10000984: 2b00         	cmp	r3, #0x0
10000986: db00         	blt	0x1000098a <alarm_pool_irq_handler+0x46> @ imm = #0x0
10000988: e0ad         	b	0x10000ae6 <alarm_pool_irq_handler+0x1a2> @ imm = #0x15a
;         if (pool->has_pending_cancellations) {
1000098a: 79a3         	ldrb	r3, [r4, #0x6]
1000098c: 2b00         	cmp	r3, #0x0
1000098e: d000         	beq	0x10000992 <alarm_pool_irq_handler+0x4e> @ imm = #0x0
10000990: e0ee         	b	0x10000b70 <alarm_pool_irq_handler+0x22c> @ imm = #0x1dc
;         earliest_index = pool->ordered_head;
10000992: 2308         	movs	r3, #0x8
10000994: 5ee0         	ldrsh	r0, [r4, r3]
;         if (earliest_index < 0) break;
10000996: 2800         	cmp	r0, #0x0
10000998: db20         	blt	0x100009dc <alarm_pool_irq_handler+0x98> @ imm = #0x40
;         earliest_target = earliest_entry->target;
1000099a: 0043         	lsls	r3, r0, #0x1
1000099c: 6962         	ldr	r2, [r4, #0x14]
1000099e: 181b         	adds	r3, r3, r0
100009a0: 00db         	lsls	r3, r3, #0x3
100009a2: 18d3         	adds	r3, r2, r3
100009a4: 689e         	ldr	r6, [r3, #0x8]
100009a6: 68dd         	ldr	r5, [r3, #0xc]
;         if (earliest_target != -1) { // cancelled alarm has target of -1
100009a8: 1c73         	adds	r3, r6, #0x1
100009aa: d100         	bne	0x100009ae <alarm_pool_irq_handler+0x6a> @ imm = #0x0
100009ac: e111         	b	0x10000bd2 <alarm_pool_irq_handler+0x28e> @ imm = #0x222
;     return timer->timerawl;
100009ae: 48a4         	ldr	r0, [pc, #0x290]        @ 0x10000c40 <alarm_pool_irq_handler+0x2fc>
100009b0: 0001         	movs	r1, r0
100009b2: 4441         	add	r1, r8
100009b4: 6a82         	ldr	r2, [r0, #0x28]
;     uint32_t time_til_alarm = timer_hw_from_timer(timer)->alarm[alarm_num] - current;
100009b6: 690b         	ldr	r3, [r1, #0x10]
;     uint32_t time_til_target = (uint32_t) target - current;
100009b8: 1ab7         	subs	r7, r6, r2
;     uint32_t time_til_alarm = timer_hw_from_timer(timer)->alarm[alarm_num] - current;
100009ba: 1a9b         	subs	r3, r3, r2
;     if (time_til_target < time_til_alarm || (timer_hw_from_timer(timer)->armed & (1 << alarm_num)) == 0) {
100009bc: 429f         	cmp	r7, r3
100009be: d315         	blo	0x100009ec <alarm_pool_irq_handler+0xa8> @ imm = #0x2a
100009c0: 2301         	movs	r3, #0x1
100009c2: 6a02         	ldr	r2, [r0, #0x20]
100009c4: 9803         	ldr	r0, [sp, #0xc]
100009c6: 4083         	lsls	r3, r0
100009c8: 421a         	tst	r2, r3
100009ca: d00f         	beq	0x100009ec <alarm_pool_irq_handler+0xa8> @ imm = #0x1e
;     return timer_time_us_64(timer_hw_from_timer(timer));
100009cc: 489c         	ldr	r0, [pc, #0x270]        @ 0x10000c40 <alarm_pool_irq_handler+0x2fc>
100009ce: f000 fb47    	bl	0x10001060 <timer_time_us_64> @ imm = #0x68e
;     } while ((earliest_target - (int64_t)ta_time_us_64(timer)) <= 0);
100009d2: 428d         	cmp	r5, r1
100009d4: dc02         	bgt	0x100009dc <alarm_pool_irq_handler+0x98> @ imm = #0x4
100009d6: d1cc         	bne	0x10000972 <alarm_pool_irq_handler+0x2e> @ imm = #-0x68
100009d8: 4286         	cmp	r6, r0
100009da: d9ca         	bls	0x10000972 <alarm_pool_irq_handler+0x2e> @ imm = #-0x6c
;     pico_default_asm_volatile ("sev");
100009dc: bf40         	sev
; }
100009de: b007         	add	sp, #0x1c
100009e0: bcf0         	pop	{r4, r5, r6, r7}
100009e2: 46bb         	mov	r11, r7
100009e4: 46b2         	mov	r10, r6
100009e6: 46a9         	mov	r9, r5
100009e8: 46a0         	mov	r8, r4
100009ea: bdf0         	pop	{r4, r5, r6, r7, pc}
;         timer_hw_from_timer(timer)->alarm[alarm_num] = (uint32_t) target;
100009ec: 610e         	str	r6, [r1, #0x10]
100009ee: e7ed         	b	0x100009cc <alarm_pool_irq_handler+0x88> @ imm = #-0x26
;             alarm_pool_entry_t *earliest_entry = &pool->entries[earliest_index];
100009f0: 6962         	ldr	r2, [r4, #0x14]
100009f2: 006b         	lsls	r3, r5, #0x1
100009f4: 4692         	mov	r10, r2
100009f6: 195b         	adds	r3, r3, r5
100009f8: 00db         	lsls	r3, r3, #0x3
100009fa: 449a         	add	r10, r3
;             earliest_target = earliest_entry->target;
100009fc: 4653         	mov	r3, r10
100009fe: 689e         	ldr	r6, [r3, #0x8]
10000a00: 68df         	ldr	r7, [r3, #0xc]
;     return timer_time_us_64(timer_hw_from_timer(timer));
10000a02: f000 fb2d    	bl	0x10001060 <timer_time_us_64> @ imm = #0x65a
;             if (((int64_t)ta_time_us_64(timer) - earliest_target) >= 0) {
10000a06: 428f         	cmp	r7, r1
10000a08: dcba         	bgt	0x10000980 <alarm_pool_irq_handler+0x3c> @ imm = #-0x8c
10000a0a: d100         	bne	0x10000a0e <alarm_pool_irq_handler+0xca> @ imm = #0x0
10000a0c: e103         	b	0x10000c16 <alarm_pool_irq_handler+0x2d2> @ imm = #0x206
;                 if (earliest_target >= 0) {
10000a0e: 2f00         	cmp	r7, #0x0
10000a10: da00         	bge	0x10000a14 <alarm_pool_irq_handler+0xd0> @ imm = #0x0
10000a12: e0e8         	b	0x10000be6 <alarm_pool_irq_handler+0x2a2> @ imm = #0x1d0
;                         repeating_timer_t *rpt = (repeating_timer_t *)earliest_entry->user_data;
10000a14: 4652         	mov	r2, r10
;                     if (earliest_entry->callback == repeating_timer_marker) {
10000a16: 4653         	mov	r3, r10
;                         repeating_timer_t *rpt = (repeating_timer_t *)earliest_entry->user_data;
10000a18: 6952         	ldr	r2, [r2, #0x14]
;                     if (earliest_entry->callback == repeating_timer_marker) {
10000a1a: 691b         	ldr	r3, [r3, #0x10]
;                         repeating_timer_t *rpt = (repeating_timer_t *)earliest_entry->user_data;
10000a1c: 4693         	mov	r11, r2
;                     if (earliest_entry->callback == repeating_timer_marker) {
10000a1e: 9a04         	ldr	r2, [sp, #0x10]
10000a20: 4293         	cmp	r3, r2
10000a22: d100         	bne	0x10000a26 <alarm_pool_irq_handler+0xe2> @ imm = #0x0
10000a24: e0d9         	b	0x10000bda <alarm_pool_irq_handler+0x296> @ imm = #0x1b2
;                         alarm_id_t id = make_alarm_id(pool->ordered_head, earliest_entry->sequence);
10000a26: 4652         	mov	r2, r10
10000a28: 2108         	movs	r1, #0x8
10000a2a: 5e60         	ldrsh	r0, [r4, r1]
10000a2c: 8852         	ldrh	r2, [r2, #0x2]
;     return index << 16 | counter;
10000a2e: 0400         	lsls	r0, r0, #0x10
;                         delta = earliest_entry->callback(id, earliest_entry->user_data);
10000a30: 4659         	mov	r1, r11
;     return index << 16 | counter;
10000a32: 4310         	orrs	r0, r2
;                         delta = earliest_entry->callback(id, earliest_entry->user_data);
10000a34: 4798         	blx	r3
10000a36: 9000         	str	r0, [sp]
10000a38: 9101         	str	r1, [sp, #0x4]
;                 if (delta) {
10000a3a: 9900         	ldr	r1, [sp]
10000a3c: 9a01         	ldr	r2, [sp, #0x4]
10000a3e: 000b         	movs	r3, r1
10000a40: 0010         	movs	r0, r2
10000a42: 4313         	orrs	r3, r2
10000a44: d100         	bne	0x10000a48 <alarm_pool_irq_handler+0x104> @ imm = #0x0
10000a46: e0ce         	b	0x10000be6 <alarm_pool_irq_handler+0x2a2> @ imm = #0x19c
;                     if (delta < 0) {
10000a48: 0013         	movs	r3, r2
10000a4a: 000a         	movs	r2, r1
;                         next_time = earliest_target - delta;
10000a4c: 1ab6         	subs	r6, r6, r2
10000a4e: 419f         	sbcs	r7, r3
;                     if (delta < 0) {
10000a50: 2800         	cmp	r0, #0x0
10000a52: db06         	blt	0x10000a62 <alarm_pool_irq_handler+0x11e> @ imm = #0xc
;     return timer_time_us_64(timer_hw_from_timer(timer));
10000a54: 487a         	ldr	r0, [pc, #0x1e8]        @ 0x10000c40 <alarm_pool_irq_handler+0x2fc>
10000a56: f000 fb03    	bl	0x10001060 <timer_time_us_64> @ imm = #0x606
;                         next_time = (int64_t) ta_time_us_64(timer) + delta;
10000a5a: 9e00         	ldr	r6, [sp]
10000a5c: 9f01         	ldr	r7, [sp, #0x4]
10000a5e: 1836         	adds	r6, r6, r0
10000a60: 414f         	adcs	r7, r1
;                     earliest_entry->target = next_time;
10000a62: 4653         	mov	r3, r10
10000a64: 609e         	str	r6, [r3, #0x8]
10000a66: 60df         	str	r7, [r3, #0xc]
;                     if (earliest_entry->next >= 0 && next_time - pool->entries[earliest_entry->next].target >= 0) {
10000a68: 2200         	movs	r2, #0x0
10000a6a: 5e9a         	ldrsh	r2, [r3, r2]
10000a6c: 2a00         	cmp	r2, #0x0
10000a6e: da00         	bge	0x10000a72 <alarm_pool_irq_handler+0x12e> @ imm = #0x0
10000a70: e786         	b	0x10000980 <alarm_pool_irq_handler+0x3c> @ imm = #-0xf4
10000a72: 0053         	lsls	r3, r2, #0x1
10000a74: 1899         	adds	r1, r3, r2
10000a76: 6960         	ldr	r0, [r4, #0x14]
10000a78: 00c9         	lsls	r1, r1, #0x3
10000a7a: 1841         	adds	r1, r0, r1
10000a7c: 9302         	str	r3, [sp, #0x8]
10000a7e: 688b         	ldr	r3, [r1, #0x8]
10000a80: 68c9         	ldr	r1, [r1, #0xc]
10000a82: 469b         	mov	r11, r3
10000a84: 42b9         	cmp	r1, r7
10000a86: dd00         	ble	0x10000a8a <alarm_pool_irq_handler+0x146> @ imm = #0x0
10000a88: e77a         	b	0x10000980 <alarm_pool_irq_handler+0x3c> @ imm = #-0x10c
10000a8a: d102         	bne	0x10000a92 <alarm_pool_irq_handler+0x14e> @ imm = #0x4
10000a8c: 42b3         	cmp	r3, r6
10000a8e: d900         	bls	0x10000a92 <alarm_pool_irq_handler+0x14e> @ imm = #0x0
10000a90: e776         	b	0x10000980 <alarm_pool_irq_handler+0x3c> @ imm = #-0x114
;                         int16_t *prev = &pool->ordered_head;
10000a92: 2308         	movs	r3, #0x8
10000a94: 469c         	mov	r12, r3
10000a96: 44a4         	add	r12, r4
10000a98: 9505         	str	r5, [sp, #0x14]
10000a9a: 4665         	mov	r5, r12
;                         pool->ordered_head = earliest_entry->next;
10000a9c: 8122         	strh	r2, [r4, #0x8]
;                         while (*prev >= 0 && (next_time - pool->entries[*prev].target) >= 0) {
10000a9e: 46a4         	mov	r12, r4
10000aa0: 9b02         	ldr	r3, [sp, #0x8]
10000aa2: 002c         	movs	r4, r5
10000aa4: e006         	b	0x10000ab4 <alarm_pool_irq_handler+0x170> @ imm = #0xc
10000aa6: 0053         	lsls	r3, r2, #0x1
10000aa8: 1899         	adds	r1, r3, r2
10000aaa: 00c9         	lsls	r1, r1, #0x3
10000aac: 1841         	adds	r1, r0, r1
10000aae: 688d         	ldr	r5, [r1, #0x8]
10000ab0: 68c9         	ldr	r1, [r1, #0xc]
10000ab2: 46ab         	mov	r11, r5
10000ab4: 189b         	adds	r3, r3, r2
10000ab6: 00db         	lsls	r3, r3, #0x3
10000ab8: 18c3         	adds	r3, r0, r3
10000aba: 42b9         	cmp	r1, r7
10000abc: dc06         	bgt	0x10000acc <alarm_pool_irq_handler+0x188> @ imm = #0xc
10000abe: d100         	bne	0x10000ac2 <alarm_pool_irq_handler+0x17e> @ imm = #0x0
10000ac0: e0b3         	b	0x10000c2a <alarm_pool_irq_handler+0x2e6> @ imm = #0x166
;                             prev = &pool->entries[*prev].next;
10000ac2: 001c         	movs	r4, r3
10000ac4: 2300         	movs	r3, #0x0
10000ac6: 5ee2         	ldrsh	r2, [r4, r3]
;                         while (*prev >= 0 && (next_time - pool->entries[*prev].target) >= 0) {
10000ac8: 2a00         	cmp	r2, #0x0
10000aca: daec         	bge	0x10000aa6 <alarm_pool_irq_handler+0x162> @ imm = #-0x28
;                         earliest_entry->next = *prev;
10000acc: 0023         	movs	r3, r4
10000ace: 4664         	mov	r4, r12
10000ad0: 469c         	mov	r12, r3
10000ad2: 4653         	mov	r3, r10
10000ad4: 801a         	strh	r2, [r3]
;                         *prev = earliest_index;
10000ad6: 4663         	mov	r3, r12
;                         earliest_entry->next = *prev;
10000ad8: 9d05         	ldr	r5, [sp, #0x14]
;                         *prev = earliest_index;
10000ada: 801d         	strh	r5, [r3]
;         if (pool->new_head >= 0) {
10000adc: 88a3         	ldrh	r3, [r4, #0x4]
10000ade: b21b         	sxth	r3, r3
10000ae0: 2b00         	cmp	r3, #0x0
10000ae2: da00         	bge	0x10000ae6 <alarm_pool_irq_handler+0x1a2> @ imm = #0x0
10000ae4: e751         	b	0x1000098a <alarm_pool_irq_handler+0x46> @ imm = #-0x15e
;             uint32_t save = spin_lock_blocking(pool->lock);
10000ae6: 6922         	ldr	r2, [r4, #0x10]
;     pico_default_asm_volatile (
10000ae8: f3ef 8110    	mrs	r1, primask
10000aec: b672         	cpsid i
;     while (__builtin_expect(!*lock, 0)) { // read from spinlock register (tries to acquire the lock)
10000aee: 6813         	ldr	r3, [r2]
10000af0: 2b00         	cmp	r3, #0x0
10000af2: d0fc         	beq	0x10000aee <alarm_pool_irq_handler+0x1aa> @ imm = #-0x8
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000af4: f3bf 8f5f    	dmb	sy
;             pool->new_head = -1;
10000af8: 2301         	movs	r3, #0x1
;             int16_t new_index = pool->new_head;
10000afa: 88a7         	ldrh	r7, [r4, #0x4]
;             pool->new_head = -1;
10000afc: 425b         	rsbs	r3, r3, #0
10000afe: 80a3         	strh	r3, [r4, #0x4]
;             int16_t new_index = pool->new_head;
10000b00: b23f         	sxth	r7, r7
;             spin_unlock(pool->lock, save);
10000b02: 6923         	ldr	r3, [r4, #0x10]
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000b04: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
10000b08: 2200         	movs	r2, #0x0
10000b0a: 601a         	str	r2, [r3]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
10000b0c: f381 8810    	msr	primask, r1
;             while (new_index >= 0) {
10000b10: 2f00         	cmp	r7, #0x0
10000b12: da00         	bge	0x10000b16 <alarm_pool_irq_handler+0x1d2> @ imm = #0x0
10000b14: e739         	b	0x1000098a <alarm_pool_irq_handler+0x46> @ imm = #-0x18e
10000b16: 0023         	movs	r3, r4
10000b18: 3308         	adds	r3, #0x8
10000b1a: 0022         	movs	r2, r4
10000b1c: 469a         	mov	r10, r3
;                 alarm_pool_entry_t *new_entry = &pool->entries[new_index];
10000b1e: 6966         	ldr	r6, [r4, #0x14]
10000b20: 007b         	lsls	r3, r7, #0x1
10000b22: 19db         	adds	r3, r3, r7
10000b24: 00db         	lsls	r3, r3, #0x3
10000b26: 18f3         	adds	r3, r6, r3
;                 int64_t new_entry_time = new_entry->target;
10000b28: 6899         	ldr	r1, [r3, #0x8]
;                 int16_t *prev = &pool->ordered_head;
10000b2a: 4650         	mov	r0, r10
;                 int64_t new_entry_time = new_entry->target;
10000b2c: 468c         	mov	r12, r1
;                 int16_t *prev = &pool->ordered_head;
10000b2e: 2408         	movs	r4, #0x8
10000b30: 5f11         	ldrsh	r1, [r2, r4]
;                 int64_t new_entry_time = new_entry->target;
10000b32: 68dd         	ldr	r5, [r3, #0xc]
;                 while (*prev >= 0 && (new_entry_time - pool->entries[*prev].target) >= 0) {
10000b34: 2900         	cmp	r1, #0x0
10000b36: db10         	blt	0x10000b5a <alarm_pool_irq_handler+0x216> @ imm = #0x20
10000b38: 9302         	str	r3, [sp, #0x8]
10000b3a: e006         	b	0x10000b4a <alarm_pool_irq_handler+0x206> @ imm = #0xc
10000b3c: 42ab         	cmp	r3, r5
10000b3e: d044         	beq	0x10000bca <alarm_pool_irq_handler+0x286> @ imm = #0x88
;                     prev = &pool->entries[*prev].next;
10000b40: 2300         	movs	r3, #0x0
10000b42: 5ee1         	ldrsh	r1, [r4, r3]
10000b44: 0020         	movs	r0, r4
;                 while (*prev >= 0 && (new_entry_time - pool->entries[*prev].target) >= 0) {
10000b46: 2900         	cmp	r1, #0x0
10000b48: db06         	blt	0x10000b58 <alarm_pool_irq_handler+0x214> @ imm = #0xc
10000b4a: 004c         	lsls	r4, r1, #0x1
10000b4c: 1864         	adds	r4, r4, r1
10000b4e: 00e4         	lsls	r4, r4, #0x3
10000b50: 1934         	adds	r4, r6, r4
10000b52: 68e3         	ldr	r3, [r4, #0xc]
10000b54: 42ab         	cmp	r3, r5
10000b56: ddf1         	ble	0x10000b3c <alarm_pool_irq_handler+0x1f8> @ imm = #-0x1e
10000b58: 9b02         	ldr	r3, [sp, #0x8]
;                 *prev = new_index;
10000b5a: 8007         	strh	r7, [r0]
;                 new_index = new_entry->next;
10000b5c: 2000         	movs	r0, #0x0
10000b5e: 5e1f         	ldrsh	r7, [r3, r0]
;                 new_entry->next = next;
10000b60: 8019         	strh	r1, [r3]
;             while (new_index >= 0) {
10000b62: 2f00         	cmp	r7, #0x0
10000b64: dadc         	bge	0x10000b20 <alarm_pool_irq_handler+0x1dc> @ imm = #-0x48
10000b66: 0014         	movs	r4, r2
;         if (pool->has_pending_cancellations) {
10000b68: 79a3         	ldrb	r3, [r4, #0x6]
10000b6a: 2b00         	cmp	r3, #0x0
10000b6c: d100         	bne	0x10000b70 <alarm_pool_irq_handler+0x22c> @ imm = #0x0
10000b6e: e710         	b	0x10000992 <alarm_pool_irq_handler+0x4e> @ imm = #-0x1e0
;             pool->has_pending_cancellations = false;
10000b70: 2300         	movs	r3, #0x0
10000b72: 71a3         	strb	r3, [r4, #0x6]
;             int16_t *prev = &pool->ordered_head;
10000b74: 0026         	movs	r6, r4
;             for(int16_t index = pool->ordered_head; index != -1; ) {
10000b76: 2308         	movs	r3, #0x8
10000b78: 5ee1         	ldrsh	r1, [r4, r3]
;             int16_t *prev = &pool->ordered_head;
10000b7a: 3608         	adds	r6, #0x8
;             for(int16_t index = pool->ordered_head; index != -1; ) {
10000b7c: 1c4b         	adds	r3, r1, #0x1
10000b7e: d100         	bne	0x10000b82 <alarm_pool_irq_handler+0x23e> @ imm = #0x0
10000b80: e72c         	b	0x100009dc <alarm_pool_irq_handler+0x98> @ imm = #-0x1a8
;                 alarm_pool_entry_t *entry = &pool->entries[index];
10000b82: 0008         	movs	r0, r1
10000b84: 46a2         	mov	r10, r4
10000b86: 6965         	ldr	r5, [r4, #0x14]
10000b88: e002         	b	0x10000b90 <alarm_pool_irq_handler+0x24c> @ imm = #0x4
;                     prev = &entry->next;
10000b8a: 003e         	movs	r6, r7
;             for(int16_t index = pool->ordered_head; index != -1; ) {
10000b8c: 1c4b         	adds	r3, r1, #0x1
10000b8e: d01a         	beq	0x10000bc6 <alarm_pool_irq_handler+0x282> @ imm = #0x34
;                 alarm_pool_entry_t *entry = &pool->entries[index];
10000b90: 004b         	lsls	r3, r1, #0x1
10000b92: 185b         	adds	r3, r3, r1
10000b94: 00db         	lsls	r3, r3, #0x3
10000b96: 18ef         	adds	r7, r5, r3
10000b98: 000a         	movs	r2, r1
10000b9a: 468c         	mov	r12, r1
;                 int16_t next = entry->next;
10000b9c: 5ee9         	ldrsh	r1, [r5, r3]
;                 if ((int16_t)entry->sequence < 0) {
10000b9e: 887b         	ldrh	r3, [r7, #0x2]
10000ba0: b21b         	sxth	r3, r3
10000ba2: 2b00         	cmp	r3, #0x0
10000ba4: daf1         	bge	0x10000b8a <alarm_pool_irq_handler+0x246> @ imm = #-0x1e
;                     entry->target = -1;
10000ba6: 2301         	movs	r3, #0x1
10000ba8: 425b         	rsbs	r3, r3, #0
10000baa: 17dc         	asrs	r4, r3, #0x1f
10000bac: 60bb         	str	r3, [r7, #0x8]
10000bae: 60fc         	str	r4, [r7, #0xc]
;                     if (index != pool->ordered_head) {
10000bb0: 4282         	cmp	r2, r0
10000bb2: d005         	beq	0x10000bc0 <alarm_pool_irq_handler+0x27c> @ imm = #0xa
;                         entry->next = pool->ordered_head;
10000bb4: 4653         	mov	r3, r10
;                         *prev = entry->next;
10000bb6: 8031         	strh	r1, [r6]
;                         entry->next = pool->ordered_head;
10000bb8: 891b         	ldrh	r3, [r3, #0x8]
10000bba: 803b         	strh	r3, [r7]
;                         pool->ordered_head = index;
10000bbc: 4653         	mov	r3, r10
10000bbe: 811a         	strh	r2, [r3, #0x8]
;                 alarm_pool_entry_t *entry = &pool->entries[index];
10000bc0: 4660         	mov	r0, r12
;             for(int16_t index = pool->ordered_head; index != -1; ) {
10000bc2: 1c4b         	adds	r3, r1, #0x1
10000bc4: d1e4         	bne	0x10000b90 <alarm_pool_irq_handler+0x24c> @ imm = #-0x38
10000bc6: 4654         	mov	r4, r10
10000bc8: e6e5         	b	0x10000996 <alarm_pool_irq_handler+0x52> @ imm = #-0x236
;                 while (*prev >= 0 && (new_entry_time - pool->entries[*prev].target) >= 0) {
10000bca: 68a3         	ldr	r3, [r4, #0x8]
10000bcc: 4563         	cmp	r3, r12
10000bce: d9b7         	bls	0x10000b40 <alarm_pool_irq_handler+0x1fc> @ imm = #-0x92
10000bd0: e7c2         	b	0x10000b58 <alarm_pool_irq_handler+0x214> @ imm = #-0x7c
;         if (earliest_target != -1) { // cancelled alarm has target of -1
10000bd2: 1c6b         	adds	r3, r5, #0x1
10000bd4: d000         	beq	0x10000bd8 <alarm_pool_irq_handler+0x294> @ imm = #0x0
10000bd6: e6ea         	b	0x100009ae <alarm_pool_irq_handler+0x6a> @ imm = #-0x22c
10000bd8: e6f8         	b	0x100009cc <alarm_pool_irq_handler+0x88> @ imm = #-0x210
;                         delta = rpt->callback(rpt) ? rpt->delay_us : 0;
10000bda: 465b         	mov	r3, r11
10000bdc: 4658         	mov	r0, r11
10000bde: 691b         	ldr	r3, [r3, #0x10]
10000be0: 4798         	blx	r3
10000be2: 2800         	cmp	r0, #0x0
10000be4: d11b         	bne	0x10000c1e <alarm_pool_irq_handler+0x2da> @ imm = #0x36
;                     pool->ordered_head = earliest_entry->next;
10000be6: 4653         	mov	r3, r10
10000be8: 881b         	ldrh	r3, [r3]
;                     uint32_t save = spin_lock_blocking(pool->lock);
10000bea: 6922         	ldr	r2, [r4, #0x10]
;                     pool->ordered_head = earliest_entry->next;
10000bec: 8123         	strh	r3, [r4, #0x8]
;     pico_default_asm_volatile (
10000bee: f3ef 8310    	mrs	r3, primask
10000bf2: b672         	cpsid i
;     while (__builtin_expect(!*lock, 0)) { // read from spinlock register (tries to acquire the lock)
10000bf4: 6811         	ldr	r1, [r2]
10000bf6: 2900         	cmp	r1, #0x0
10000bf8: d0fc         	beq	0x10000bf4 <alarm_pool_irq_handler+0x2b0> @ imm = #-0x8
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000bfa: f3bf 8f5f    	dmb	sy
;                     earliest_entry->next = pool->free_head;
10000bfe: 4651         	mov	r1, r10
10000c00: 8862         	ldrh	r2, [r4, #0x2]
10000c02: 800a         	strh	r2, [r1]
;                     spin_unlock(pool->lock, save);
10000c04: 6922         	ldr	r2, [r4, #0x10]
;                     pool->free_head = earliest_index;
10000c06: 8065         	strh	r5, [r4, #0x2]
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000c08: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
10000c0c: 2100         	movs	r1, #0x0
10000c0e: 6011         	str	r1, [r2]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
10000c10: f383 8810    	msr	primask, r3
; }
10000c14: e6b4         	b	0x10000980 <alarm_pool_irq_handler+0x3c> @ imm = #-0x298
;             if (((int64_t)ta_time_us_64(timer) - earliest_target) >= 0) {
10000c16: 4286         	cmp	r6, r0
10000c18: d800         	bhi	0x10000c1c <alarm_pool_irq_handler+0x2d8> @ imm = #0x0
10000c1a: e6f8         	b	0x10000a0e <alarm_pool_irq_handler+0xca> @ imm = #-0x210
10000c1c: e6b0         	b	0x10000980 <alarm_pool_irq_handler+0x3c> @ imm = #-0x2a0
;                         delta = rpt->callback(rpt) ? rpt->delay_us : 0;
10000c1e: 465b         	mov	r3, r11
10000c20: 681a         	ldr	r2, [r3]
10000c22: 685b         	ldr	r3, [r3, #0x4]
10000c24: 9200         	str	r2, [sp]
10000c26: 9301         	str	r3, [sp, #0x4]
10000c28: e707         	b	0x10000a3a <alarm_pool_irq_handler+0xf6> @ imm = #-0x1f2
;                         while (*prev >= 0 && (next_time - pool->entries[*prev].target) >= 0) {
10000c2a: 45b3         	cmp	r11, r6
10000c2c: d800         	bhi	0x10000c30 <alarm_pool_irq_handler+0x2ec> @ imm = #0x0
10000c2e: e748         	b	0x10000ac2 <alarm_pool_irq_handler+0x17e> @ imm = #-0x170
10000c30: e74c         	b	0x10000acc <alarm_pool_irq_handler+0x188> @ imm = #-0x168
10000c32: 46c0         	mov	r8, r8
10000c34: b8 05 00 20  	.word	0x200005b8
10000c38: 3c 70 05 40  	.word	0x4005703c
10000c3c: 45 09 00 10  	.word	0x10000945
10000c40: 00 40 05 40  	.word	0x40054000

10000c44 <runtime_init_default_alarm_pool>:
; void __weak runtime_init_default_alarm_pool(void) {
10000c44: b570         	push	{r4, r5, r6, lr}
;     return default_alarm_pool.lock != NULL;
10000c46: 4c2e         	ldr	r4, [pc, #0xb8]         @ 0x10000d00 <runtime_init_default_alarm_pool+0xbc>
;     if (!default_alarm_pool_initialized()) {
10000c48: 6925         	ldr	r5, [r4, #0x10]
10000c4a: 2d00         	cmp	r5, #0x0
10000c4c: d004         	beq	0x10000c58 <runtime_init_default_alarm_pool+0x14> @ imm = #0x8
;     lock_init(&sleep_notifier, PICO_SPINLOCK_ID_TIMER);
10000c4e: 210a         	movs	r1, #0xa
10000c50: 482c         	ldr	r0, [pc, #0xb0]         @ 0x10000d04 <runtime_init_default_alarm_pool+0xc0>
10000c52: f7ff fe2f    	bl	0x100008b4 <lock_init>  @ imm = #-0x3a2
; }
10000c56: bd70         	pop	{r4, r5, r6, pc}
;     timer_hardware_alarm_claim(timer_hw_from_timer(timer), hardware_alaram_num);
10000c58: 4e2b         	ldr	r6, [pc, #0xac]         @ 0x10000d08 <runtime_init_default_alarm_pool+0xc4>
10000c5a: 2103         	movs	r1, #0x3
10000c5c: 0030         	movs	r0, r6
10000c5e: f000 f9f5    	bl	0x1000104c <timer_hardware_alarm_claim> @ imm = #0x3ea
;     pool->timer = timer;
10000c62: 60e6         	str	r6, [r4, #0xc]
;     pool->lock = spin_lock_instance(next_striped_spin_lock_num());
10000c64: f7ff fdbe    	bl	0x100007e4 <next_striped_spin_lock_num> @ imm = #-0x484
;     return (spin_lock_t *) (SIO_BASE + SIO_SPINLOCK0_OFFSET + lock_num * 4);
10000c68: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x10000d0c <runtime_init_default_alarm_pool+0xc8>
;     pool->timer_alarm_num = (uint8_t) hardware_alarm_num;
10000c6a: 2203         	movs	r2, #0x3
;     return (spin_lock_t *) (SIO_BASE + SIO_SPINLOCK0_OFFSET + lock_num * 4);
10000c6c: 469c         	mov	r12, r3
;     return (*(uint32_t *) (SIO_BASE + SIO_CPUID_OFFSET));
10000c6e: 23d0         	movs	r3, #0xd0
;     pool->timer_alarm_num = (uint8_t) hardware_alarm_num;
10000c70: 7022         	strb	r2, [r4]
;     return (*(uint32_t *) (SIO_BASE + SIO_CPUID_OFFSET));
10000c72: 061b         	lsls	r3, r3, #0x18
;     pool->core_num = (uint8_t) get_core_num();
10000c74: 681b         	ldr	r3, [r3]
;     pool->new_head = pool->ordered_head = -1;
10000c76: 2101         	movs	r1, #0x1
;     pool->core_num = (uint8_t) get_core_num();
10000c78: 7063         	strb	r3, [r4, #0x1]
;     pool->new_head = pool->ordered_head = -1;
10000c7a: 4b25         	ldr	r3, [pc, #0x94]         @ 0x10000d10 <runtime_init_default_alarm_pool+0xcc>
;     return (spin_lock_t *) (SIO_BASE + SIO_SPINLOCK0_OFFSET + lock_num * 4);
10000c7c: 4460         	add	r0, r12
;     pool->new_head = pool->ordered_head = -1;
10000c7e: 60a3         	str	r3, [r4, #0x8]
;     pool->free_head = (int16_t)(max_timers - 1);
10000c80: 230f         	movs	r3, #0xf
;     return (spin_lock_t *) (SIO_BASE + SIO_SPINLOCK0_OFFSET + lock_num * 4);
10000c82: 0080         	lsls	r0, r0, #0x2
;     pool->lock = spin_lock_instance(next_striped_spin_lock_num());
10000c84: 6120         	str	r0, [r4, #0x10]
;         pool->entries[i].next = (int16_t)(i-1);
10000c86: 2002         	movs	r0, #0x2
;     pool->free_head = (int16_t)(max_timers - 1);
10000c88: 8063         	strh	r3, [r4, #0x2]
;         pool->entries[i].next = (int16_t)(i-1);
10000c8a: 6963         	ldr	r3, [r4, #0x14]
;     pool->new_head = pool->ordered_head = -1;
10000c8c: 4249         	rsbs	r1, r1, #0
10000c8e: 80a1         	strh	r1, [r4, #0x4]
;         pool->entries[i].next = (int16_t)(i-1);
10000c90: 8019         	strh	r1, [r3]
10000c92: 3102         	adds	r1, #0x2
10000c94: 8619         	strh	r1, [r3, #0x30]
10000c96: 3147         	adds	r1, #0x47
10000c98: 831d         	strh	r5, [r3, #0x18]
10000c9a: 5258         	strh	r0, [r3, r1]
10000c9c: 3118         	adds	r1, #0x18
10000c9e: 525a         	strh	r2, [r3, r1]
10000ca0: 3275         	adds	r2, #0x75
10000ca2: 395c         	subs	r1, #0x5c
10000ca4: 5299         	strh	r1, [r3, r2]
10000ca6: 3218         	adds	r2, #0x18
10000ca8: 3101         	adds	r1, #0x1
10000caa: 5299         	strh	r1, [r3, r2]
10000cac: 3218         	adds	r2, #0x18
10000cae: 3101         	adds	r1, #0x1
10000cb0: 5299         	strh	r1, [r3, r2]
10000cb2: 3218         	adds	r2, #0x18
10000cb4: 3101         	adds	r1, #0x1
10000cb6: 5299         	strh	r1, [r3, r2]
10000cb8: 3508         	adds	r5, #0x8
10000cba: 3218         	adds	r2, #0x18
10000cbc: 529d         	strh	r5, [r3, r2]
10000cbe: 3102         	adds	r1, #0x2
10000cc0: 3218         	adds	r2, #0x18
10000cc2: 5299         	strh	r1, [r3, r2]
10000cc4: 3218         	adds	r2, #0x18
10000cc6: 3101         	adds	r1, #0x1
10000cc8: 5299         	strh	r1, [r3, r2]
10000cca: 3218         	adds	r2, #0x18
10000ccc: 3101         	adds	r1, #0x1
10000cce: 5299         	strh	r1, [r3, r2]
10000cd0: 3218         	adds	r2, #0x18
10000cd2: 3101         	adds	r1, #0x1
10000cd4: 5299         	strh	r1, [r3, r2]
10000cd6: 3218         	adds	r2, #0x18
10000cd8: 3101         	adds	r1, #0x1
10000cda: 5299         	strh	r1, [r3, r2]
10000cdc: 3218         	adds	r2, #0x18
10000cde: 3101         	adds	r1, #0x1
10000ce0: 5299         	strh	r1, [r3, r2]
;     pools[ta_timer_num(timer)][hardware_alarm_num] = pool;
10000ce2: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x10000d14 <runtime_init_default_alarm_pool+0xd0>
;     irq_set_exclusive_handler(irq_num, irq_handler);
10000ce4: 490c         	ldr	r1, [pc, #0x30]         @ 0x10000d18 <runtime_init_default_alarm_pool+0xd4>
;     pools[ta_timer_num(timer)][hardware_alarm_num] = pool;
10000ce6: 60dc         	str	r4, [r3, #0xc]
;     irq_set_exclusive_handler(irq_num, irq_handler);
10000ce8: 3001         	adds	r0, #0x1
;     timer_hw_from_timer(timer)->armed = 1u << alarm_num;
10000cea: 6235         	str	r5, [r6, #0x20]
;     irq_set_exclusive_handler(irq_num, irq_handler);
10000cec: f7ff fdb8    	bl	0x10000860 <irq_set_exclusive_handler> @ imm = #-0x490
;     irq_set_enabled(irq_num, true);
10000cf0: 2101         	movs	r1, #0x1
10000cf2: 2003         	movs	r0, #0x3
10000cf4: f7ff fda2    	bl	0x1000083c <irq_set_enabled> @ imm = #-0x4bc
;     *(io_rw_32 *) hw_set_alias_untyped((volatile void *) addr) = mask;
10000cf8: 4b08         	ldr	r3, [pc, #0x20]         @ 0x10000d1c <runtime_init_default_alarm_pool+0xd8>
10000cfa: 601d         	str	r5, [r3]
; }
10000cfc: e7a7         	b	0x10000c4e <runtime_init_default_alarm_pool+0xa> @ imm = #-0xb2
10000cfe: 46c0         	mov	r8, r8
10000d00: 9c 01 00 20  	.word	0x2000019c
10000d04: cc 05 00 20  	.word	0x200005cc
10000d08: 00 40 05 40  	.word	0x40054000
10000d0c: 40 00 00 34  	.word	0x34000040
10000d10: ff ff 10 00  	.word	0x0010ffff
10000d14: b8 05 00 20  	.word	0x200005b8
10000d18: 45 09 00 10  	.word	0x10000945
10000d1c: 38 60 05 40  	.word	0x40056038

10000d20 <alarm_pool_add_alarm_at_force_in_context>:
;                                                     void *user_data) {
10000d20: b570         	push	{r4, r5, r6, lr}
10000d22: 0001         	movs	r1, r0
;     uint32_t save = spin_lock_blocking(pool->lock);
10000d24: 6904         	ldr	r4, [r0, #0x10]
;     pico_default_asm_volatile (
10000d26: f3ef 8c10    	mrs	r12, primask
10000d2a: b672         	cpsid i
;     while (__builtin_expect(!*lock, 0)) { // read from spinlock register (tries to acquire the lock)
10000d2c: 6820         	ldr	r0, [r4]
10000d2e: 2800         	cmp	r0, #0x0
10000d30: d0fc         	beq	0x10000d2c <alarm_pool_add_alarm_at_force_in_context+0xc> @ imm = #-0x8
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000d32: f3bf 8f5f    	dmb	sy
;     int16_t index = pool->free_head;
10000d36: 2002         	movs	r0, #0x2
10000d38: 5e0d         	ldrsh	r5, [r1, r0]
;     alarm_pool_entry_t *entry = &pool->entries[index];
10000d3a: 694c         	ldr	r4, [r1, #0x14]
10000d3c: 0068         	lsls	r0, r5, #0x1
10000d3e: 1940         	adds	r0, r0, r5
10000d40: 00c0         	lsls	r0, r0, #0x3
10000d42: 1824         	adds	r4, r4, r0
;     spin_unlock(pool->lock, save);
10000d44: 6908         	ldr	r0, [r1, #0x10]
;     if (index >= 0) {
10000d46: 2d00         	cmp	r5, #0x0
10000d48: db36         	blt	0x10000db8 <alarm_pool_add_alarm_at_force_in_context+0x98> @ imm = #0x6c
;         pool->free_head = entry->next;
10000d4a: 8826         	ldrh	r6, [r4]
10000d4c: 804e         	strh	r6, [r1, #0x2]
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000d4e: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
10000d52: 2600         	movs	r6, #0x0
10000d54: 6006         	str	r6, [r0]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
10000d56: f38c 8810    	msr	primask, r12
;     entry->target = (int64_t)to_us_since_boot(time);
10000d5a: 60e3         	str	r3, [r4, #0xc]
;     uint16_t next_sequence = (entry->sequence + 1) & 0x7fff;
10000d5c: 8863         	ldrh	r3, [r4, #0x2]
;     entry->callback = callback;
10000d5e: 9804         	ldr	r0, [sp, #0x10]
;     uint16_t next_sequence = (entry->sequence + 1) & 0x7fff;
10000d60: 3301         	adds	r3, #0x1
;     entry->callback = callback;
10000d62: 6120         	str	r0, [r4, #0x10]
;     uint16_t next_sequence = (entry->sequence + 1) & 0x7fff;
10000d64: 045b         	lsls	r3, r3, #0x11
;     entry->user_data = user_data;
10000d66: 9805         	ldr	r0, [sp, #0x14]
;     uint16_t next_sequence = (entry->sequence + 1) & 0x7fff;
10000d68: 0c5b         	lsrs	r3, r3, #0x11
;     entry->target = (int64_t)to_us_since_boot(time);
10000d6a: 60a2         	str	r2, [r4, #0x8]
;     entry->user_data = user_data;
10000d6c: 6160         	str	r0, [r4, #0x14]
;     if (!next_sequence) next_sequence = 1; // zero is not allowed
10000d6e: 1c1a         	adds	r2, r3, #0x0
10000d70: 2b00         	cmp	r3, #0x0
10000d72: d01f         	beq	0x10000db4 <alarm_pool_add_alarm_at_force_in_context+0x94> @ imm = #0x3e
10000d74: b293         	uxth	r3, r2
;     return index << 16 | counter;
10000d76: 0428         	lsls	r0, r5, #0x10
;     entry->sequence = next_sequence;
10000d78: 8062         	strh	r2, [r4, #0x2]
;     return index << 16 | counter;
10000d7a: 4318         	orrs	r0, r3
;     save = spin_lock_blocking(pool->lock);
10000d7c: 690a         	ldr	r2, [r1, #0x10]
;     pico_default_asm_volatile (
10000d7e: f3ef 8c10    	mrs	r12, primask
10000d82: b672         	cpsid i
;     while (__builtin_expect(!*lock, 0)) { // read from spinlock register (tries to acquire the lock)
10000d84: 6813         	ldr	r3, [r2]
10000d86: 2b00         	cmp	r3, #0x0
10000d88: d0fc         	beq	0x10000d84 <alarm_pool_add_alarm_at_force_in_context+0x64> @ imm = #-0x8
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000d8a: f3bf 8f5f    	dmb	sy
;     entry->next = pool->new_head;
10000d8e: 888b         	ldrh	r3, [r1, #0x4]
10000d90: 8023         	strh	r3, [r4]
;     pool->new_head = index;
10000d92: 808d         	strh	r5, [r1, #0x4]
;     spin_unlock(pool->lock, save);
10000d94: 690b         	ldr	r3, [r1, #0x10]
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000d96: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
10000d9a: 2200         	movs	r2, #0x0
10000d9c: 601a         	str	r2, [r3]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
10000d9e: f38c 8810    	msr	primask, r12
;     ta_force_irq(pool->timer, pool->timer_alarm_num);
10000da2: 780b         	ldrb	r3, [r1]
;     hw_set_bits(&timer_hw_from_timer(timer)->intf, 1u << alarm_num);
10000da4: 3201         	adds	r2, #0x1
10000da6: 409a         	lsls	r2, r3
10000da8: 68cb         	ldr	r3, [r1, #0xc]
;     *(io_rw_32 *) hw_set_alias_untyped((volatile void *) addr) = mask;
10000daa: 4908         	ldr	r1, [pc, #0x20]         @ 0x10000dcc <alarm_pool_add_alarm_at_force_in_context+0xac>
10000dac: 468c         	mov	r12, r1
10000dae: 4463         	add	r3, r12
10000db0: 601a         	str	r2, [r3]
; }
10000db2: bd70         	pop	{r4, r5, r6, pc}
;     if (!next_sequence) next_sequence = 1; // zero is not allowed
10000db4: 2201         	movs	r2, #0x1
10000db6: e7dd         	b	0x10000d74 <alarm_pool_add_alarm_at_force_in_context+0x54> @ imm = #-0x46
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000db8: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
10000dbc: 2300         	movs	r3, #0x0
10000dbe: 6003         	str	r3, [r0]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
10000dc0: f38c 8810    	msr	primask, r12
;     if (index < 0) return PICO_ERROR_GENERIC; // PICO_ERROR_INSUFFICIENT_RESOURCES - not using to preserve previous -1 return code
10000dc4: 2001         	movs	r0, #0x1
10000dc6: 4240         	rsbs	r0, r0, #0
10000dc8: e7f3         	b	0x10000db2 <alarm_pool_add_alarm_at_force_in_context+0x92> @ imm = #-0x1a
10000dca: 46c0         	mov	r8, r8
10000dcc: 3c 20 00 00  	.word	0x0000203c

10000dd0 <alarm_pool_cancel_alarm>:
; bool alarm_pool_cancel_alarm(alarm_pool_t *pool, alarm_id_t alarm_id) {
10000dd0: b510         	push	{r4, lr}
;     if (index >= pool->num_entries) return false;
10000dd2: 8943         	ldrh	r3, [r0, #0xa]
;     return (int16_t)(id >> 16);
10000dd4: 140a         	asrs	r2, r1, #0x10
;     if (index >= pool->num_entries) return false;
10000dd6: 4293         	cmp	r3, r2
10000dd8: dd1a         	ble	0x10000e10 <alarm_pool_cancel_alarm+0x40> @ imm = #0x34
;     alarm_pool_entry_t *entry = &pool->entries[index];
10000dda: 0053         	lsls	r3, r2, #0x1
10000ddc: 189b         	adds	r3, r3, r2
10000dde: 6942         	ldr	r2, [r0, #0x14]
10000de0: 00db         	lsls	r3, r3, #0x3
10000de2: 18d3         	adds	r3, r2, r3
;     uint32_t save = spin_lock_blocking(pool->lock);
10000de4: 6904         	ldr	r4, [r0, #0x10]
;     pico_default_asm_volatile (
10000de6: f3ef 8c10    	mrs	r12, primask
10000dea: b672         	cpsid i
;     while (__builtin_expect(!*lock, 0)) { // read from spinlock register (tries to acquire the lock)
10000dec: 6822         	ldr	r2, [r4]
10000dee: 2a00         	cmp	r2, #0x0
10000df0: d0fc         	beq	0x10000dec <alarm_pool_cancel_alarm+0x1c> @ imm = #-0x8
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000df2: f3bf 8f5f    	dmb	sy
;     uint current_sequence = entry->sequence;
10000df6: 885a         	ldrh	r2, [r3, #0x2]
;     if (sequence == current_sequence) {
10000df8: 0409         	lsls	r1, r1, #0x10
;     uint current_sequence = entry->sequence;
10000dfa: b294         	uxth	r4, r2
;     if (sequence == current_sequence) {
10000dfc: 0c09         	lsrs	r1, r1, #0x10
10000dfe: 428a         	cmp	r2, r1
10000e00: d008         	beq	0x10000e14 <alarm_pool_cancel_alarm+0x44> @ imm = #0x10
;     spin_unlock(pool->lock, save);
10000e02: 6903         	ldr	r3, [r0, #0x10]
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000e04: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
10000e08: 2200         	movs	r2, #0x0
10000e0a: 601a         	str	r2, [r3]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
10000e0c: f38c 8810    	msr	primask, r12
;     if (index >= pool->num_entries) return false;
10000e10: 2000         	movs	r0, #0x0
; }
10000e12: bd10         	pop	{r4, pc}
;         entry->sequence = (uint16_t)(current_sequence | 0x8000);
10000e14: 2280         	movs	r2, #0x80
10000e16: 0212         	lsls	r2, r2, #0x8
10000e18: 4314         	orrs	r4, r2
10000e1a: 805c         	strh	r4, [r3, #0x2]
;         pool->has_pending_cancellations = true;
10000e1c: 2301         	movs	r3, #0x1
;     spin_unlock(pool->lock, save);
10000e1e: 6902         	ldr	r2, [r0, #0x10]
;         pool->has_pending_cancellations = true;
10000e20: 7183         	strb	r3, [r0, #0x6]
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000e22: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
10000e26: 2100         	movs	r1, #0x0
10000e28: 6011         	str	r1, [r2]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
10000e2a: f38c 8810    	msr	primask, r12
;     *(io_rw_32 *) hw_set_alias_untyped((volatile void *) addr) = mask;
10000e2e: 4904         	ldr	r1, [pc, #0x10]         @ 0x10000e40 <alarm_pool_cancel_alarm+0x70>
;     if (canceled) ta_force_irq(pool->timer, pool->timer_alarm_num);
10000e30: 7802         	ldrb	r2, [r0]
;     *(io_rw_32 *) hw_set_alias_untyped((volatile void *) addr) = mask;
10000e32: 468c         	mov	r12, r1
;     hw_set_bits(&timer_hw_from_timer(timer)->intf, 1u << alarm_num);
10000e34: 4093         	lsls	r3, r2
10000e36: 68c2         	ldr	r2, [r0, #0xc]
;     return canceled;
10000e38: 2001         	movs	r0, #0x1
;     *(io_rw_32 *) hw_set_alias_untyped((volatile void *) addr) = mask;
10000e3a: 4462         	add	r2, r12
10000e3c: 6013         	str	r3, [r2]
; }
10000e3e: e7e8         	b	0x10000e12 <alarm_pool_cancel_alarm+0x42> @ imm = #-0x30
10000e40: 3c 20 00 00  	.word	0x0000203c

10000e44 <sleep_ms>:
; void sleep_ms(uint32_t ms) {
10000e44: b5f0         	push	{r4, r5, r6, r7, lr}
10000e46: 46c6         	mov	lr, r8
10000e48: b500         	push	{lr}
10000e4a: b082         	sub	sp, #0x8
10000e4c: 0004         	movs	r4, r0
;     update_us_since_boot(&t, time_us_64());
10000e4e: f000 f90f    	bl	0x10001070 <time_us_64> @ imm = #0x21e
;     sleep_us(ms * 1000ull);
10000e52: 22fa         	movs	r2, #0xfa
;     update_us_since_boot(&t, time_us_64());
10000e54: 0006         	movs	r6, r0
10000e56: 000f         	movs	r7, r1
;     sleep_us(ms * 1000ull);
10000e58: 0020         	movs	r0, r4
10000e5a: 2300         	movs	r3, #0x0
10000e5c: 2100         	movs	r1, #0x0
10000e5e: 0092         	lsls	r2, r2, #0x2
10000e60: f001 f9e0    	bl	0x10002224 <__wrap___aeabi_lmul> @ imm = #0x13c0
;     uint64_t delayed = base + us;
10000e64: 1980         	adds	r0, r0, r6
10000e66: 4179         	adcs	r1, r7
10000e68: 0004         	movs	r4, r0
10000e6a: 1e0d         	subs	r5, r1, #0x0
10000e6c: da02         	bge	0x10000e74 <sleep_ms+0x30> @ imm = #0x4
10000e6e: 2401         	movs	r4, #0x1
10000e70: 4d2e         	ldr	r5, [pc, #0xb8]         @ 0x10000f2c <sleep_ms+0xe8>
10000e72: 4264         	rsbs	r4, r4, #0
;     uint64_t t_before_us = t_us - PICO_TIME_SLEEP_OVERHEAD_ADJUST_US;
10000e74: 2606         	movs	r6, #0x6
10000e76: 4276         	rsbs	r6, r6, #0
10000e78: 17f7         	asrs	r7, r6, #0x1f
10000e7a: 1936         	adds	r6, r6, r4
10000e7c: 416f         	adcs	r7, r5
;     if (t_before_us > t_us) t_before_us = 0;
10000e7e: 42af         	cmp	r7, r5
10000e80: d814         	bhi	0x10000eac <sleep_ms+0x68> @ imm = #0x28
10000e82: d011         	beq	0x10000ea8 <sleep_ms+0x64> @ imm = #0x22
;     update_us_since_boot(&t, time_us_64());
10000e84: f000 f8f4    	bl	0x10001070 <time_us_64> @ imm = #0x1e8
;     return (int64_t)(to_us_since_boot(to) - to_us_since_boot(from));
10000e88: 0032         	movs	r2, r6
10000e8a: 003b         	movs	r3, r7
10000e8c: 1a12         	subs	r2, r2, r0
10000e8e: 418b         	sbcs	r3, r1
;     if (absolute_time_diff_us(get_absolute_time(), t_before) > 0) {
10000e90: 2b00         	cmp	r3, #0x0
10000e92: dc15         	bgt	0x10000ec0 <sleep_ms+0x7c> @ imm = #0x2a
10000e94: 2b00         	cmp	r3, #0x0
10000e96: d046         	beq	0x10000f26 <sleep_ms+0xe2> @ imm = #0x8c
;     busy_wait_until(t);
10000e98: 0020         	movs	r0, r4
10000e9a: 0029         	movs	r1, r5
10000e9c: f000 f8f2    	bl	0x10001084 <busy_wait_until> @ imm = #0x1e4
; }
10000ea0: b002         	add	sp, #0x8
10000ea2: bc80         	pop	{r7}
10000ea4: 46b8         	mov	r8, r7
10000ea6: bdf0         	pop	{r4, r5, r6, r7, pc}
;     if (t_before_us > t_us) t_before_us = 0;
10000ea8: 42a6         	cmp	r6, r4
10000eaa: d9eb         	bls	0x10000e84 <sleep_ms+0x40> @ imm = #-0x2a
10000eac: 2600         	movs	r6, #0x0
10000eae: 2700         	movs	r7, #0x0
;     update_us_since_boot(&t, time_us_64());
10000eb0: f000 f8de    	bl	0x10001070 <time_us_64> @ imm = #0x1bc
;     return (int64_t)(to_us_since_boot(to) - to_us_since_boot(from));
10000eb4: 0032         	movs	r2, r6
10000eb6: 003b         	movs	r3, r7
10000eb8: 1a12         	subs	r2, r2, r0
10000eba: 418b         	sbcs	r3, r1
;     if (absolute_time_diff_us(get_absolute_time(), t_before) > 0) {
10000ebc: 2b00         	cmp	r3, #0x0
10000ebe: dde9         	ble	0x10000e94 <sleep_ms+0x50> @ imm = #-0x2e
;     update_us_since_boot(&t, time_us_64());
10000ec0: f000 f8d6    	bl	0x10001070 <time_us_64> @ imm = #0x1ac
;     return (int64_t)(to_us_since_boot(to) - to_us_since_boot(from));
10000ec4: 0032         	movs	r2, r6
10000ec6: 003b         	movs	r3, r7
10000ec8: 1a12         	subs	r2, r2, r0
10000eca: 418b         	sbcs	r3, r1
;         if (absolute_time_diff_us(t, time) < 0) return 0;
10000ecc: 2b00         	cmp	r3, #0x0
10000ece: db0a         	blt	0x10000ee6 <sleep_ms+0xa2> @ imm = #0x14
;     return alarm_pool_add_alarm_at_force_in_context(pool, time, callback, user_data);
10000ed0: 2300         	movs	r3, #0x0
10000ed2: 9301         	str	r3, [sp, #0x4]
10000ed4: 4b16         	ldr	r3, [pc, #0x58]         @ 0x10000f30 <sleep_ms+0xec>
10000ed6: 0032         	movs	r2, r6
10000ed8: 9300         	str	r3, [sp]
10000eda: 4816         	ldr	r0, [pc, #0x58]         @ 0x10000f34 <sleep_ms+0xf0>
10000edc: 003b         	movs	r3, r7
10000ede: f7ff ff1f    	bl	0x10000d20 <alarm_pool_add_alarm_at_force_in_context> @ imm = #-0x1c2
;         if (add_alarm_at(t_before, sleep_until_callback, NULL, false) >= 0) {
10000ee2: 3001         	adds	r0, #0x1
10000ee4: d0d8         	beq	0x10000e98 <sleep_ms+0x54> @ imm = #-0x50
;     *lock = 0; // write to spinlock register (release lock)
10000ee6: 2300         	movs	r3, #0x0
;     uint32_t hi_target = (uint32_t)(target >> 32u);
10000ee8: 0039         	movs	r1, r7
;     return (hi >= hi_target && (timer->timerawl >= (uint32_t) target || hi != hi_target));
10000eea: 46b0         	mov	r8, r6
;     *lock = 0; // write to spinlock register (release lock)
10000eec: 469c         	mov	r12, r3
;     uint32_t hi = timer->timerawh;
10000eee: 4a12         	ldr	r2, [pc, #0x48]         @ 0x10000f38 <sleep_ms+0xf4>
;                 uint32_t save = spin_lock_blocking(sleep_notifier.spin_lock);
10000ef0: 4812         	ldr	r0, [pc, #0x48]         @ 0x10000f3c <sleep_ms+0xf8>
;     uint32_t hi = timer->timerawh;
10000ef2: 6a53         	ldr	r3, [r2, #0x24]
;     return (hi >= hi_target && (timer->timerawl >= (uint32_t) target || hi != hi_target));
10000ef4: 4299         	cmp	r1, r3
10000ef6: d804         	bhi	0x10000f02 <sleep_ms+0xbe> @ imm = #0x8
10000ef8: 6a96         	ldr	r6, [r2, #0x28]
10000efa: 4546         	cmp	r6, r8
10000efc: d2cc         	bhs	0x10000e98 <sleep_ms+0x54> @ imm = #-0x68
10000efe: 4299         	cmp	r1, r3
10000f00: d1ca         	bne	0x10000e98 <sleep_ms+0x54> @ imm = #-0x6c
;                 uint32_t save = spin_lock_blocking(sleep_notifier.spin_lock);
10000f02: 6806         	ldr	r6, [r0]
;     pico_default_asm_volatile (
10000f04: f3ef 8710    	mrs	r7, primask
10000f08: b672         	cpsid i
;     while (__builtin_expect(!*lock, 0)) { // read from spinlock register (tries to acquire the lock)
10000f0a: 6833         	ldr	r3, [r6]
10000f0c: 2b00         	cmp	r3, #0x0
10000f0e: d0fc         	beq	0x10000f0a <sleep_ms+0xc6> @ imm = #-0x8
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000f10: f3bf 8f5f    	dmb	sy
;                 lock_internal_spin_unlock_with_wait(&sleep_notifier, save);
10000f14: 6803         	ldr	r3, [r0]
;     pico_default_asm_volatile ("dmb" : : : "memory");
10000f16: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
10000f1a: 4666         	mov	r6, r12
10000f1c: 601e         	str	r6, [r3]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
10000f1e: f387 8810    	msr	primask, r7
;     pico_default_asm_volatile ("wfe");
10000f22: bf20         	wfe
; }
10000f24: e7e5         	b	0x10000ef2 <sleep_ms+0xae> @ imm = #-0x36
;     if (absolute_time_diff_us(get_absolute_time(), t_before) > 0) {
10000f26: 2a00         	cmp	r2, #0x0
10000f28: d0b6         	beq	0x10000e98 <sleep_ms+0x54> @ imm = #-0x94
10000f2a: e7c9         	b	0x10000ec0 <sleep_ms+0x7c> @ imm = #-0x6e
10000f2c: ff ff ff 7f  	.word	0x7fffffff
10000f30: 15 09 00 10  	.word	0x10000915
10000f34: 9c 01 00 20  	.word	0x2000019c
10000f38: 00 40 05 40  	.word	0x40054000
10000f3c: cc 05 00 20  	.word	0x200005cc

10000f40 <best_effort_wfe_or_timeout>:
; bool best_effort_wfe_or_timeout(absolute_time_t timeout_timestamp) {
10000f40: b5f0         	push	{r4, r5, r6, r7, lr}
10000f42: 4657         	mov	r7, r10
10000f44: 464e         	mov	r6, r9
10000f46: 46de         	mov	lr, r11
10000f48: 4645         	mov	r5, r8
10000f4a: b5e0         	push	{r5, r6, r7, lr}
10000f4c: 0006         	movs	r6, r0
10000f4e: 000f         	movs	r7, r1
10000f50: b085         	sub	sp, #0x14
;     pico_default_asm_volatile ( "mrs %0, ipsr" : "=l" (exception));
10000f52: f3ef 8305    	mrs	r3, ipsr
10000f56: 4699         	mov	r9, r3
;     uint32_t hi_target = (uint32_t)(target >> 32u);
10000f58: 468b         	mov	r11, r1
;     if (__get_current_exception()) {
10000f5a: 2b00         	cmp	r3, #0x0
10000f5c: d012         	beq	0x10000f84 <best_effort_wfe_or_timeout+0x44> @ imm = #0x24
;     uint32_t hi = timer->timerawh;
10000f5e: 4938         	ldr	r1, [pc, #0xe0]         @ 0x10001040 <best_effort_wfe_or_timeout+0x100>
10000f60: 2000         	movs	r0, #0x0
10000f62: 6a4b         	ldr	r3, [r1, #0x24]
;     return (hi >= hi_target && (timer->timerawl >= (uint32_t) target || hi != hi_target));
10000f64: 42bb         	cmp	r3, r7
10000f66: d306         	blo	0x10000f76 <best_effort_wfe_or_timeout+0x36> @ imm = #0xc
10000f68: 6a8a         	ldr	r2, [r1, #0x28]
10000f6a: 1bdb         	subs	r3, r3, r7
10000f6c: 1e59         	subs	r1, r3, #0x1
10000f6e: 418b         	sbcs	r3, r1
10000f70: 42b2         	cmp	r2, r6
10000f72: 4140         	adcs	r0, r0
10000f74: 4318         	orrs	r0, r3
; }
10000f76: b005         	add	sp, #0x14
10000f78: bcf0         	pop	{r4, r5, r6, r7}
10000f7a: 46bb         	mov	r11, r7
10000f7c: 46b2         	mov	r10, r6
10000f7e: 46a9         	mov	r9, r5
10000f80: 46a0         	mov	r8, r4
10000f82: bdf0         	pop	{r4, r5, r6, r7, pc}
;         if (ta_wakes_up_on_or_before(alarm_pool_get_default()->timer, alarm_pool_get_default()->timer_alarm_num,
10000f84: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x10001044 <best_effort_wfe_or_timeout+0x104>
10000f86: 469a         	mov	r10, r3
10000f88: 68db         	ldr	r3, [r3, #0xc]
10000f8a: 4698         	mov	r8, r3
10000f8c: 4653         	mov	r3, r10
10000f8e: 781b         	ldrb	r3, [r3]
;     int64_t current = (int64_t)timer_time_us_64(timer_hw_from_timer(timer));
10000f90: 4640         	mov	r0, r8
;         if (ta_wakes_up_on_or_before(alarm_pool_get_default()->timer, alarm_pool_get_default()->timer_alarm_num,
10000f92: 9303         	str	r3, [sp, #0xc]
;     int64_t current = (int64_t)timer_time_us_64(timer_hw_from_timer(timer));
10000f94: f000 f864    	bl	0x10001060 <timer_time_us_64> @ imm = #0xc8
;     uint32_t time_til_alarm = timer_hw_from_timer(timer)->alarm[alarm_num] - (uint32_t)current;
10000f98: 4642         	mov	r2, r8
10000f9a: 9b03         	ldr	r3, [sp, #0xc]
;     int64_t current = (int64_t)timer_time_us_64(timer_hw_from_timer(timer));
10000f9c: 0004         	movs	r4, r0
;     uint32_t time_til_alarm = timer_hw_from_timer(timer)->alarm[alarm_num] - (uint32_t)current;
10000f9e: 3304         	adds	r3, #0x4
10000fa0: 009b         	lsls	r3, r3, #0x2
10000fa2: 589b         	ldr	r3, [r3, r2]
;     int64_t current = (int64_t)timer_time_us_64(timer_hw_from_timer(timer));
10000fa4: 000d         	movs	r5, r1
;     uint32_t time_til_alarm = timer_hw_from_timer(timer)->alarm[alarm_num] - (uint32_t)current;
10000fa6: 1a1b         	subs	r3, r3, r0
;     int64_t time_til_target = target - current;
10000fa8: 0039         	movs	r1, r7
10000faa: 0030         	movs	r0, r6
10000fac: 1b00         	subs	r0, r0, r4
10000fae: 41a9         	sbcs	r1, r5
;         if (ta_wakes_up_on_or_before(alarm_pool_get_default()->timer, alarm_pool_get_default()->timer_alarm_num,
10000fb0: 4589         	cmp	r9, r1
10000fb2: dc10         	bgt	0x10000fd6 <best_effort_wfe_or_timeout+0x96> @ imm = #0x20
10000fb4: d00d         	beq	0x10000fd2 <best_effort_wfe_or_timeout+0x92> @ imm = #0x1a
;     pico_default_asm_volatile ("wfe");
10000fb6: bf20         	wfe
;     uint32_t hi = timer->timerawh;
10000fb8: 4a21         	ldr	r2, [pc, #0x84]         @ 0x10001040 <best_effort_wfe_or_timeout+0x100>
10000fba: 2000         	movs	r0, #0x0
10000fbc: 6a53         	ldr	r3, [r2, #0x24]
;     return (hi >= hi_target && (timer->timerawl >= (uint32_t) target || hi != hi_target));
10000fbe: 455b         	cmp	r3, r11
10000fc0: d3d9         	blo	0x10000f76 <best_effort_wfe_or_timeout+0x36> @ imm = #-0x4e
10000fc2: 6a92         	ldr	r2, [r2, #0x28]
10000fc4: 1bdb         	subs	r3, r3, r7
10000fc6: 1e59         	subs	r1, r3, #0x1
10000fc8: 418b         	sbcs	r3, r1
10000fca: 42b2         	cmp	r2, r6
10000fcc: 4140         	adcs	r0, r0
10000fce: 4318         	orrs	r0, r3
10000fd0: e7d1         	b	0x10000f76 <best_effort_wfe_or_timeout+0x36> @ imm = #-0x5e
;         if (ta_wakes_up_on_or_before(alarm_pool_get_default()->timer, alarm_pool_get_default()->timer_alarm_num,
10000fd2: 4283         	cmp	r3, r0
10000fd4: d9ef         	bls	0x10000fb6 <best_effort_wfe_or_timeout+0x76> @ imm = #-0x22
;     update_us_since_boot(&t, time_us_64());
10000fd6: f000 f84b    	bl	0x10001070 <time_us_64> @ imm = #0x96
;     return (int64_t)(to_us_since_boot(to) - to_us_since_boot(from));
10000fda: 0032         	movs	r2, r6
10000fdc: 003b         	movs	r3, r7
10000fde: 1a12         	subs	r2, r2, r0
10000fe0: 418b         	sbcs	r3, r1
;         if (absolute_time_diff_us(t, time) < 0) return 0;
10000fe2: 2b00         	cmp	r3, #0x0
10000fe4: db1a         	blt	0x1000101c <best_effort_wfe_or_timeout+0xdc> @ imm = #0x34
;     return alarm_pool_add_alarm_at_force_in_context(pool, time, callback, user_data);
10000fe6: 2300         	movs	r3, #0x0
10000fe8: 9301         	str	r3, [sp, #0x4]
10000fea: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x10001048 <best_effort_wfe_or_timeout+0x108>
10000fec: 0032         	movs	r2, r6
10000fee: 9300         	str	r3, [sp]
10000ff0: 4650         	mov	r0, r10
10000ff2: 003b         	movs	r3, r7
10000ff4: f7ff fe94    	bl	0x10000d20 <alarm_pool_add_alarm_at_force_in_context> @ imm = #-0x2d8
10000ff8: 1e01         	subs	r1, r0, #0x0
;             if (id <= 0) {
10000ffa: dd0f         	ble	0x1000101c <best_effort_wfe_or_timeout+0xdc> @ imm = #0x1e
;     uint32_t hi = timer->timerawh;
10000ffc: 4b10         	ldr	r3, [pc, #0x40]         @ 0x10001040 <best_effort_wfe_or_timeout+0x100>
10000ffe: 6a5a         	ldr	r2, [r3, #0x24]
;     return (hi >= hi_target && (timer->timerawl >= (uint32_t) target || hi != hi_target));
10001000: 455a         	cmp	r2, r11
10001002: d31b         	blo	0x1000103c <best_effort_wfe_or_timeout+0xfc> @ imm = #0x36
10001004: 6a9b         	ldr	r3, [r3, #0x28]
10001006: 42b3         	cmp	r3, r6
10001008: d316         	blo	0x10001038 <best_effort_wfe_or_timeout+0xf8> @ imm = #0x2c
;     return alarm_pool_cancel_alarm(alarm_pool_get_default(), alarm_id);
1000100a: 4650         	mov	r0, r10
1000100c: f7ff fee0    	bl	0x10000dd0 <alarm_pool_cancel_alarm> @ imm = #-0x240
;     uint32_t hi = timer->timerawh;
10001010: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x10001040 <best_effort_wfe_or_timeout+0x100>
10001012: 2000         	movs	r0, #0x0
10001014: 6a53         	ldr	r3, [r2, #0x24]
;     return (hi >= hi_target && (timer->timerawl >= (uint32_t) target || hi != hi_target));
10001016: 455b         	cmp	r3, r11
10001018: d3ad         	blo	0x10000f76 <best_effort_wfe_or_timeout+0x36> @ imm = #-0xa6
1000101a: e7d2         	b	0x10000fc2 <best_effort_wfe_or_timeout+0x82> @ imm = #-0x5c
;     uint32_t hi = timer->timerawh;
1000101c: 4a08         	ldr	r2, [pc, #0x20]         @ 0x10001040 <best_effort_wfe_or_timeout+0x100>
1000101e: 2000         	movs	r0, #0x0
10001020: 6a53         	ldr	r3, [r2, #0x24]
;     return (hi >= hi_target && (timer->timerawl >= (uint32_t) target || hi != hi_target));
10001022: 455b         	cmp	r3, r11
10001024: d3a7         	blo	0x10000f76 <best_effort_wfe_or_timeout+0x36> @ imm = #-0xb2
10001026: 2000         	movs	r0, #0x0
10001028: 6a92         	ldr	r2, [r2, #0x28]
1000102a: 1bdb         	subs	r3, r3, r7
1000102c: 42b2         	cmp	r2, r6
1000102e: 4140         	adcs	r0, r0
10001030: 1e5a         	subs	r2, r3, #0x1
10001032: 4193         	sbcs	r3, r2
10001034: 4318         	orrs	r0, r3
;                 return time_reached(timeout_timestamp);
10001036: e79e         	b	0x10000f76 <best_effort_wfe_or_timeout+0x36> @ imm = #-0xc4
;     return (hi >= hi_target && (timer->timerawl >= (uint32_t) target || hi != hi_target));
10001038: 455a         	cmp	r2, r11
1000103a: d1e6         	bne	0x1000100a <best_effort_wfe_or_timeout+0xca> @ imm = #-0x34
;     pico_default_asm_volatile ("wfe");
1000103c: bf20         	wfe
; }
1000103e: e7e4         	b	0x1000100a <best_effort_wfe_or_timeout+0xca> @ imm = #-0x38
10001040: 00 40 05 40  	.word	0x40054000
10001044: 9c 01 00 20  	.word	0x2000019c
10001048: 15 09 00 10  	.word	0x10000915

1000104c <timer_hardware_alarm_claim>:
; void timer_hardware_alarm_claim(timer_hw_t *timer, uint alarm_num) {
1000104c: b510         	push	{r4, lr}
;     hw_claim_or_assert(&claimed[timer_get_index(timer)], alarm_num, "Hardware alarm %d already claimed");
1000104e: 4a02         	ldr	r2, [pc, #0x8]          @ 0x10001058 <timer_hardware_alarm_claim+0xc>
10001050: 4802         	ldr	r0, [pc, #0x8]          @ 0x1000105c <timer_hardware_alarm_claim+0x10>
10001052: f7ff fba5    	bl	0x100007a0 <hw_claim_or_assert> @ imm = #-0x8b6
; }
10001056: bd10         	pop	{r4, pc}
10001058: 4c 43 00 10  	.word	0x1000434c
1000105c: 68 05 00 20  	.word	0x20000568

10001060 <timer_time_us_64>:
; uint64_t timer_time_us_64(timer_hw_t *timer) {
10001060: 0003         	movs	r3, r0
;     uint32_t hi = timer->timerawh;
10001062: 6a41         	ldr	r1, [r0, #0x24]
;         lo = timer->timerawl;
10001064: 000a         	movs	r2, r1
10001066: 6a98         	ldr	r0, [r3, #0x28]
;         uint32_t next_hi = timer->timerawh;
10001068: 6a59         	ldr	r1, [r3, #0x24]
;         if (hi == next_hi) break;
1000106a: 428a         	cmp	r2, r1
1000106c: d1fa         	bne	0x10001064 <timer_time_us_64+0x4> @ imm = #-0xc
; }
1000106e: 4770         	bx	lr

10001070 <time_us_64>:
;     uint32_t hi = timer->timerawh;
10001070: 4b03         	ldr	r3, [pc, #0xc]          @ 0x10001080 <time_us_64+0x10>
10001072: 6a59         	ldr	r1, [r3, #0x24]
;         lo = timer->timerawl;
10001074: 000a         	movs	r2, r1
10001076: 6a98         	ldr	r0, [r3, #0x28]
;         uint32_t next_hi = timer->timerawh;
10001078: 6a59         	ldr	r1, [r3, #0x24]
;         if (hi == next_hi) break;
1000107a: 4291         	cmp	r1, r2
1000107c: d1fa         	bne	0x10001074 <time_us_64+0x4> @ imm = #-0xc
; }
1000107e: 4770         	bx	lr
10001080: 00 40 05 40  	.word	0x40054000

10001084 <busy_wait_until>:
;     uint32_t hi = timer->timerawh;
10001084: 4a06         	ldr	r2, [pc, #0x18]         @ 0x100010a0 <busy_wait_until+0x1c>
10001086: 6a53         	ldr	r3, [r2, #0x24]
;     while (hi < hi_target) {
10001088: 4299         	cmp	r1, r3
1000108a: d8fc         	bhi	0x10001086 <busy_wait_until+0x2> @ imm = #-0x8
;     while (hi == hi_target && timer->timerawl < (uint32_t) target) {
1000108c: d107         	bne	0x1000109e <busy_wait_until+0x1a> @ imm = #0xe
1000108e: 4b04         	ldr	r3, [pc, #0x10]         @ 0x100010a0 <busy_wait_until+0x1c>
10001090: e002         	b	0x10001098 <busy_wait_until+0x14> @ imm = #0x4
;         hi = timer->timerawh;
10001092: 6a5a         	ldr	r2, [r3, #0x24]
;     while (hi == hi_target && timer->timerawl < (uint32_t) target) {
10001094: 4291         	cmp	r1, r2
10001096: d102         	bne	0x1000109e <busy_wait_until+0x1a> @ imm = #0x4
10001098: 6a9a         	ldr	r2, [r3, #0x28]
1000109a: 4290         	cmp	r0, r2
1000109c: d8f9         	bhi	0x10001092 <busy_wait_until+0xe> @ imm = #-0xe
; }
1000109e: 4770         	bx	lr
100010a0: 00 40 05 40  	.word	0x40054000

100010a4 <clock_configure_int_divider>:
; void clock_configure_int_divider(clock_handle_t clock, uint32_t src, uint32_t auxsrc, uint32_t src_freq, uint32_t int_divider) {
100010a4: b5f8         	push	{r3, r4, r5, r6, r7, lr}
100010a6: 46de         	mov	lr, r11
100010a8: 464e         	mov	r6, r9
100010aa: 4657         	mov	r7, r10
100010ac: 4645         	mov	r5, r8
100010ae: b5e0         	push	{r5, r6, r7, lr}
100010b0: 468b         	mov	r11, r1
100010b2: 0005         	movs	r5, r0
;     clock_configure_internal(clock, src, auxsrc, src_freq / int_divider, int_divider << CLOCKS_CLK_GPOUT0_DIV_INT_LSB);
100010b4: 990a         	ldr	r1, [sp, #0x28]
; void clock_configure_int_divider(clock_handle_t clock, uint32_t src, uint32_t auxsrc, uint32_t src_freq, uint32_t int_divider) {
100010b6: 0018         	movs	r0, r3
100010b8: 0016         	movs	r6, r2
;     clock_configure_internal(clock, src, auxsrc, src_freq / int_divider, int_divider << CLOCKS_CLK_GPOUT0_DIV_INT_LSB);
100010ba: f000 fa8f    	bl	0x100015dc <divmod_u32u32> @ imm = #0x51e
100010be: 9b0a         	ldr	r3, [sp, #0x28]
;     clock_hw_t *clock_hw = &clocks_hw->clk[clock];
100010c0: 006c         	lsls	r4, r5, #0x1
;     clock_configure_internal(clock, src, auxsrc, src_freq / int_divider, int_divider << CLOCKS_CLK_GPOUT0_DIV_INT_LSB);
100010c2: 021f         	lsls	r7, r3, #0x8
;     clock_hw_t *clock_hw = &clocks_hw->clk[clock];
100010c4: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x10001190 <clock_configure_int_divider+0xec>
100010c6: 1964         	adds	r4, r4, r5
100010c8: 469c         	mov	r12, r3
100010ca: 00a4         	lsls	r4, r4, #0x2
100010cc: 4464         	add	r4, r12
;     if (div > clock_hw->div)
100010ce: 6863         	ldr	r3, [r4, #0x4]
;     clock_configure_internal(clock, src, auxsrc, src_freq / int_divider, int_divider << CLOCKS_CLK_GPOUT0_DIV_INT_LSB);
100010d0: 4681         	mov	r9, r0
;     if (div > clock_hw->div)
100010d2: 429f         	cmp	r7, r3
100010d4: d900         	bls	0x100010d8 <clock_configure_int_divider+0x34> @ imm = #0x0
;         clock_hw->div = div;
100010d6: 6067         	str	r7, [r4, #0x4]
;     return clock == clk_sys || clock == clk_ref;
100010d8: 1f2b         	subs	r3, r5, #0x4
100010da: b2db         	uxtb	r3, r3
100010dc: 4698         	mov	r8, r3
;     if (has_glitchless_mux(clock) && src == CLOCKS_CLK_SYS_CTRL_SRC_VALUE_CLKSRC_CLK_SYS_AUX) {
100010de: 2b01         	cmp	r3, #0x1
100010e0: d930         	bls	0x10001144 <clock_configure_int_divider+0xa0> @ imm = #0x60
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
100010e2: 23c0         	movs	r3, #0xc0
100010e4: 2280         	movs	r2, #0x80
100010e6: 019b         	lsls	r3, r3, #0x6
100010e8: 18e3         	adds	r3, r4, r3
100010ea: 0112         	lsls	r2, r2, #0x4
100010ec: 601a         	str	r2, [r3]
;         if (configured_freq[clock] > 0) {
100010ee: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x10001194 <clock_configure_int_divider+0xf0>
100010f0: 00ad         	lsls	r5, r5, #0x2
100010f2: 5959         	ldr	r1, [r3, r5]
100010f4: 469a         	mov	r10, r3
100010f6: 2900         	cmp	r1, #0x0
100010f8: d11b         	bne	0x10001132 <clock_configure_int_divider+0x8e> @ imm = #0x36
;     hw_write_masked(&clock_hw->ctrl,
100010fa: 0173         	lsls	r3, r6, #0x5
;     hw_xor_bits(addr, (*addr ^ values) & write_mask);
100010fc: 26e0         	movs	r6, #0xe0
100010fe: 6822         	ldr	r2, [r4]
10001100: 4053         	eors	r3, r2
10001102: 401e         	ands	r6, r3
;     *(io_rw_32 *) hw_xor_alias_untyped((volatile void *) addr) = mask;
10001104: 2380         	movs	r3, #0x80
;     if (has_glitchless_mux(clock)) {
10001106: 4642         	mov	r2, r8
;     *(io_rw_32 *) hw_xor_alias_untyped((volatile void *) addr) = mask;
10001108: 015b         	lsls	r3, r3, #0x5
1000110a: 18e3         	adds	r3, r4, r3
1000110c: 601e         	str	r6, [r3]
;     if (has_glitchless_mux(clock)) {
1000110e: 2a01         	cmp	r2, #0x1
10001110: d930         	bls	0x10001174 <clock_configure_int_divider+0xd0> @ imm = #0x60
;     *(io_rw_32 *) hw_set_alias_untyped((volatile void *) addr) = mask;
10001112: 2380         	movs	r3, #0x80
10001114: 2280         	movs	r2, #0x80
10001116: 019b         	lsls	r3, r3, #0x6
10001118: 18e3         	adds	r3, r4, r3
1000111a: 0112         	lsls	r2, r2, #0x4
1000111c: 601a         	str	r2, [r3]
;     configured_freq[clock] = actual_freq;
1000111e: 4653         	mov	r3, r10
10001120: 464a         	mov	r2, r9
;     clock_hw->div = div;
10001122: 6067         	str	r7, [r4, #0x4]
;     configured_freq[clock] = actual_freq;
10001124: 515a         	str	r2, [r3, r5]
; }
10001126: bcf0         	pop	{r4, r5, r6, r7}
10001128: 46bb         	mov	r11, r7
1000112a: 46b2         	mov	r10, r6
1000112c: 46a9         	mov	r9, r5
1000112e: 46a0         	mov	r8, r4
10001130: bdf8         	pop	{r3, r4, r5, r6, r7, pc}
;             uint delay_cyc = configured_freq[clk_sys] / configured_freq[clock] + 1;
10001132: 6958         	ldr	r0, [r3, #0x14]
10001134: f000 fa52    	bl	0x100015dc <divmod_u32u32> @ imm = #0x4a4
10001138: 3001         	adds	r0, #0x1
;             busy_wait_at_least_cycles(delay_cyc * 3);
1000113a: 0043         	lsls	r3, r0, #0x1
1000113c: 181b         	adds	r3, r3, r0
;     pico_default_asm_volatile(
1000113e: 3b03         	subs	r3, #0x3
10001140: d2fd         	bhs	0x1000113e <clock_configure_int_divider+0x9a> @ imm = #-0x6
; }
10001142: e7da         	b	0x100010fa <clock_configure_int_divider+0x56> @ imm = #-0x4c
;     if (has_glitchless_mux(clock) && src == CLOCKS_CLK_SYS_CTRL_SRC_VALUE_CLKSRC_CLK_SYS_AUX) {
10001144: 465b         	mov	r3, r11
10001146: 2b01         	cmp	r3, #0x1
10001148: d1cb         	bne	0x100010e2 <clock_configure_int_divider+0x3e> @ imm = #-0x6a
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
1000114a: 23c0         	movs	r3, #0xc0
1000114c: 2203         	movs	r2, #0x3
1000114e: 019b         	lsls	r3, r3, #0x6
10001150: 18e3         	adds	r3, r4, r3
10001152: 601a         	str	r2, [r3]
;         while (!(clock_hw->selected & 1u))
10001154: 3a02         	subs	r2, #0x2
10001156: 68a3         	ldr	r3, [r4, #0x8]
10001158: 421a         	tst	r2, r3
1000115a: d0fc         	beq	0x10001156 <clock_configure_int_divider+0xb2> @ imm = #-0x8
;     hw_write_masked(&clock_hw->ctrl,
1000115c: 0173         	lsls	r3, r6, #0x5
;     hw_xor_bits(addr, (*addr ^ values) & write_mask);
1000115e: 26e0         	movs	r6, #0xe0
10001160: 6822         	ldr	r2, [r4]
10001162: 00ad         	lsls	r5, r5, #0x2
10001164: 4053         	eors	r3, r2
10001166: 401e         	ands	r6, r3
;     *(io_rw_32 *) hw_xor_alias_untyped((volatile void *) addr) = mask;
10001168: 2380         	movs	r3, #0x80
1000116a: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x10001194 <clock_configure_int_divider+0xf0>
1000116c: 015b         	lsls	r3, r3, #0x5
1000116e: 4692         	mov	r10, r2
10001170: 18e3         	adds	r3, r4, r3
10001172: 601e         	str	r6, [r3]
;     hw_xor_bits(addr, (*addr ^ values) & write_mask);
10001174: 465a         	mov	r2, r11
10001176: 6821         	ldr	r1, [r4]
10001178: 4051         	eors	r1, r2
1000117a: 2203         	movs	r2, #0x3
1000117c: 400a         	ands	r2, r1
;     *(io_rw_32 *) hw_xor_alias_untyped((volatile void *) addr) = mask;
1000117e: 601a         	str	r2, [r3]
;         while (!(clock_hw->selected & (1u << src)))
10001180: 2201         	movs	r2, #0x1
10001182: 465b         	mov	r3, r11
10001184: 409a         	lsls	r2, r3
10001186: 68a3         	ldr	r3, [r4, #0x8]
10001188: 421a         	tst	r2, r3
1000118a: d0fc         	beq	0x10001186 <clock_configure_int_divider+0xe2> @ imm = #-0x8
1000118c: e7c1         	b	0x10001112 <clock_configure_int_divider+0x6e> @ imm = #-0x7e
1000118e: 46c0         	mov	r8, r8
10001190: 00 80 00 40  	.word	0x40008000
10001194: 6c 05 00 20  	.word	0x2000056c

10001198 <clock_configure_undivided>:
; void clock_configure_undivided(clock_handle_t clock, uint32_t src, uint32_t auxsrc, uint32_t src_freq) {
10001198: b5f0         	push	{r4, r5, r6, r7, lr}
1000119a: 4646         	mov	r6, r8
1000119c: 464f         	mov	r7, r9
1000119e: 46d6         	mov	lr, r10
100011a0: b5c0         	push	{r6, r7, lr}
100011a2: 001f         	movs	r7, r3
;     clock_hw_t *clock_hw = &clocks_hw->clk[clock];
100011a4: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x10001278 <clock_configure_undivided+0xe0>
100011a6: 0044         	lsls	r4, r0, #0x1
100011a8: 469c         	mov	r12, r3
100011aa: 1824         	adds	r4, r4, r0
100011ac: 00a4         	lsls	r4, r4, #0x2
100011ae: 4464         	add	r4, r12
;     if (div > clock_hw->div)
100011b0: 6863         	ldr	r3, [r4, #0x4]
; void clock_configure_undivided(clock_handle_t clock, uint32_t src, uint32_t auxsrc, uint32_t src_freq) {
100011b2: 4688         	mov	r8, r1
100011b4: 0016         	movs	r6, r2
;     if (div > clock_hw->div)
100011b6: 2bff         	cmp	r3, #0xff
100011b8: d802         	bhi	0x100011c0 <clock_configure_undivided+0x28> @ imm = #0x4
;         clock_hw->div = div;
100011ba: 2380         	movs	r3, #0x80
100011bc: 005b         	lsls	r3, r3, #0x1
100011be: 6063         	str	r3, [r4, #0x4]
;     return clock == clk_sys || clock == clk_ref;
100011c0: 1f03         	subs	r3, r0, #0x4
100011c2: b2db         	uxtb	r3, r3
100011c4: 469a         	mov	r10, r3
;     if (has_glitchless_mux(clock) && src == CLOCKS_CLK_SYS_CTRL_SRC_VALUE_CLKSRC_CLK_SYS_AUX) {
100011c6: 2b01         	cmp	r3, #0x1
100011c8: d930         	bls	0x1000122c <clock_configure_undivided+0x94> @ imm = #0x60
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
100011ca: 23c0         	movs	r3, #0xc0
100011cc: 2280         	movs	r2, #0x80
100011ce: 019b         	lsls	r3, r3, #0x6
100011d0: 18e3         	adds	r3, r4, r3
100011d2: 0112         	lsls	r2, r2, #0x4
100011d4: 601a         	str	r2, [r3]
;         if (configured_freq[clock] > 0) {
100011d6: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x1000127c <clock_configure_undivided+0xe4>
100011d8: 0085         	lsls	r5, r0, #0x2
100011da: 5959         	ldr	r1, [r3, r5]
100011dc: 4699         	mov	r9, r3
100011de: 2900         	cmp	r1, #0x0
100011e0: d11b         	bne	0x1000121a <clock_configure_undivided+0x82> @ imm = #0x36
;     hw_write_masked(&clock_hw->ctrl,
100011e2: 0173         	lsls	r3, r6, #0x5
;     hw_xor_bits(addr, (*addr ^ values) & write_mask);
100011e4: 26e0         	movs	r6, #0xe0
100011e6: 6822         	ldr	r2, [r4]
100011e8: 4053         	eors	r3, r2
100011ea: 401e         	ands	r6, r3
;     *(io_rw_32 *) hw_xor_alias_untyped((volatile void *) addr) = mask;
100011ec: 2380         	movs	r3, #0x80
;     if (has_glitchless_mux(clock)) {
100011ee: 4652         	mov	r2, r10
;     *(io_rw_32 *) hw_xor_alias_untyped((volatile void *) addr) = mask;
100011f0: 015b         	lsls	r3, r3, #0x5
100011f2: 18e3         	adds	r3, r4, r3
100011f4: 601e         	str	r6, [r3]
;     if (has_glitchless_mux(clock)) {
100011f6: 2a01         	cmp	r2, #0x1
100011f8: d930         	bls	0x1000125c <clock_configure_undivided+0xc4> @ imm = #0x60
;     *(io_rw_32 *) hw_set_alias_untyped((volatile void *) addr) = mask;
100011fa: 2380         	movs	r3, #0x80
100011fc: 2280         	movs	r2, #0x80
100011fe: 019b         	lsls	r3, r3, #0x6
10001200: 18e3         	adds	r3, r4, r3
10001202: 0112         	lsls	r2, r2, #0x4
10001204: 601a         	str	r2, [r3]
;     clock_hw->div = div;
10001206: 2380         	movs	r3, #0x80
10001208: 005b         	lsls	r3, r3, #0x1
1000120a: 6063         	str	r3, [r4, #0x4]
;     configured_freq[clock] = actual_freq;
1000120c: 464b         	mov	r3, r9
1000120e: 515f         	str	r7, [r3, r5]
; }
10001210: bce0         	pop	{r5, r6, r7}
10001212: 46ba         	mov	r10, r7
10001214: 46b1         	mov	r9, r6
10001216: 46a8         	mov	r8, r5
10001218: bdf0         	pop	{r4, r5, r6, r7, pc}
;             uint delay_cyc = configured_freq[clk_sys] / configured_freq[clock] + 1;
1000121a: 6958         	ldr	r0, [r3, #0x14]
1000121c: f000 f9de    	bl	0x100015dc <divmod_u32u32> @ imm = #0x3bc
10001220: 3001         	adds	r0, #0x1
;             busy_wait_at_least_cycles(delay_cyc * 3);
10001222: 0043         	lsls	r3, r0, #0x1
10001224: 181b         	adds	r3, r3, r0
;     pico_default_asm_volatile(
10001226: 3b03         	subs	r3, #0x3
10001228: d2fd         	bhs	0x10001226 <clock_configure_undivided+0x8e> @ imm = #-0x6
; }
1000122a: e7da         	b	0x100011e2 <clock_configure_undivided+0x4a> @ imm = #-0x4c
;     if (has_glitchless_mux(clock) && src == CLOCKS_CLK_SYS_CTRL_SRC_VALUE_CLKSRC_CLK_SYS_AUX) {
1000122c: 4643         	mov	r3, r8
1000122e: 2b01         	cmp	r3, #0x1
10001230: d1cb         	bne	0x100011ca <clock_configure_undivided+0x32> @ imm = #-0x6a
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
10001232: 23c0         	movs	r3, #0xc0
10001234: 2203         	movs	r2, #0x3
10001236: 019b         	lsls	r3, r3, #0x6
10001238: 18e3         	adds	r3, r4, r3
1000123a: 601a         	str	r2, [r3]
;         while (!(clock_hw->selected & 1u))
1000123c: 3a02         	subs	r2, #0x2
1000123e: 68a3         	ldr	r3, [r4, #0x8]
10001240: 421a         	tst	r2, r3
10001242: d0fc         	beq	0x1000123e <clock_configure_undivided+0xa6> @ imm = #-0x8
;     hw_write_masked(&clock_hw->ctrl,
10001244: 0173         	lsls	r3, r6, #0x5
;     hw_xor_bits(addr, (*addr ^ values) & write_mask);
10001246: 26e0         	movs	r6, #0xe0
10001248: 6822         	ldr	r2, [r4]
1000124a: 0085         	lsls	r5, r0, #0x2
1000124c: 4053         	eors	r3, r2
1000124e: 401e         	ands	r6, r3
;     *(io_rw_32 *) hw_xor_alias_untyped((volatile void *) addr) = mask;
10001250: 2380         	movs	r3, #0x80
10001252: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x1000127c <clock_configure_undivided+0xe4>
10001254: 015b         	lsls	r3, r3, #0x5
10001256: 4691         	mov	r9, r2
10001258: 18e3         	adds	r3, r4, r3
1000125a: 601e         	str	r6, [r3]
;     hw_xor_bits(addr, (*addr ^ values) & write_mask);
1000125c: 4642         	mov	r2, r8
1000125e: 6821         	ldr	r1, [r4]
10001260: 4051         	eors	r1, r2
10001262: 2203         	movs	r2, #0x3
10001264: 400a         	ands	r2, r1
;     *(io_rw_32 *) hw_xor_alias_untyped((volatile void *) addr) = mask;
10001266: 601a         	str	r2, [r3]
;         while (!(clock_hw->selected & (1u << src)))
10001268: 2301         	movs	r3, #0x1
1000126a: 4642         	mov	r2, r8
1000126c: 4093         	lsls	r3, r2
1000126e: 68a2         	ldr	r2, [r4, #0x8]
10001270: 4213         	tst	r3, r2
10001272: d0fc         	beq	0x1000126e <clock_configure_undivided+0xd6> @ imm = #-0x8
10001274: e7c1         	b	0x100011fa <clock_configure_undivided+0x62> @ imm = #-0x7e
10001276: 46c0         	mov	r8, r8
10001278: 00 80 00 40  	.word	0x40008000
1000127c: 6c 05 00 20  	.word	0x2000056c

10001280 <clock_get_hz>:
;     return configured_freq[clock];
10001280: 4b01         	ldr	r3, [pc, #0x4]          @ 0x10001288 <clock_get_hz+0x8>
10001282: 0080         	lsls	r0, r0, #0x2
10001284: 58c0         	ldr	r0, [r0, r3]
; }
10001286: 4770         	bx	lr
10001288: 6c 05 00 20  	.word	0x2000056c

1000128c <pll_init>:
; void pll_init(PLL pll, uint refdiv, uint vco_freq, uint post_div1, uint post_div2) {
1000128c: b5f8         	push	{r3, r4, r5, r6, r7, lr}
1000128e: 0004         	movs	r4, r0
;     uint32_t ref_freq = XOSC_HZ / refdiv;
10001290: 4821         	ldr	r0, [pc, #0x84]         @ 0x10001318 <pll_init+0x8c>
; void pll_init(PLL pll, uint refdiv, uint vco_freq, uint post_div1, uint post_div2) {
10001292: 001e         	movs	r6, r3
10001294: 0017         	movs	r7, r2
10001296: 000d         	movs	r5, r1
;     uint32_t ref_freq = XOSC_HZ / refdiv;
10001298: f000 f9a0    	bl	0x100015dc <divmod_u32u32> @ imm = #0x340
1000129c: 0001         	movs	r1, r0
;     uint32_t fbdiv = vco_freq / ref_freq;
1000129e: 0038         	movs	r0, r7
100012a0: f000 f99c    	bl	0x100015dc <divmod_u32u32> @ imm = #0x338
;                     (post_div2 << PLL_PRIM_POSTDIV2_LSB);
100012a4: 9b06         	ldr	r3, [sp, #0x18]
;     uint32_t pdiv = (post_div1 << PLL_PRIM_POSTDIV1_LSB) |
100012a6: 0436         	lsls	r6, r6, #0x10
;                     (post_div2 << PLL_PRIM_POSTDIV2_LSB);
100012a8: 031b         	lsls	r3, r3, #0xc
;     uint32_t pdiv = (post_div1 << PLL_PRIM_POSTDIV1_LSB) |
100012aa: 431e         	orrs	r6, r3
;     if ((pll->cs & PLL_CS_LOCK_BITS) &&
100012ac: 6823         	ldr	r3, [r4]
100012ae: 2b00         	cmp	r3, #0x0
100012b0: db20         	blt	0x100012f4 <pll_init+0x68> @ imm = #0x40
;     reset_unreset_block_num_wait_blocking(PLL_RESET_NUM(pll));
100012b2: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x1000131c <pll_init+0x90>
;     while (~*reset_done & mask)
100012b4: 491a         	ldr	r1, [pc, #0x68]         @ 0x10001320 <pll_init+0x94>
;     reset_unreset_block_num_wait_blocking(PLL_RESET_NUM(pll));
100012b6: 18e3         	adds	r3, r4, r3
100012b8: 1e5a         	subs	r2, r3, #0x1
100012ba: 4193         	sbcs	r3, r2
100012bc: 2280         	movs	r2, #0x80
100012be: 0192         	lsls	r2, r2, #0x6
100012c0: 4694         	mov	r12, r2
100012c2: 425b         	rsbs	r3, r3, #0
100012c4: 0b1b         	lsrs	r3, r3, #0xc
;     *(io_rw_32 *) hw_set_alias_untyped((volatile void *) addr) = mask;
100012c6: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x10001324 <pll_init+0x98>
;     reset_unreset_block_num_wait_blocking(PLL_RESET_NUM(pll));
100012c8: 031b         	lsls	r3, r3, #0xc
100012ca: 4463         	add	r3, r12
;     *(io_rw_32 *) hw_set_alias_untyped((volatile void *) addr) = mask;
100012cc: 6013         	str	r3, [r2]
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
100012ce: 4a16         	ldr	r2, [pc, #0x58]         @ 0x10001328 <pll_init+0x9c>
100012d0: 6013         	str	r3, [r2]
;     while (~*reset_done & mask)
100012d2: 001f         	movs	r7, r3
100012d4: 680a         	ldr	r2, [r1]
100012d6: 4397         	bics	r7, r2
100012d8: d1fb         	bne	0x100012d2 <pll_init+0x46> @ imm = #-0xa
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
100012da: 4b14         	ldr	r3, [pc, #0x50]         @ 0x1000132c <pll_init+0xa0>
;     pll->cs = refdiv;
100012dc: 6025         	str	r5, [r4]
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
100012de: 18e2         	adds	r2, r4, r3
100012e0: 2321         	movs	r3, #0x21
;     pll->fbdiv_int = fbdiv;
100012e2: 60a0         	str	r0, [r4, #0x8]
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
100012e4: 6013         	str	r3, [r2]
;     while (!(pll->cs & PLL_CS_LOCK_BITS)) tight_loop_contents();
100012e6: 6823         	ldr	r3, [r4]
100012e8: 2b00         	cmp	r3, #0x0
100012ea: dafc         	bge	0x100012e6 <pll_init+0x5a> @ imm = #-0x8
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
100012ec: 2308         	movs	r3, #0x8
;     pll->prim = pdiv;
100012ee: 60e6         	str	r6, [r4, #0xc]
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
100012f0: 6013         	str	r3, [r2]
; }
100012f2: bdf8         	pop	{r3, r4, r5, r6, r7, pc}
;         (refdiv == (pll->cs & PLL_CS_REFDIV_BITS)) &&
100012f4: 233f         	movs	r3, #0x3f
100012f6: 6822         	ldr	r2, [r4]
100012f8: 4013         	ands	r3, r2
;     if ((pll->cs & PLL_CS_LOCK_BITS) &&
100012fa: 42ab         	cmp	r3, r5
100012fc: d1d9         	bne	0x100012b2 <pll_init+0x26> @ imm = #-0x4e
;         (fbdiv  == (pll->fbdiv_int & PLL_FBDIV_INT_BITS)) &&
100012fe: 68a3         	ldr	r3, [r4, #0x8]
10001300: 051b         	lsls	r3, r3, #0x14
10001302: 0d1b         	lsrs	r3, r3, #0x14
;         (refdiv == (pll->cs & PLL_CS_REFDIV_BITS)) &&
10001304: 4283         	cmp	r3, r0
10001306: d1d4         	bne	0x100012b2 <pll_init+0x26> @ imm = #-0x58
;         (pdiv   == (pll->prim & (PLL_PRIM_POSTDIV1_BITS | PLL_PRIM_POSTDIV2_BITS)))) {
10001308: 22ee         	movs	r2, #0xee
1000130a: 68e3         	ldr	r3, [r4, #0xc]
1000130c: 02d2         	lsls	r2, r2, #0xb
1000130e: 4013         	ands	r3, r2
;         (fbdiv  == (pll->fbdiv_int & PLL_FBDIV_INT_BITS)) &&
10001310: 42b3         	cmp	r3, r6
10001312: d1ce         	bne	0x100012b2 <pll_init+0x26> @ imm = #-0x64
10001314: e7ed         	b	0x100012f2 <pll_init+0x66> @ imm = #-0x26
10001316: 46c0         	mov	r8, r8
10001318: 00 1b b7 00  	.word	0x00b71b00
1000131c: 00 40 fd bf  	.word	0xbffd4000
10001320: 08 c0 00 40  	.word	0x4000c008
10001324: 00 e0 00 40  	.word	0x4000e000
10001328: 00 f0 00 40  	.word	0x4000f000
1000132c: 04 30 00 00  	.word	0x00003004

10001330 <tick_start>:
;     watchdog_hw->tick = cycles | WATCHDOG_TICK_ENABLE_BITS;
10001330: 2380         	movs	r3, #0x80
10001332: 4a02         	ldr	r2, [pc, #0x8]          @ 0x1000133c <tick_start+0xc>
10001334: 009b         	lsls	r3, r3, #0x2
10001336: 430b         	orrs	r3, r1
10001338: 62d3         	str	r3, [r2, #0x2c]
; }
1000133a: 4770         	bx	lr
1000133c: 00 80 05 40  	.word	0x40058000

10001340 <rom_func_lookup>:
;     return (void *)(uintptr_t)*(uint16_t *)(uintptr_t)rom_address;
10001340: 2300         	movs	r3, #0x0
; void *rom_func_lookup(uint32_t code) {
10001342: b510         	push	{r4, lr}
10001344: 0001         	movs	r1, r0
;     return (void *)(uintptr_t)*(uint16_t *)(uintptr_t)rom_address;
10001346: 8a98         	ldrh	r0, [r3, #0x14]
10001348: 8b1b         	ldrh	r3, [r3, #0x18]
;     return rom_table_lookup(func_table, code);
1000134a: 4798         	blx	r3
; }
1000134c: bd10         	pop	{r4, pc}
1000134e: 46c0         	mov	r8, r8

10001350 <rom_data_lookup>:
;     return (void *)(uintptr_t)*(uint16_t *)(uintptr_t)rom_address;
10001350: 2316         	movs	r3, #0x16
; void *rom_data_lookup(uint32_t code) {
10001352: b510         	push	{r4, lr}
10001354: 0001         	movs	r1, r0
;     return (void *)(uintptr_t)*(uint16_t *)(uintptr_t)rom_address;
10001356: 8818         	ldrh	r0, [r3]
10001358: 3302         	adds	r3, #0x2
1000135a: 881b         	ldrh	r3, [r3]
;     return rom_table_lookup(data_table, code);
1000135c: 4798         	blx	r3
; }
1000135e: bd10         	pop	{r4, pc}

10001360 <rom_funcs_lookup>:
; bool rom_funcs_lookup(uint32_t *table, unsigned int count) {
10001360: b5f8         	push	{r3, r4, r5, r6, r7, lr}
10001362: 4647         	mov	r7, r8
10001364: 46ce         	mov	lr, r9
10001366: b580         	push	{r7, lr}
10001368: 1e0f         	subs	r7, r1, #0x0
;     for (unsigned int i = 0; i < count; i++) {
1000136a: d018         	beq	0x1000139e <rom_funcs_lookup+0x3e> @ imm = #0x30
;     return (void *)(uintptr_t)*(uint16_t *)(uintptr_t)rom_address;
1000136c: 2314         	movs	r3, #0x14
1000136e: 4699         	mov	r9, r3
10001370: 3304         	adds	r3, #0x4
10001372: 0004         	movs	r4, r0
;     for (unsigned int i = 0; i < count; i++) {
10001374: 2500         	movs	r5, #0x0
;     bool ok = true;
10001376: 2601         	movs	r6, #0x1
;     return (void *)(uintptr_t)*(uint16_t *)(uintptr_t)rom_address;
10001378: 4698         	mov	r8, r3
1000137a: 464b         	mov	r3, r9
1000137c: 8818         	ldrh	r0, [r3]
1000137e: 4643         	mov	r3, r8
;     return rom_table_lookup(func_table, code);
10001380: 6821         	ldr	r1, [r4]
;     return (void *)(uintptr_t)*(uint16_t *)(uintptr_t)rom_address;
10001382: 881b         	ldrh	r3, [r3]
;     return rom_table_lookup(func_table, code);
10001384: 4798         	blx	r3
;         table[i] = (uintptr_t) rom_func_lookup(table[i]);
10001386: c401         	stm	r4!, {r0}
;         if (!table[i]) ok = false;
10001388: 1e43         	subs	r3, r0, #0x1
1000138a: 4198         	sbcs	r0, r3
;     for (unsigned int i = 0; i < count; i++) {
1000138c: 3501         	adds	r5, #0x1
;         if (!table[i]) ok = false;
1000138e: 4006         	ands	r6, r0
;     for (unsigned int i = 0; i < count; i++) {
10001390: 42af         	cmp	r7, r5
10001392: d1f2         	bne	0x1000137a <rom_funcs_lookup+0x1a> @ imm = #-0x1c
; }
10001394: 0030         	movs	r0, r6
10001396: bcc0         	pop	{r6, r7}
10001398: 46b9         	mov	r9, r7
1000139a: 46b0         	mov	r8, r6
1000139c: bdf8         	pop	{r3, r4, r5, r6, r7, pc}
;     bool ok = true;
1000139e: 2601         	movs	r6, #0x1
100013a0: e7f8         	b	0x10001394 <rom_funcs_lookup+0x34> @ imm = #-0x10
100013a2: 46c0         	mov	r8, r8

100013a4 <xosc_init>:
;     xosc_hw->ctrl = XOSC_CTRL_FREQ_RANGE_VALUE_1_15MHZ;
100013a4: 23aa         	movs	r3, #0xaa
100013a6: 4a06         	ldr	r2, [pc, #0x18]         @ 0x100013c0 <xosc_init+0x1c>
100013a8: 011b         	lsls	r3, r3, #0x4
100013aa: 6013         	str	r3, [r2]
;     xosc_hw->startup = STARTUP_DELAY;
100013ac: 238d         	movs	r3, #0x8d
100013ae: 005b         	lsls	r3, r3, #0x1
100013b0: 60d3         	str	r3, [r2, #0xc]
;     *(io_rw_32 *) hw_set_alias_untyped((volatile void *) addr) = mask;
100013b2: 4904         	ldr	r1, [pc, #0x10]         @ 0x100013c4 <xosc_init+0x20>
100013b4: 4b04         	ldr	r3, [pc, #0x10]         @ 0x100013c8 <xosc_init+0x24>
100013b6: 6019         	str	r1, [r3]
;     while(!(xosc_hw->status & XOSC_STATUS_STABLE_BITS)) {
100013b8: 6853         	ldr	r3, [r2, #0x4]
100013ba: 2b00         	cmp	r3, #0x0
100013bc: dafc         	bge	0x100013b8 <xosc_init+0x14> @ imm = #-0x8
; }
100013be: 4770         	bx	lr
100013c0: 00 40 02 40  	.word	0x40024000
100013c4: 00 b0 fa 00  	.word	0x00fab000
100013c8: 00 60 02 40  	.word	0x40026000

100013cc <first_per_core_initializer>:
; static void first_per_core_initializer(void) {}
100013cc: 4770         	bx	lr
100013ce: 46c0         	mov	r8, r8

100013d0 <hard_assertion_failure>:
; void __weak hard_assertion_failure(void) {
100013d0: b510         	push	{r4, lr}
;     panic("Hard assert");
100013d2: 4801         	ldr	r0, [pc, #0x4]          @ 0x100013d8 <hard_assertion_failure+0x8>
100013d4: f7ff f9cc    	bl	0x10000770 <panic>      @ imm = #-0xc68
100013d8: 70 43 00 10  	.word	0x10004370

100013dc <runtime_run_initializers>:
; void runtime_run_initializers(void) {
100013dc: b570         	push	{r4, r5, r6, lr}
;     for (uintptr_t *p = from; p < &__preinit_array_end; p++) {
100013de: 4d07         	ldr	r5, [pc, #0x1c]         @ 0x100013fc <runtime_run_initializers+0x20>
100013e0: 4e07         	ldr	r6, [pc, #0x1c]         @ 0x10001400 <runtime_run_initializers+0x24>
100013e2: 42b5         	cmp	r5, r6
100013e4: d209         	bhs	0x100013fa <runtime_run_initializers+0x1e> @ imm = #0x12
100013e6: 2400         	movs	r4, #0x0
100013e8: 3e01         	subs	r6, #0x1
100013ea: 1b76         	subs	r6, r6, r5
100013ec: 08b6         	lsrs	r6, r6, #0x2
;         ((void (*)(void))val)();
100013ee: cd08         	ldm	r5!, {r3}
100013f0: 4798         	blx	r3
;     for (uintptr_t *p = from; p < &__preinit_array_end; p++) {
100013f2: 0023         	movs	r3, r4
100013f4: 3401         	adds	r4, #0x1
100013f6: 42b3         	cmp	r3, r6
100013f8: d1f9         	bne	0x100013ee <runtime_run_initializers+0x12> @ imm = #-0xe
; }
100013fa: bd70         	pop	{r4, r5, r6, pc}
100013fc: 40 41 00 10  	.word	0x10004140
10001400: 7c 41 00 10  	.word	0x1000417c

10001404 <runtime_init_early_resets>:
;     *(io_rw_32 *) hw_set_alias_untyped((volatile void *) addr) = mask;
10001404: 4b05         	ldr	r3, [pc, #0x14]         @ 0x1000141c <runtime_init_early_resets+0x18>
10001406: 4a06         	ldr	r2, [pc, #0x18]         @ 0x10001420 <runtime_init_early_resets+0x1c>
;     while (~*reset_done & mask)
10001408: 4906         	ldr	r1, [pc, #0x18]         @ 0x10001424 <runtime_init_early_resets+0x20>
;     *(io_rw_32 *) hw_set_alias_untyped((volatile void *) addr) = mask;
1000140a: 601a         	str	r2, [r3]
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
1000140c: 4a06         	ldr	r2, [pc, #0x18]         @ 0x10001428 <runtime_init_early_resets+0x24>
1000140e: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x1000142c <runtime_init_early_resets+0x28>
10001410: 601a         	str	r2, [r3]
;     while (~*reset_done & mask)
10001412: 0010         	movs	r0, r2
10001414: 680b         	ldr	r3, [r1]
10001416: 4398         	bics	r0, r3
10001418: d1fb         	bne	0x10001412 <runtime_init_early_resets+0xe> @ imm = #-0xa
; }
1000141a: 4770         	bx	lr
1000141c: 00 e0 00 40  	.word	0x4000e000
10001420: bf cd fb fe  	.word	0xfefbcdbf
10001424: 08 c0 00 40  	.word	0x4000c008
10001428: fe 7f 3c 00  	.word	0x003c7ffe
1000142c: 00 f0 00 40  	.word	0x4000f000

10001430 <runtime_init_usb_power_down>:
;     if (usb_hw->sie_ctrl == USB_SIE_CTRL_RESET) {
10001430: 4b04         	ldr	r3, [pc, #0x10]         @ 0x10001444 <runtime_init_usb_power_down+0x14>
10001432: 6cdb         	ldr	r3, [r3, #0x4c]
10001434: 2b00         	cmp	r3, #0x0
10001436: d103         	bne	0x10001440 <runtime_init_usb_power_down+0x10> @ imm = #0x6
;     *(io_rw_32 *) hw_set_alias_untyped((volatile void *) addr) = mask;
10001438: 2280         	movs	r2, #0x80
1000143a: 4b03         	ldr	r3, [pc, #0xc]          @ 0x10001448 <runtime_init_usb_power_down+0x18>
1000143c: 02d2         	lsls	r2, r2, #0xb
1000143e: 601a         	str	r2, [r3]
; }
10001440: 4770         	bx	lr
10001442: 46c0         	mov	r8, r8
10001444: 00 00 11 50  	.word	0x50110000
10001448: 4c 20 11 50  	.word	0x5011204c

1000144c <runtime_init_post_clock_resets>:
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
1000144c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x10001460 <runtime_init_post_clock_resets+0x14>
1000144e: 4b05         	ldr	r3, [pc, #0x14]         @ 0x10001464 <runtime_init_post_clock_resets+0x18>
10001450: 601a         	str	r2, [r3]
;     while (~*reset_done & mask)
10001452: 4a05         	ldr	r2, [pc, #0x14]         @ 0x10001468 <runtime_init_post_clock_resets+0x1c>
10001454: 6813         	ldr	r3, [r2]
10001456: 01db         	lsls	r3, r3, #0x7
10001458: 3380         	adds	r3, #0x80
1000145a: d1fb         	bne	0x10001454 <runtime_init_post_clock_resets+0x8> @ imm = #-0xa
; }
1000145c: 4770         	bx	lr
1000145e: 46c0         	mov	r8, r8
10001460: ff ff ff 01  	.word	0x01ffffff
10001464: 00 f0 00 40  	.word	0x4000f000
10001468: 08 c0 00 40  	.word	0x4000c008

1000146c <runtime_init_rp2040_gpio_ie_disable>:
;             pads_bank0_hw_clear->io[28] = pads_bank0_hw_clear->io[29] = PADS_BANK0_GPIO0_IE_BITS;
1000146c: 2240         	movs	r2, #0x40
1000146e: 4b03         	ldr	r3, [pc, #0xc]          @ 0x1000147c <runtime_init_rp2040_gpio_ie_disable+0x10>
10001470: 679a         	str	r2, [r3, #0x78]
10001472: 675a         	str	r2, [r3, #0x74]
;     pads_bank0_hw_clear->io[26] = pads_bank0_hw_clear->io[27] =
10001474: 671a         	str	r2, [r3, #0x70]
10001476: 66da         	str	r2, [r3, #0x6c]
; }
10001478: 4770         	bx	lr
1000147a: 46c0         	mov	r8, r8
1000147c: 00 f0 01 40  	.word	0x4001f000

10001480 <runtime_init_spin_locks_reset>:
; void __weak runtime_init_spin_locks_reset(void) {
10001480: b510         	push	{r4, lr}
;     spin_locks_reset();
10001482: f7ff f9bb    	bl	0x100007fc <spin_locks_reset> @ imm = #-0xc8a
; }
10001486: bd10         	pop	{r4, pc}

10001488 <runtime_init_install_ram_vector_table>:
; void runtime_init_install_ram_vector_table(void) {
10001488: b570         	push	{r4, r5, r6, lr}
;     __builtin_memcpy(ram_vector_table, (uint32_t *) scb_hw->vtor, sizeof(ram_vector_table));
1000148a: 4d04         	ldr	r5, [pc, #0x10]         @ 0x1000149c <runtime_init_install_ram_vector_table+0x14>
1000148c: 4c04         	ldr	r4, [pc, #0x10]         @ 0x100014a0 <runtime_init_install_ram_vector_table+0x18>
1000148e: 68a9         	ldr	r1, [r5, #0x8]
10001490: 22c0         	movs	r2, #0xc0
10001492: 0020         	movs	r0, r4
10001494: f000 ff7c    	bl	0x10002390 <__wrap_memcpy> @ imm = #0xef8
;     scb_hw->vtor = (uintptr_t) ram_vector_table;
10001498: 60ac         	str	r4, [r5, #0x8]
; }
1000149a: bd70         	pop	{r4, r5, r6, pc}
1000149c: 00 ed 00 e0  	.word	0xe000ed00
100014a0: 00 00 00 20  	.word	0x20000000

100014a4 <runtime_init_clocks>:
;         clocks_hw->resus.ctrl = 0;
100014a4: 2300         	movs	r3, #0x0
; void __weak runtime_init_clocks(void) {
100014a6: b510         	push	{r4, lr}
;         clocks_hw->resus.ctrl = 0;
100014a8: 4c29         	ldr	r4, [pc, #0xa4]         @ 0x10001550 <runtime_init_clocks+0xac>
; void __weak runtime_init_clocks(void) {
100014aa: b082         	sub	sp, #0x8
;         clocks_hw->resus.ctrl = 0;
100014ac: 67a3         	str	r3, [r4, #0x78]
;         xosc_init();
100014ae: f7ff ff79    	bl	0x100013a4 <xosc_init>  @ imm = #-0x10e
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
100014b2: 2201         	movs	r2, #0x1
100014b4: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x10001554 <runtime_init_clocks+0xb0>
100014b6: 601a         	str	r2, [r3]
;         while (clocks_hw->clk[clk_sys].selected != 0x1)
100014b8: 6c63         	ldr	r3, [r4, #0x44]
100014ba: 2b01         	cmp	r3, #0x1
100014bc: d1fc         	bne	0x100014b8 <runtime_init_clocks+0x14> @ imm = #-0x8
;     *(io_rw_32 *) hw_clear_alias_untyped((volatile void *) addr) = mask;
100014be: 2203         	movs	r2, #0x3
100014c0: 4b25         	ldr	r3, [pc, #0x94]         @ 0x10001558 <runtime_init_clocks+0xb4>
100014c2: 601a         	str	r2, [r3]
;         while (clocks_hw->clk[clk_ref].selected != 0x1)
100014c4: 4a22         	ldr	r2, [pc, #0x88]         @ 0x10001550 <runtime_init_clocks+0xac>
100014c6: 6b93         	ldr	r3, [r2, #0x38]
100014c8: 2b01         	cmp	r3, #0x1
100014ca: d1fc         	bne	0x100014c6 <runtime_init_clocks+0x22> @ imm = #-0x8
;         pll_init(pll_sys, PLL_SYS_REFDIV, PLL_SYS_VCO_FREQ_HZ, PLL_SYS_POSTDIV1, PLL_SYS_POSTDIV2);
100014cc: 3301         	adds	r3, #0x1
100014ce: 9300         	str	r3, [sp]
100014d0: 2101         	movs	r1, #0x1
100014d2: 4a22         	ldr	r2, [pc, #0x88]         @ 0x1000155c <runtime_init_clocks+0xb8>
100014d4: 4822         	ldr	r0, [pc, #0x88]         @ 0x10001560 <runtime_init_clocks+0xbc>
100014d6: 3304         	adds	r3, #0x4
100014d8: f7ff fed8    	bl	0x1000128c <pll_init>   @ imm = #-0x250
;         pll_init(pll_usb, PLL_USB_REFDIV, PLL_USB_VCO_FREQ_HZ, PLL_USB_POSTDIV1, PLL_USB_POSTDIV2);
100014dc: 2305         	movs	r3, #0x5
100014de: 2101         	movs	r1, #0x1
100014e0: 9300         	str	r3, [sp]
100014e2: 4a20         	ldr	r2, [pc, #0x80]         @ 0x10001564 <runtime_init_clocks+0xc0>
100014e4: 4820         	ldr	r0, [pc, #0x80]         @ 0x10001568 <runtime_init_clocks+0xc4>
100014e6: f7ff fed1    	bl	0x1000128c <pll_init>   @ imm = #-0x25e
;         clock_configure_undivided(clk_ref,
100014ea: 2200         	movs	r2, #0x0
100014ec: 2102         	movs	r1, #0x2
100014ee: 2004         	movs	r0, #0x4
100014f0: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x1000156c <runtime_init_clocks+0xc8>
100014f2: f7ff fe51    	bl	0x10001198 <clock_configure_undivided> @ imm = #-0x35e
;         clock_configure_undivided(clk_sys,
100014f6: 2200         	movs	r2, #0x0
100014f8: 2101         	movs	r1, #0x1
100014fa: 2005         	movs	r0, #0x5
100014fc: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x10001570 <runtime_init_clocks+0xcc>
100014fe: f7ff fe4b    	bl	0x10001198 <clock_configure_undivided> @ imm = #-0x36a
;         clock_configure_undivided(clk_usb,
10001502: 2200         	movs	r2, #0x0
10001504: 2100         	movs	r1, #0x0
10001506: 2007         	movs	r0, #0x7
10001508: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x10001574 <runtime_init_clocks+0xd0>
1000150a: f7ff fe45    	bl	0x10001198 <clock_configure_undivided> @ imm = #-0x376
;         clock_configure_undivided(clk_adc,
1000150e: 2200         	movs	r2, #0x0
10001510: 2100         	movs	r1, #0x0
10001512: 2008         	movs	r0, #0x8
10001514: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x10001574 <runtime_init_clocks+0xd0>
10001516: f7ff fe3f    	bl	0x10001198 <clock_configure_undivided> @ imm = #-0x382
;         clock_configure_int_divider(clk_rtc,
1000151a: 2380         	movs	r3, #0x80
1000151c: 00db         	lsls	r3, r3, #0x3
1000151e: 9300         	str	r3, [sp]
10001520: 2200         	movs	r2, #0x0
10001522: 2100         	movs	r1, #0x0
10001524: 2009         	movs	r0, #0x9
10001526: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x10001574 <runtime_init_clocks+0xd0>
10001528: f7ff fdbc    	bl	0x100010a4 <clock_configure_int_divider> @ imm = #-0x488
;         clock_configure_undivided(clk_peri,
1000152c: 2200         	movs	r2, #0x0
1000152e: 4b10         	ldr	r3, [pc, #0x40]         @ 0x10001570 <runtime_init_clocks+0xcc>
10001530: 2100         	movs	r1, #0x0
10001532: 2006         	movs	r0, #0x6
10001534: f7ff fe30    	bl	0x10001198 <clock_configure_undivided> @ imm = #-0x3a0
;     uint32_t cycles = clock_get_hz(clk_ref) / MHZ;
10001538: 2004         	movs	r0, #0x4
1000153a: f7ff fea1    	bl	0x10001280 <clock_get_hz> @ imm = #-0x2be
1000153e: 490e         	ldr	r1, [pc, #0x38]         @ 0x10001578 <runtime_init_clocks+0xd4>
10001540: f000 f84c    	bl	0x100015dc <divmod_u32u32> @ imm = #0x98
10001544: 0001         	movs	r1, r0
;         tick_start((tick_gen_num_t)i, cycles);
10001546: 2000         	movs	r0, #0x0
10001548: f7ff fef2    	bl	0x10001330 <tick_start> @ imm = #-0x21c
; }
1000154c: b002         	add	sp, #0x8
1000154e: bd10         	pop	{r4, pc}
10001550: 00 80 00 40  	.word	0x40008000
10001554: 3c b0 00 40  	.word	0x4000b03c
10001558: 30 b0 00 40  	.word	0x4000b030
1000155c: 00 2f 68 59  	.word	0x59682f00
10001560: 00 80 02 40  	.word	0x40028000
10001564: 00 8c 86 47  	.word	0x47868c00
10001568: 00 c0 02 40  	.word	0x4002c000
1000156c: 00 1b b7 00  	.word	0x00b71b00
10001570: 40 59 73 07  	.word	0x07735940
10001574: 00 6c dc 02  	.word	0x02dc6c00
10001578: 40 42 0f 00  	.word	0x000f4240

1000157c <__aeabi_bits_init>:
;     ldr r0, =aeabi_bits_funcs
1000157c: 4801         	ldr	r0, [pc, #0x4]          @ 0x10001584 <__aeabi_bits_init+0x8>
;     movs r1, #BITS_FUNC_COUNT
1000157e: 2104         	movs	r1, #0x4
;     ldr r3, =rom_funcs_lookup
10001580: 4b01         	ldr	r3, [pc, #0x4]          @ 0x10001588 <__aeabi_bits_init+0xc>
;     bx r3
10001582: 4718         	bx	r3
10001584: c0 01 00 20  	.word	0x200001c0
10001588: 61 13 00 10  	.word	0x10001361

1000158c <divmod_s32s32>:
;     ldr r2, =SIO_BASE
1000158c: 4a12         	ldr	r2, [pc, #0x48]         @ 0x100015d8 <divmod_s32s32_savestate+0x18>
;     ldr r3, [r2, #SIO_DIV_CSR_OFFSET]
1000158e: 6f93         	ldr	r3, [r2, #0x78]
;     lsrs r3, #SIO_DIV_CSR_DIRTY_SHIFT_FOR_CARRY
10001590: 089b         	lsrs	r3, r3, #0x2
;     bcs divmod_s32s32_savestate
10001592: d215         	bhs	0x100015c0 <divmod_s32s32_savestate> @ imm = #0x2a

10001594 <divmod_s32s32_unsafe>:
;     str r0, [r2, #SIO_DIV_SDIVIDEND_OFFSET]
10001594: 6690         	str	r0, [r2, #0x68]
;     str r1, [r2, #SIO_DIV_SDIVISOR_OFFSET]
10001596: 66d1         	str	r1, [r2, #0x6c]
;     cmp r1, #0
10001598: 2900         	cmp	r1, #0x0
;     beq 1f
1000159a: d005         	beq	0x100015a8 <divmod_s32s32_unsafe+0x14> @ imm = #0xa
;     wait_div 2
1000159c: e7ff         	b	0x1000159e <divmod_s32s32_unsafe+0xa> @ imm = #-0x2
1000159e: e7ff         	b	0x100015a0 <divmod_s32s32_unsafe+0xc> @ imm = #-0x2
100015a0: e7ff         	b	0x100015a2 <divmod_s32s32_unsafe+0xe> @ imm = #-0x2
;     ldr r1, [r2, #SIO_DIV_REMAINDER_OFFSET]
100015a2: 6f51         	ldr	r1, [r2, #0x74]
;     ldr r0, [r2, #SIO_DIV_QUOTIENT_OFFSET]
100015a4: 6f10         	ldr	r0, [r2, #0x70]
;     bx lr
100015a6: 4770         	bx	lr
;     push {r2, lr}
100015a8: b504         	push	{r2, lr}
;     movs r1, #0x80
100015aa: 2180         	movs	r1, #0x80
;     lsls r1, #24
100015ac: 0609         	lsls	r1, r1, #0x18
;     asrs r2, r0, #31
100015ae: 17c2         	asrs	r2, r0, #0x1f
;     eors r1, r2
100015b0: 4051         	eors	r1, r2
;     cmp r0, #0
100015b2: 2800         	cmp	r0, #0x0
;     beq 1f
100015b4: d000         	beq	0x100015b8 <divmod_s32s32_unsafe+0x24> @ imm = #0x0
;     mvns r0, r1
100015b6: 43c8         	mvns	r0, r1
;     bl __aeabi_idiv0
100015b8: f002 fdb2    	bl	0x10004120 <____aeabi_idiv0_veneer> @ imm = #0x2b64
;     movs r1, #0 // remainder 0
100015bc: 2100         	movs	r1, #0x0
;     pop {r2, pc}
100015be: bd04         	pop	{r2, pc}

100015c0 <divmod_s32s32_savestate>:
;     save_div_state_and_lr
100015c0: b5f0         	push	{r4, r5, r6, r7, lr}
100015c2: 6e14         	ldr	r4, [r2, #0x60]
100015c4: 6e55         	ldr	r5, [r2, #0x64]
100015c6: 6f57         	ldr	r7, [r2, #0x74]
100015c8: 6f16         	ldr	r6, [r2, #0x70]
;     bl divmod_s32s32_unsafe
100015ca: f7ff ffe3    	bl	0x10001594 <divmod_s32s32_unsafe> @ imm = #-0x3a
;     restore_div_state_and_return
100015ce: 6614         	str	r4, [r2, #0x60]
100015d0: 6655         	str	r5, [r2, #0x64]
100015d2: 6757         	str	r7, [r2, #0x74]
100015d4: 6716         	str	r6, [r2, #0x70]
100015d6: bdf0         	pop	{r4, r5, r6, r7, pc}
100015d8: 00 00 00 d0  	.word	0xd0000000

100015dc <divmod_u32u32>:
;     ldr r2, =SIO_BASE
100015dc: 4a11         	ldr	r2, [pc, #0x44]         @ 0x10001624 <divmod_u32u32_savestate+0x18>
;     ldr r3, [r2, #SIO_DIV_CSR_OFFSET]
100015de: 6f93         	ldr	r3, [r2, #0x78]
;     lsrs r3, #SIO_DIV_CSR_DIRTY_SHIFT_FOR_CARRY
100015e0: 089b         	lsrs	r3, r3, #0x2
;     bcs divmod_u32u32_savestate
100015e2: d213         	bhs	0x1000160c <divmod_u32u32_savestate> @ imm = #0x26

100015e4 <divmod_u32u32_unsafe>:
;     str r0, [r2, #SIO_DIV_UDIVIDEND_OFFSET]
100015e4: 6610         	str	r0, [r2, #0x60]
;     str r1, [r2, #SIO_DIV_UDIVISOR_OFFSET]
100015e6: 6651         	str	r1, [r2, #0x64]
;     cmp r1, #0
100015e8: 2900         	cmp	r1, #0x0
;     beq 1f
100015ea: d005         	beq	0x100015f8 <divmod_u32u32_unsafe+0x14> @ imm = #0xa
;     wait_div 2
100015ec: e7ff         	b	0x100015ee <divmod_u32u32_unsafe+0xa> @ imm = #-0x2
100015ee: e7ff         	b	0x100015f0 <divmod_u32u32_unsafe+0xc> @ imm = #-0x2
100015f0: e7ff         	b	0x100015f2 <divmod_u32u32_unsafe+0xe> @ imm = #-0x2
;     ldr r1, [r2, #SIO_DIV_REMAINDER_OFFSET]
100015f2: 6f51         	ldr	r1, [r2, #0x74]
;     ldr r0, [r2, #SIO_DIV_QUOTIENT_OFFSET]
100015f4: 6f10         	ldr	r0, [r2, #0x70]
;     bx lr
100015f6: 4770         	bx	lr
;     push {r2, lr}
100015f8: b504         	push	{r2, lr}
;     cmp r0, #0
100015fa: 2800         	cmp	r0, #0x0
;     beq 1f
100015fc: d001         	beq	0x10001602 <divmod_u32u32_unsafe+0x1e> @ imm = #0x2
;     movs r0, #0
100015fe: 2000         	movs	r0, #0x0
;     mvns r0, r0
10001600: 43c0         	mvns	r0, r0
;     bl __aeabi_idiv0
10001602: f002 fd8d    	bl	0x10004120 <____aeabi_idiv0_veneer> @ imm = #0x2b1a
;     movs r1, #0 // remainder 0
10001606: 2100         	movs	r1, #0x0
;     pop {r2, pc}
10001608: bd04         	pop	{r2, pc}
1000160a: 46c0         	mov	r8, r8

1000160c <divmod_u32u32_savestate>:
;     save_div_state_and_lr
1000160c: b5f0         	push	{r4, r5, r6, r7, lr}
1000160e: 6e14         	ldr	r4, [r2, #0x60]
10001610: 6e55         	ldr	r5, [r2, #0x64]
10001612: 6f57         	ldr	r7, [r2, #0x74]
10001614: 6f16         	ldr	r6, [r2, #0x70]
;     bl divmod_u32u32_unsafe
10001616: f7ff ffe5    	bl	0x100015e4 <divmod_u32u32_unsafe> @ imm = #-0x36
;     restore_div_state_and_return
1000161a: 6614         	str	r4, [r2, #0x60]
1000161c: 6655         	str	r5, [r2, #0x64]
1000161e: 6757         	str	r7, [r2, #0x74]
10001620: 6716         	str	r6, [r2, #0x70]
10001622: bdf0         	pop	{r4, r5, r6, r7, pc}
10001624: 00 00 00 d0  	.word	0xd0000000

10001628 <divmod_s64s64>:
;     mov ip, r2
10001628: 4694         	mov	r12, r2
;     ldr r2, =SIO_BASE
1000162a: 4a4a         	ldr	r2, [pc, #0x128]        @ 0x10001754 <udiv0+0x1a>
;     ldr r2, [r2, #SIO_DIV_CSR_OFFSET]
1000162c: 6f92         	ldr	r2, [r2, #0x78]
;     lsrs r2, #SIO_DIV_CSR_DIRTY_SHIFT_FOR_CARRY
1000162e: 0892         	lsrs	r2, r2, #0x2
;     mov r2, ip
10001630: 4662         	mov	r2, r12
;     bcs divmod_s64s64_savestate
10001632: d201         	bhs	0x10001638 <divmod_s64s64_savestate> @ imm = #0x2
;     b divmod_s64s64_unsafe
10001634: e028         	b	0x10001688 <divmod_s64s64_unsafe> @ imm = #0x50
10001636: 46c0         	mov	r8, r8

10001638 <divmod_s64s64_savestate>:
;     save_div_state_and_lr_64
10001638: b5f0         	push	{r4, r5, r6, r7, lr}
1000163a: 4e46         	ldr	r6, [pc, #0x118]        @ 0x10001754 <udiv0+0x1a>
1000163c: 6e34         	ldr	r4, [r6, #0x60]
1000163e: 6e75         	ldr	r5, [r6, #0x64]
10001640: 6f77         	ldr	r7, [r6, #0x74]
10001642: 6f36         	ldr	r6, [r6, #0x70]
;     bl divmod_s64s64_unsafe
10001644: f000 f820    	bl	0x10001688 <divmod_s64s64_unsafe> @ imm = #0x40
;     restore_div_state_and_return_64
10001648: 4694         	mov	r12, r2
1000164a: 4a42         	ldr	r2, [pc, #0x108]        @ 0x10001754 <udiv0+0x1a>
1000164c: 6614         	str	r4, [r2, #0x60]
1000164e: 6655         	str	r5, [r2, #0x64]
10001650: 6757         	str	r7, [r2, #0x74]
10001652: 6716         	str	r6, [r2, #0x70]
10001654: 4662         	mov	r2, r12
10001656: bdf0         	pop	{r4, r5, r6, r7, pc}

10001658 <divmod_u64u64>:
;     mov ip, r2
10001658: 4694         	mov	r12, r2
;     ldr r2, =SIO_BASE
1000165a: 4a3e         	ldr	r2, [pc, #0xf8]         @ 0x10001754 <udiv0+0x1a>
;     ldr r2, [r2, #SIO_DIV_CSR_OFFSET]
1000165c: 6f92         	ldr	r2, [r2, #0x78]
;     lsrs r2, #SIO_DIV_CSR_DIRTY_SHIFT_FOR_CARRY
1000165e: 0892         	lsrs	r2, r2, #0x2
;     mov r2, ip
10001660: 4662         	mov	r2, r12
;     bcs divmod_u64u64_savestate
10001662: d201         	bhs	0x10001668 <divmod_u64u64_savestate> @ imm = #0x2
;     b divmod_u64u64_unsafe
10001664: e054         	b	0x10001710 <divmod_u64u64_unsafe> @ imm = #0xa8
10001666: 46c0         	mov	r8, r8

10001668 <divmod_u64u64_savestate>:
;     save_div_state_and_lr_64
10001668: b5f0         	push	{r4, r5, r6, r7, lr}
1000166a: 4e3a         	ldr	r6, [pc, #0xe8]         @ 0x10001754 <udiv0+0x1a>
1000166c: 6e34         	ldr	r4, [r6, #0x60]
1000166e: 6e75         	ldr	r5, [r6, #0x64]
10001670: 6f77         	ldr	r7, [r6, #0x74]
10001672: 6f36         	ldr	r6, [r6, #0x70]
;     bl divmod_u64u64_unsafe
10001674: f000 f84c    	bl	0x10001710 <divmod_u64u64_unsafe> @ imm = #0x98
;     restore_div_state_and_return_64
10001678: 4694         	mov	r12, r2
1000167a: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x10001754 <udiv0+0x1a>
1000167c: 6614         	str	r4, [r2, #0x60]
1000167e: 6655         	str	r5, [r2, #0x64]
10001680: 6757         	str	r7, [r2, #0x74]
10001682: 6716         	str	r6, [r2, #0x70]
10001684: 4662         	mov	r2, r12
10001686: bdf0         	pop	{r4, r5, r6, r7, pc}

10001688 <divmod_s64s64_unsafe>:
;  cmp r3,#0
10001688: 2b00         	cmp	r3, #0x0
;  blt 1f
1000168a: db24         	blt	0x100016d6 <l42_1+0x26> @ imm = #0x48
;  beq 2f                    @ could x be zero?
1000168c: d011         	beq	0x100016b2 <l42_1+0x2>  @ imm = #0x22
;  cmp r1,#0
1000168e: 2900         	cmp	r1, #0x0
;  bge divmod_u64u64_unsafe  @ both positive
10001690: da3e         	bge	0x10001710 <divmod_u64u64_unsafe> @ imm = #0x7c
;  push {r14}
10001692: b500         	push	{lr}
;  dneg r0,r1
10001694: 43c9         	mvns	r1, r1
10001696: 4240         	rsbs	r0, r0, #0
10001698: d100         	bne	0x1000169c <l40_1>      @ imm = #0x0
1000169a: 3101         	adds	r1, #0x1

1000169c <l40_1>:
;  bl divmod_u64u64_unsafe
1000169c: f000 f838    	bl	0x10001710 <divmod_u64u64_unsafe> @ imm = #0x70
;  dneg r0,r1
100016a0: 43c9         	mvns	r1, r1
100016a2: 4240         	rsbs	r0, r0, #0
100016a4: d100         	bne	0x100016a8 <l41_1>      @ imm = #0x0
100016a6: 3101         	adds	r1, #0x1

100016a8 <l41_1>:
;  dneg r2,r3
100016a8: 43db         	mvns	r3, r3
100016aa: 4252         	rsbs	r2, r2, #0
100016ac: d100         	bne	0x100016b0 <l42_1>      @ imm = #0x0
100016ae: 3301         	adds	r3, #0x1

100016b0 <l42_1>:
;  pop {r15}
100016b0: bd00         	pop	{pc}
;  cmp r2,#0
100016b2: 2a00         	cmp	r2, #0x0
;  bne 3b                    @ back if x not zero
100016b4: d1eb         	bne	0x1000168e <divmod_s64s64_unsafe+0x6> @ imm = #-0x2a
;  cmp r0,#0                 @ y==0?
100016b6: 2800         	cmp	r0, #0x0
;  bne 4f
100016b8: d101         	bne	0x100016be <l42_1+0xe>  @ imm = #0x2
;  cmp r1,#0
100016ba: 2900         	cmp	r1, #0x0
;  beq 5f                    @ then pass 0 to __aeabi_ldiv0
100016bc: d005         	beq	0x100016ca <l42_1+0x1a> @ imm = #0xa
;  movs r0,#0
100016be: 2000         	movs	r0, #0x0
;  lsrs r1,#31
100016c0: 0fc9         	lsrs	r1, r1, #0x1f
;  lsls r1,#31               @ get sign bit
100016c2: 07c9         	lsls	r1, r1, #0x1f
;  bne 5f                    @ y -ve? pass -2^63 to __aeabi_ldiv0
100016c4: d101         	bne	0x100016ca <l42_1+0x1a> @ imm = #0x2
;  mvns r0,r0
100016c6: 43c0         	mvns	r0, r0
;  lsrs r1,r0,#1             @ y +ve: pass 2^63-1 to __aeabi_ldiv0
100016c8: 0841         	lsrs	r1, r0, #0x1
;  push {r14}
100016ca: b500         	push	{lr}
;  bl __aeabi_ldiv0
100016cc: f002 fd20    	bl	0x10004110 <____aeabi_ldiv0_veneer> @ imm = #0x2a40
;  movs r2,#0                @ and return 0 for the remainder
100016d0: 2200         	movs	r2, #0x0
;  movs r3,#0
100016d2: 2300         	movs	r3, #0x0
;  pop {r15}
100016d4: bd00         	pop	{pc}
;  push {r14}
100016d6: b500         	push	{lr}
;  cmp r1,#0
100016d8: 2900         	cmp	r1, #0x0
;  blt 1f
100016da: db0a         	blt	0x100016f2 <l44_1+0x2>  @ imm = #0x14
;  dneg r2,r3
100016dc: 43db         	mvns	r3, r3
100016de: 4252         	rsbs	r2, r2, #0
100016e0: d100         	bne	0x100016e4 <l43_1>      @ imm = #0x0
100016e2: 3301         	adds	r3, #0x1

100016e4 <l43_1>:
;  bl divmod_u64u64_unsafe
100016e4: f000 f814    	bl	0x10001710 <divmod_u64u64_unsafe> @ imm = #0x28
;  dneg r0,r1
100016e8: 43c9         	mvns	r1, r1
100016ea: 4240         	rsbs	r0, r0, #0
100016ec: d100         	bne	0x100016f0 <l44_1>      @ imm = #0x0
100016ee: 3101         	adds	r1, #0x1

100016f0 <l44_1>:
;  pop {r15}
100016f0: bd00         	pop	{pc}
;  dneg r0,r1
100016f2: 43c9         	mvns	r1, r1
100016f4: 4240         	rsbs	r0, r0, #0
100016f6: d100         	bne	0x100016fa <l45_1>      @ imm = #0x0
100016f8: 3101         	adds	r1, #0x1

100016fa <l45_1>:
;  dneg r2,r3
100016fa: 43db         	mvns	r3, r3
100016fc: 4252         	rsbs	r2, r2, #0
100016fe: d100         	bne	0x10001702 <l46_1>      @ imm = #0x0
10001700: 3301         	adds	r3, #0x1

10001702 <l46_1>:
;  bl divmod_u64u64_unsafe
10001702: f000 f805    	bl	0x10001710 <divmod_u64u64_unsafe> @ imm = #0xa
;  dneg r2,r3
10001706: 43db         	mvns	r3, r3
10001708: 4252         	rsbs	r2, r2, #0
1000170a: d100         	bne	0x1000170e <l47_1>      @ imm = #0x0
1000170c: 3301         	adds	r3, #0x1

1000170e <l47_1>:
;  pop {r15}
1000170e: bd00         	pop	{pc}

10001710 <divmod_u64u64_unsafe>:
;  cmp r1,#0
10001710: 2900         	cmp	r1, #0x0
;  bne y64                   @ y fits in 32 bits?
10001712: d123         	bne	0x1000175c <y64>        @ imm = #0x46
;  cmp r3,#0                 @ yes; and x?
10001714: 2b00         	cmp	r3, #0x0
;  bne 1f
10001716: d118         	bne	0x1000174a <udiv0+0x10> @ imm = #0x30
;  cmp r2,#0
10001718: 2a00         	cmp	r2, #0x0
;  beq 2f                    @ x==0?
1000171a: d00c         	beq	0x10001736 <divmod_u64u64_unsafe+0x26> @ imm = #0x18
;  mov r12,r7
1000171c: 46bc         	mov	r12, r7
;  ldr r7,=SIO_BASE
1000171e: 4f0d         	ldr	r7, [pc, #0x34]         @ 0x10001754 <udiv0+0x1a>
;  str r0,[r7,#SIO_DIV_UDIVIDEND_OFFSET]
10001720: 6638         	str	r0, [r7, #0x60]
;  str r2,[r7,#SIO_DIV_UDIVISOR_OFFSET]
10001722: 667a         	str	r2, [r7, #0x64]
;  movs r1,#0
10001724: 2100         	movs	r1, #0x0
;  movs r3,#0
10001726: 2300         	movs	r3, #0x0
;  wait_div 2
10001728: e7ff         	b	0x1000172a <divmod_u64u64_unsafe+0x1a> @ imm = #-0x2
1000172a: e7ff         	b	0x1000172c <divmod_u64u64_unsafe+0x1c> @ imm = #-0x2
1000172c: e7ff         	b	0x1000172e <divmod_u64u64_unsafe+0x1e> @ imm = #-0x2
;  ldr r2,[r7,#SIO_DIV_REMAINDER_OFFSET]
1000172e: 6f7a         	ldr	r2, [r7, #0x74]
;  ldr r0,[r7,#SIO_DIV_QUOTIENT_OFFSET]
10001730: 6f38         	ldr	r0, [r7, #0x70]
;  mov r7,r12
10001732: 4667         	mov	r7, r12
;  bx r14
10001734: 4770         	bx	lr
;  cmp r0,#0                 @ y==0?
10001736: 2800         	cmp	r0, #0x0
;  beq 3f                    @ then pass 0 to __aeabi_ldiv0
10001738: d001         	beq	0x1000173e <udiv0+0x4>  @ imm = #0x2

1000173a <udiv0>:
;  ldr r0,=0xffffffff
1000173a: 4807         	ldr	r0, [pc, #0x1c]         @ 0x10001758 <udiv0+0x1e>
;  movs r1,r0                @ pass 2^64-1 to __aeabi_ldiv0
1000173c: 0001         	movs	r1, r0
;  push {r14}
1000173e: b500         	push	{lr}
;  bl __aeabi_ldiv0
10001740: f002 fce6    	bl	0x10004110 <____aeabi_ldiv0_veneer> @ imm = #0x29cc
;  movs r2,#0                @ and return 0 for the remainder
10001744: 2200         	movs	r2, #0x0
;  movs r3,#0
10001746: 2300         	movs	r3, #0x0
;  pop {r15}
10001748: bd00         	pop	{pc}
;  movs r2,r0                @ x>y, so result is 0 remainder y
1000174a: 0002         	movs	r2, r0
;  movs r3,r1
1000174c: 000b         	movs	r3, r1
;  movs r0,#0
1000174e: 2000         	movs	r0, #0x0
;  movs r1,#0
10001750: 2100         	movs	r1, #0x0
;  bx r14
10001752: 4770         	bx	lr
10001754: 00 00 00 d0  	.word	0xd0000000
10001758: ff ff ff ff  	.word	0xffffffff

1000175c <y64>:
;  cmp r3,#0
1000175c: 2b00         	cmp	r3, #0x0
;  beq 1f
1000175e: d000         	beq	0x10001762 <y64+0x6>    @ imm = #0x0
;  b y64_x48                 @ if x does not fit in 32 bits, go to 48- and 64-bit cases
10001760: e0bf         	b	0x100018e2 <y64_x48>    @ imm = #0x17e
;  lsrs r3,r2,#16
10001762: 0c13         	lsrs	r3, r2, #0x10
;  bne y64_x32               @ jump if x is 17..32 bits
10001764: d128         	bne	0x100017b8 <y64_x32>    @ imm = #0x50
;  cmp r2,#0
10001766: 2a00         	cmp	r2, #0x0
;  beq udiv0                 @ x==0? exit as with y!=0 case above
10001768: d0e7         	beq	0x1000173a <udiv0>      @ imm = #-0x32
;  push {r7}
1000176a: b480         	push	{r7}
;  ldr r7,=SIO_BASE
1000176c: 4f11         	ldr	r7, [pc, #0x44]         @ 0x100017b4 <y64+0x58>
;  str r1,[r7,#SIO_DIV_UDIVIDEND_OFFSET]
1000176e: 6639         	str	r1, [r7, #0x60]
;  str r2,[r7,#SIO_DIV_UDIVISOR_OFFSET]
10001770: 667a         	str	r2, [r7, #0x64]
;  wait_div 4
10001772: e7ff         	b	0x10001774 <y64+0x18>   @ imm = #-0x2
10001774: e7ff         	b	0x10001776 <y64+0x1a>   @ imm = #-0x2
;  push {r4, r5}
10001776: b430         	push	{r4, r5}
;  lsrs r4,r0,#16
10001778: 0c04         	lsrs	r4, r0, #0x10
;  ldr r3,[r7,#SIO_DIV_REMAINDER_OFFSET] @ r0=y0-q0*x; 0<=r0<x
1000177a: 6f7b         	ldr	r3, [r7, #0x74]
;  ldr r1,[r7,#SIO_DIV_QUOTIENT_OFFSET]  @ q0=y0/x;
1000177c: 6f39         	ldr	r1, [r7, #0x70]
;  lsls r3,#16
1000177e: 041b         	lsls	r3, r3, #0x10
;  orrs r3,r4
10001780: 4323         	orrs	r3, r4
;  str r3,[r7,#SIO_DIV_UDIVIDEND_OFFSET] @ y1=(r0<<16)+(((ui32)y)>>16);
10001782: 663b         	str	r3, [r7, #0x60]
;  str r2,[r7,#SIO_DIV_UDIVISOR_OFFSET]  @ must set divisor again, as we do not save/restore regs at all in IRQs if not dirty
10001784: 667a         	str	r2, [r7, #0x64]
;  wait_div 1
10001786: e7ff         	b	0x10001788 <y64+0x2c>   @ imm = #-0x2
10001788: e7ff         	b	0x1000178a <y64+0x2e>   @ imm = #-0x2
1000178a: e7ff         	b	0x1000178c <y64+0x30>   @ imm = #-0x2
1000178c: 46c0         	mov	r8, r8
;  uxth r4,r0
1000178e: b284         	uxth	r4, r0
;  ldr r3,[r7,#SIO_DIV_REMAINDER_OFFSET] @ r1=y1-q1*x; 0<=r1<x
10001790: 6f7b         	ldr	r3, [r7, #0x74]
;  ldr r5,[r7,#SIO_DIV_QUOTIENT_OFFSET]  @ q1=y1/x;
10001792: 6f3d         	ldr	r5, [r7, #0x70]
;  lsls r3,#16
10001794: 041b         	lsls	r3, r3, #0x10
;  orrs r3,r4
10001796: 4323         	orrs	r3, r4
;  str r3,[r7,#SIO_DIV_UDIVIDEND_OFFSET] @ y1=(r0<<16)+(((ui32)y)>>16);
10001798: 663b         	str	r3, [r7, #0x60]
;  str r2,[r7,#SIO_DIV_UDIVISOR_OFFSET]  @ must set divisor again, as we do not save/restore regs at all in IRQs if not dirty
1000179a: 667a         	str	r2, [r7, #0x64]
;  wait_div 3
1000179c: e7ff         	b	0x1000179e <y64+0x42>   @ imm = #-0x2
1000179e: e7ff         	b	0x100017a0 <y64+0x44>   @ imm = #-0x2
100017a0: 46c0         	mov	r8, r8
;  movs r3,#0
100017a2: 2300         	movs	r3, #0x0
;  lsls r4,r5,#16             @ quotient=(q0<<32)+(q1<<16)+q2
100017a4: 042c         	lsls	r4, r5, #0x10
;  lsrs r5,#16
100017a6: 0c2d         	lsrs	r5, r5, #0x10
;  ldr r2,[r7,#SIO_DIV_REMAINDER_OFFSET] @ r2=y2-q2*x; 0<=r2<x
100017a8: 6f7a         	ldr	r2, [r7, #0x74]
;  ldr r0,[r7,#SIO_DIV_QUOTIENT_OFFSET]  @ q2=y2/x;
100017aa: 6f38         	ldr	r0, [r7, #0x70]
;  adds r0,r4
100017ac: 1900         	adds	r0, r0, r4
;  adcs r1,r5
100017ae: 4169         	adcs	r1, r5
;  pop {r4,r5,r7}
100017b0: bcb0         	pop	{r4, r5, r7}
;  bx r14
100017b2: 4770         	bx	lr
100017b4: 00 00 00 d0  	.word	0xd0000000

100017b8 <y64_x32>:
;  push {r4-r7,r14}
100017b8: b5f0         	push	{r4, r5, r6, r7, lr}
;  mov r12,r2                @ save x
100017ba: 4694         	mov	r12, r2
;  movs r5,#0                @ xsh=0
100017bc: 2500         	movs	r5, #0x0
;  lsrs r4,r2,#24
100017be: 0e14         	lsrs	r4, r2, #0x18
;  bne 1f
100017c0: d101         	bne	0x100017c6 <y64_x32+0xe> @ imm = #0x2
;  lsls r2,#8                @ if(x0<1U<<24) x0<<=8,xsh =8;
100017c2: 0212         	lsls	r2, r2, #0x8
;  adds r5,#8
100017c4: 3508         	adds	r5, #0x8
;  lsrs r4,r2,#28
100017c6: 0f14         	lsrs	r4, r2, #0x1c
;  bne 1f
100017c8: d101         	bne	0x100017ce <y64_x32+0x16> @ imm = #0x2
;  lsls r2,#4                @ if(x0<1U<<28) x0<<=4,xsh+=4;
100017ca: 0112         	lsls	r2, r2, #0x4
;  adds r5,#4
100017cc: 3504         	adds	r5, #0x4
;  lsrs r4,r2,#30
100017ce: 0f94         	lsrs	r4, r2, #0x1e
;  bne 1f
100017d0: d101         	bne	0x100017d6 <y64_x32+0x1e> @ imm = #0x2
;  lsls r2,#2                @ if(x0<1U<<30) x0<<=2,xsh+=2;
100017d2: 0092         	lsls	r2, r2, #0x2
;  adds r5,#2
100017d4: 3502         	adds	r5, #0x2
;  lsrs r4,r2,#31
100017d6: 0fd4         	lsrs	r4, r2, #0x1f
;  bne 1f
100017d8: d101         	bne	0x100017de <y64_x32+0x26> @ imm = #0x2
;  lsls r2,#1                @ if(x0<1U<<31) x0<<=1,xsh+=1;
100017da: 0052         	lsls	r2, r2, #0x1
;  adds r5,#1
100017dc: 3501         	adds	r5, #0x1
;  lsrs r4,r2,#15
100017de: 0bd4         	lsrs	r4, r2, #0xf
;  adds r4,#1                @ x1=(x0>>15)+1; 2^16<x1<=2^17
100017e0: 3401         	adds	r4, #0x1
;  ldr r7,=SIO_BASE
100017e2: 4f25         	ldr	r7, [pc, #0x94]         @ 0x10001878 <y64_x32+0xc0>
;  str r4,[r7,#SIO_DIV_UDIVISOR_OFFSET]
100017e4: 667c         	str	r4, [r7, #0x64]
;  ldr r4,=0xffffffff
100017e6: 4c25         	ldr	r4, [pc, #0x94]         @ 0x1000187c <y64_x32+0xc4>
;  str r4,[r7,#SIO_DIV_UDIVIDEND_OFFSET]
100017e8: 663c         	str	r4, [r7, #0x60]
;  lsrs r6,r1,#16
100017ea: 0c0e         	lsrs	r6, r1, #0x10
;  uxth r3,r2                @ x0l
100017ec: b293         	uxth	r3, r2
;  wait_div 2
100017ee: e7ff         	b	0x100017f0 <y64_x32+0x38> @ imm = #-0x2
100017f0: e7ff         	b	0x100017f2 <y64_x32+0x3a> @ imm = #-0x2
100017f2: e7ff         	b	0x100017f4 <y64_x32+0x3c> @ imm = #-0x2
;  ldr r4,[r7,#SIO_DIV_QUOTIENT_OFFSET]  @ r=0xffffffffU/x1; 2^15<=r<2^16 r is a normalised reciprocal of x, guaranteed not an overestimate
100017f4: 6f3c         	ldr	r4, [r7, #0x70]
;  muls r6,r4
100017f6: 4366         	muls	r6, r4, r6
;  lsrs r6,#16               @ q=((ui32)(y>>48)*r)>>16;
100017f8: 0c36         	lsrs	r6, r6, #0x10
;  lsls r7,r6,#13
100017fa: 0377         	lsls	r7, r6, #0xd
;  mov r14,r7                @ quh=q0<<13
100017fc: 46be         	mov	lr, r7
;  muls r3,r6                @ x0l*q
100017fe: 4373         	muls	r3, r6, r3
;  lsrs r7,r3,#15
10001800: 0bdf         	lsrs	r7, r3, #0xf
;  lsls r3,#17               @ r3:r7 is (x0l*q)<<17
10001802: 045b         	lsls	r3, r3, #0x11
;  subs r0,r3
10001804: 1ac0         	subs	r0, r0, r3
;  sbcs r1,r7                @ y-=(x0l*q)<<17
10001806: 41b9         	sbcs	r1, r7
;  lsrs r3,r2,#16            @ x0h
10001808: 0c13         	lsrs	r3, r2, #0x10
;  muls r3,r6                @ q*x0h
1000180a: 4373         	muls	r3, r6, r3
;  adds r3,r3
1000180c: 18db         	adds	r3, r3, r3
;  subs r1,r3                @ y-=(x0h*q)<<17
1000180e: 1ac9         	subs	r1, r1, r3
;  lsrs r6,r1,#3
10001810: 08ce         	lsrs	r6, r1, #0x3
;  muls r6,r4
10001812: 4366         	muls	r6, r4, r6
;  lsrs r6,#16               @ q=((ui32)(y>>35)*r)>>16;
10001814: 0c36         	lsrs	r6, r6, #0x10
;  add r14,r6                @ quh+=q1
10001816: 44b6         	add	lr, r6
;  uxth r3,r2                @ x0l
10001818: b293         	uxth	r3, r2
;  muls r3,r6                @ x0l*q
1000181a: 4373         	muls	r3, r6, r3
;  lsrs r7,r3,#28
1000181c: 0f1f         	lsrs	r7, r3, #0x1c
;  lsls r3,#4                @ r3:r7 is (x0l*q)<<4
1000181e: 011b         	lsls	r3, r3, #0x4
;  subs r0,r3
10001820: 1ac0         	subs	r0, r0, r3
;  sbcs r1,r7                @ y-=(x0l*q)<<4
10001822: 41b9         	sbcs	r1, r7
;  lsrs r3,r2,#16            @ x0h
10001824: 0c13         	lsrs	r3, r2, #0x10
;  muls r3,r6                @ x0h*q
10001826: 4373         	muls	r3, r6, r3
;  lsrs r7,r3,#12
10001828: 0b1f         	lsrs	r7, r3, #0xc
;  lsls r3,#20               @ r3:r7 is (x0h*q)<<4
1000182a: 051b         	lsls	r3, r3, #0x14
;  subs r0,r3
1000182c: 1ac0         	subs	r0, r0, r3
;  sbcs r1,r7                @ y-=(x0h*q)<<4
1000182e: 41b9         	sbcs	r1, r7
;  lsrs r6,r0,#22
10001830: 0d86         	lsrs	r6, r0, #0x16
;  lsls r7,r1,#10
10001832: 028f         	lsls	r7, r1, #0xa
;  orrs r6,r7                @ y>>22
10001834: 433e         	orrs	r6, r7
;  muls r6,r4
10001836: 4366         	muls	r6, r4, r6
;  lsrs r6,#16               @ q=((ui32)(y>>22)*r)>>16;
10001838: 0c36         	lsrs	r6, r6, #0x10
;  cmp r5,#9
1000183a: 2d09         	cmp	r5, #0x9
;  blt last0                 @ if(xsh<9) goto last0;
1000183c: db24         	blt	0x10001888 <last0>      @ imm = #0x48
;  lsrs r2,#9                @ x0>>9: this shift loses no bits
1000183e: 0a52         	lsrs	r2, r2, #0x9
;  muls r2,r6                @ x0*q
10001840: 4372         	muls	r2, r6, r2
;  subs r0,r2                @ y-x0*q
10001842: 1a80         	subs	r0, r0, r2
;  lsls r7,r6,#13            @ qul=q<<13
10001844: 0377         	lsls	r7, r6, #0xd
;  lsrs r6,r0,#9
10001846: 0a46         	lsrs	r6, r0, #0x9
;  muls r6,r4
10001848: 4366         	muls	r6, r4, r6
;  lsrs r6,#16               @ q=((ui32)(y>>9)*r)>>16;
1000184a: 0c36         	lsrs	r6, r6, #0x10
;  movs r3,#22
1000184c: 2316         	movs	r3, #0x16
;  subs r3,r5                @ 22-xsh
1000184e: 1b5b         	subs	r3, r3, r5
;  lsrs r6,r3                @ q>>=22-xsh
10001850: 40de         	lsrs	r6, r3
;  lsrs r7,r3                @ qul>>=22-xsh
10001852: 40df         	lsrs	r7, r3
;  adds r7,r6                @ qul+=q
10001854: 19bf         	adds	r7, r7, r6
;  mov r4,r12
10001856: 4664         	mov	r4, r12
;  muls r6,r4                @ x*q
10001858: 4366         	muls	r6, r4, r6
;  subs r2,r0,r6             @ y-=x*q
1000185a: 1b82         	subs	r2, r0, r6
;  mov r0,r14                @ quh
1000185c: 4670         	mov	r0, lr
;  adds r5,#4                @ xsh+4
1000185e: 3504         	adds	r5, #0x4
;  adds r3,#6                @ 28-xsh
10001860: 3306         	adds	r3, #0x6
;  movs r1,r0
10001862: 0001         	movs	r1, r0
;  lsrs r1,r3
10001864: 40d9         	lsrs	r1, r3
;  lsls r0,r5                @ r0:r1 is quh<<(4+xsh)
10001866: 40a8         	lsls	r0, r5
;  adds r0,r7
10001868: 19c0         	adds	r0, r0, r7
;  bcc 1f
1000186a: d300         	blo	0x1000186e <y64_x32+0xb6> @ imm = #0x0
;  adds r1,#1
1000186c: 3101         	adds	r1, #0x1
;  cmp r2,r4
1000186e: 42a2         	cmp	r2, r4
;  bhs 3f
10001870: d206         	bhs	0x10001880 <y64_x32+0xc8> @ imm = #0xc
;  movs r3,#0
10001872: 2300         	movs	r3, #0x0
;  pop {r4-r7,r15}
10001874: bdf0         	pop	{r4, r5, r6, r7, pc}
10001876: 00 00        	.short	0x0000
10001878: 00 00 00 d0  	.word	0xd0000000
1000187c: ff ff ff ff  	.word	0xffffffff
;  subs r2,r4
10001880: 1b12         	subs	r2, r2, r4
;  adds r0,#1
10001882: 3001         	adds	r0, #0x1
;  bcc 1b
10001884: d3f3         	blo	0x1000186e <y64_x32+0xb6> @ imm = #-0x1a
;  b 2b                      @ while(y>=x) y-=x,qu++;
10001886: e7f1         	b	0x1000186c <y64_x32+0xb4> @ imm = #-0x1e

10001888 <last0>:
;  movs r7,#9
10001888: 2709         	movs	r7, #0x9
;  subs r7,r5                @ 9-xsh
1000188a: 1b7f         	subs	r7, r7, r5
;  lsrs r6,r7
1000188c: 40fe         	lsrs	r6, r7
;  mov r4,r12                @ x
1000188e: 4664         	mov	r4, r12
;  uxth r2,r4
10001890: b2a2         	uxth	r2, r4
;  muls r2,r6                @ q*xlo
10001892: 4372         	muls	r2, r6, r2
;  subs r0,r2
10001894: 1a80         	subs	r0, r0, r2
;  bcs 1f
10001896: d200         	bhs	0x1000189a <last0+0x12> @ imm = #0x0
;  subs r1,#1                @ y-=q*xlo
10001898: 3901         	subs	r1, #0x1
;  lsrs r2,r4,#16            @ xhi
1000189a: 0c22         	lsrs	r2, r4, #0x10
;  muls r2,r6                @ q*xhi
1000189c: 4372         	muls	r2, r6, r2
;  lsrs r3,r2,#16
1000189e: 0c13         	lsrs	r3, r2, #0x10
;  lsls r2,#16
100018a0: 0412         	lsls	r2, r2, #0x10
;  subs r2,r0,r2
100018a2: 1a82         	subs	r2, r0, r2
;  sbcs r1,r3                @ y-q*xhi
100018a4: 4199         	sbcs	r1, r3
;  movs r3,r1                @ y now in r2:r3
100018a6: 000b         	movs	r3, r1
;  mov r0,r14                @ quh
100018a8: 4670         	mov	r0, lr
;  adds r5,#4                @ xsh+4
100018aa: 3504         	adds	r5, #0x4
;  adds r7,#19               @ 28-xsh
100018ac: 3713         	adds	r7, #0x13
;  movs r1,r0
100018ae: 0001         	movs	r1, r0
;  lsrs r1,r7
100018b0: 40f9         	lsrs	r1, r7
;  lsls r0,r5                @ r0:r1 is quh<<(4+xsh)
100018b2: 40a8         	lsls	r0, r5
;  adds r0,r6
100018b4: 1980         	adds	r0, r0, r6
;  bcc 1f
100018b6: d300         	blo	0x100018ba <last0+0x32> @ imm = #0x0
;  adds r1,#1                @ quh<<(xsh+4))+q
100018b8: 3101         	adds	r1, #0x1
;  cmp r3,#0                 @ y>=2^32?
100018ba: 2b00         	cmp	r3, #0x0
;  bne 3f
100018bc: d102         	bne	0x100018c4 <last0+0x3c> @ imm = #0x4
;  cmp r2,r4                 @ y>=x?
100018be: 42a2         	cmp	r2, r4
;  bhs 4f
100018c0: d20a         	bhs	0x100018d8 <last0+0x50> @ imm = #0x14
;  pop {r4-r7,r15}
100018c2: bdf0         	pop	{r4, r5, r6, r7, pc}
;  adds r0,#1                @ qu++
100018c4: 3001         	adds	r0, #0x1
;  bcc 2f
100018c6: d300         	blo	0x100018ca <last0+0x42> @ imm = #0x0
;  adds r1,#1
100018c8: 3101         	adds	r1, #0x1
;  subs r2,r4                @ y-=x
100018ca: 1b12         	subs	r2, r2, r4
;  bcs 3b
100018cc: d2fa         	bhs	0x100018c4 <last0+0x3c> @ imm = #-0xc
;  subs r3,#1
100018ce: 3b01         	subs	r3, #0x1
;  bne 3b
100018d0: d1f8         	bne	0x100018c4 <last0+0x3c> @ imm = #-0x10
;  cmp r2,r4
100018d2: 42a2         	cmp	r2, r4
;  bhs 4f
100018d4: d200         	bhs	0x100018d8 <last0+0x50> @ imm = #0x0
;  pop {r4-r7,r15}
100018d6: bdf0         	pop	{r4, r5, r6, r7, pc}
;  adds r0,#1                @ qu++
100018d8: 3001         	adds	r0, #0x1
;  bcc 2f
100018da: d300         	blo	0x100018de <last0+0x56> @ imm = #0x0
;  adds r1,#1
100018dc: 3101         	adds	r1, #0x1
;  subs r2,r4                @ y-=x
100018de: 1b12         	subs	r2, r2, r4
;  b 1b
100018e0: e7f7         	b	0x100018d2 <last0+0x4a> @ imm = #-0x12

100018e2 <y64_x48>:
;  push {r4-r7,r14}          @ save a copy of x
100018e2: b5f0         	push	{r4, r5, r6, r7, lr}
;  lsrs r4,r3,#16
100018e4: 0c1c         	lsrs	r4, r3, #0x10
;  beq 1f
100018e6: d000         	beq	0x100018ea <y64_x48+0x8> @ imm = #0x0
;  b y64_x64                 @ jump if x is 49..64 bits
100018e8: e080         	b	0x100019ec <y64_x64>    @ imm = #0x100
;  push {r2-r3}              @ save a copy of x
100018ea: b40c         	push	{r2, r3}
;  movs r5,#0                @ xsh=0
100018ec: 2500         	movs	r5, #0x0
;  lsrs r4,r3,#8
100018ee: 0a1c         	lsrs	r4, r3, #0x8
;  bne 1f
100018f0: d104         	bne	0x100018fc <y64_x48+0x1a> @ imm = #0x8
;  lsls r3,#8
100018f2: 021b         	lsls	r3, r3, #0x8
;  lsrs r6,r2,#24
100018f4: 0e16         	lsrs	r6, r2, #0x18
;  orrs r3,r6
100018f6: 4333         	orrs	r3, r6
;  lsls r2,#8                @ if(x0<1U<<40) x0<<=8,xsh =8;
100018f8: 0212         	lsls	r2, r2, #0x8
;  adds r5,#8
100018fa: 3508         	adds	r5, #0x8
;  lsrs r4,r3,#12
100018fc: 0b1c         	lsrs	r4, r3, #0xc
;  bne 1f
100018fe: d104         	bne	0x1000190a <y64_x48+0x28> @ imm = #0x8
;  lsls r3,#4
10001900: 011b         	lsls	r3, r3, #0x4
;  lsrs r6,r2,#28
10001902: 0f16         	lsrs	r6, r2, #0x1c
;  orrs r3,r6
10001904: 4333         	orrs	r3, r6
;  lsls r2,#4                @ if(x0<1U<<44) x0<<=4,xsh+=4;
10001906: 0112         	lsls	r2, r2, #0x4
;  adds r5,#4
10001908: 3504         	adds	r5, #0x4
;  lsrs r4,r3,#14
1000190a: 0b9c         	lsrs	r4, r3, #0xe
;  bne 1f
1000190c: d104         	bne	0x10001918 <y64_x48+0x36> @ imm = #0x8
;  lsls r3,#2
1000190e: 009b         	lsls	r3, r3, #0x2
;  lsrs r6,r2,#30
10001910: 0f96         	lsrs	r6, r2, #0x1e
;  orrs r3,r6
10001912: 4333         	orrs	r3, r6
;  lsls r2,#2                @ if(x0<1U<<46) x0<<=2,xsh+=2;
10001914: 0092         	lsls	r2, r2, #0x2
;  adds r5,#2
10001916: 3502         	adds	r5, #0x2
;  lsrs r4,r3,#15
10001918: 0bdc         	lsrs	r4, r3, #0xf
;  bne 1f
1000191a: d102         	bne	0x10001922 <y64_x48+0x40> @ imm = #0x4
;  adds r2,r2
1000191c: 1892         	adds	r2, r2, r2
;  adcs r3,r3                @ if(x0<1U<<47) x0<<=1,xsh+=1;
1000191e: 415b         	adcs	r3, r3
;  adds r5,#1
10001920: 3501         	adds	r5, #0x1
;  movs r4,r3
10001922: 001c         	movs	r4, r3
;  adds r7,r2,r2
10001924: 1897         	adds	r7, r2, r2
;  adcs r4,r4
10001926: 4164         	adcs	r4, r4
;  adds r4,#1                @ x1=(ui32)(x0>>31)+1; // 2^16<x1<=2^17
10001928: 3401         	adds	r4, #0x1
;  ldr r7,=SIO_BASE
1000192a: 4f46         	ldr	r7, [pc, #0x118]        @ 0x10001a44 <y64_x64+0x58>
;  str r4,[r7,#SIO_DIV_UDIVISOR_OFFSET]
1000192c: 667c         	str	r4, [r7, #0x64]
;  ldr r4,=0xffffffff
1000192e: 4c46         	ldr	r4, [pc, #0x118]        @ 0x10001a48 <y64_x64+0x5c>
;  str r4,[r7,#SIO_DIV_UDIVIDEND_OFFSET]
10001930: 663c         	str	r4, [r7, #0x60]
;  lsrs r6,r1,#16
10001932: 0c0e         	lsrs	r6, r1, #0x10
;  wait_div 1
10001934: e7ff         	b	0x10001936 <y64_x48+0x54> @ imm = #-0x2
10001936: e7ff         	b	0x10001938 <y64_x48+0x56> @ imm = #-0x2
10001938: e7ff         	b	0x1000193a <y64_x48+0x58> @ imm = #-0x2
1000193a: 46c0         	mov	r8, r8
;  ldr r4,[r7,#SIO_DIV_QUOTIENT_OFFSET]  @ r=0xffffffffU/x1; 2^15<=r<2^16 r is a normalised reciprocal of x, guaranteed not an overestimate
1000193c: 6f3c         	ldr	r4, [r7, #0x70]
;  muls r6,r4
1000193e: 4366         	muls	r6, r4, r6
;  lsrs r6,#16               @ q=((ui32)(y>>48)*r)>>16;
10001940: 0c36         	lsrs	r6, r6, #0x10
;  lsls r7,r6,#13
10001942: 0377         	lsls	r7, r6, #0xd
;  mov r14,r7                @ save q<<13
10001944: 46be         	mov	lr, r7
;  uxth r7,r2                @ x0l
10001946: b297         	uxth	r7, r2
;  muls r7,r6
10001948: 4377         	muls	r7, r6, r7
;  subs r0,r7
1000194a: 1bc0         	subs	r0, r0, r7
;  bcs 1f
1000194c: d200         	bhs	0x10001950 <y64_x48+0x6e> @ imm = #0x0
;  subs r1,#1
1000194e: 3901         	subs	r1, #0x1
;  subs r0,r7
10001950: 1bc0         	subs	r0, r0, r7
;  bcs 1f
10001952: d200         	bhs	0x10001956 <y64_x48+0x74> @ imm = #0x0
;  subs r1,#1
10001954: 3901         	subs	r1, #0x1
;  uxth r7,r3                @ x0h
10001956: b29f         	uxth	r7, r3
;  muls r7,r6
10001958: 4377         	muls	r7, r6, r7
;  subs r1,r7
1000195a: 1bc9         	subs	r1, r1, r7
;  subs r1,r7
1000195c: 1bc9         	subs	r1, r1, r7
;  lsrs r7,r2,#16            @ x0m
1000195e: 0c17         	lsrs	r7, r2, #0x10
;  muls r7,r6
10001960: 4377         	muls	r7, r6, r7
;  lsls r6,r7,#17
10001962: 047e         	lsls	r6, r7, #0x11
;  lsrs r7,#15
10001964: 0bff         	lsrs	r7, r7, #0xf
;  subs r0,r6
10001966: 1b80         	subs	r0, r0, r6
;  sbcs r1,r7                @ y-=((ui64)q*x0)<<1;
10001968: 41b9         	sbcs	r1, r7
;  lsrs r6,r1,#3             @ y>>35
1000196a: 08ce         	lsrs	r6, r1, #0x3
;  muls r6,r4
1000196c: 4366         	muls	r6, r4, r6
;  lsrs r6,#16               @ q=((ui32)(y>>35)*r)>>16;
1000196e: 0c36         	lsrs	r6, r6, #0x10
;  cmp r5,#12
10001970: 2d0c         	cmp	r5, #0xc
;  blt last1                 @ if(xsh<12) goto last1;
10001972: db33         	blt	0x100019dc <last1>      @ imm = #0x66
;  add r14,r6                @ qu<<13+q
10001974: 44b6         	add	lr, r6
;  lsrs r2,#12
10001976: 0b12         	lsrs	r2, r2, #0xc
;  lsls r7,r3,#20
10001978: 051f         	lsls	r7, r3, #0x14
;  orrs r2,r7
1000197a: 433a         	orrs	r2, r7
;  lsrs r3,#12               @ x0>>12
1000197c: 0b1b         	lsrs	r3, r3, #0xc
;  uxth r7,r2                @ x0l
1000197e: b297         	uxth	r7, r2
;  muls r7,r6
10001980: 4377         	muls	r7, r6, r7
;  subs r0,r7
10001982: 1bc0         	subs	r0, r0, r7
;  bcs 1f
10001984: d200         	bhs	0x10001988 <y64_x48+0xa6> @ imm = #0x0
;  subs r1,#1
10001986: 3901         	subs	r1, #0x1
;  uxth r7,r3                @ x0h
10001988: b29f         	uxth	r7, r3
;  muls r7,r6
1000198a: 4377         	muls	r7, r6, r7
;  subs r1,r7
1000198c: 1bc9         	subs	r1, r1, r7
;  lsrs r7,r2,#16            @ x0m
1000198e: 0c17         	lsrs	r7, r2, #0x10
;  muls r7,r6
10001990: 4377         	muls	r7, r6, r7
;  lsls r6,r7,#16
10001992: 043e         	lsls	r6, r7, #0x10
;  lsrs r7,#16
10001994: 0c3f         	lsrs	r7, r7, #0x10
;  subs r0,r6
10001996: 1b80         	subs	r0, r0, r6
;  sbcs r1,r7                @ y-=((ui64)q*x0)>>12
10001998: 41b9         	sbcs	r1, r7
;  lsrs r6,r0,#22
1000199a: 0d86         	lsrs	r6, r0, #0x16
;  lsls r7,r1,#10
1000199c: 028f         	lsls	r7, r1, #0xa
;  orrs r6,r7                @ y>>22
1000199e: 433e         	orrs	r6, r7
;  muls r6,r4
100019a0: 4366         	muls	r6, r4, r6
;  movs r7,#41
100019a2: 2729         	movs	r7, #0x29
;  subs r7,r5
100019a4: 1b7f         	subs	r7, r7, r5
;  lsrs r6,r7                @ q=((ui32)(y>>22)*r)>>(16+25-xsh)
100019a6: 40fe         	lsrs	r6, r7
;  subs r5,#12
100019a8: 3d0c         	subs	r5, #0xc
;  mov r7,r14
100019aa: 4677         	mov	r7, lr
;  lsls r7,r5
100019ac: 40af         	lsls	r7, r5
;  adds r7,r6                @ qu=(qu<<(xsh-12))+q
100019ae: 19bf         	adds	r7, r7, r6
;  pop {r4,r5}               @ recall x
100019b0: bc30         	pop	{r4, r5}
;  uxth r2,r4
100019b2: b2a2         	uxth	r2, r4
;  uxth r3,r5
100019b4: b2ab         	uxth	r3, r5
;  muls r2,r6                @ xlo*q
100019b6: 4372         	muls	r2, r6, r2
;  muls r3,r6                @ xhi*q
100019b8: 4373         	muls	r3, r6, r3
;  subs r0,r2
100019ba: 1a80         	subs	r0, r0, r2
;  sbcs r1,r3
100019bc: 4199         	sbcs	r1, r3
;  lsrs r2,r4,#16
100019be: 0c22         	lsrs	r2, r4, #0x10
;  muls r2,r6
100019c0: 4372         	muls	r2, r6, r2
;  lsrs r3,r2,#16
100019c2: 0c13         	lsrs	r3, r2, #0x10
;  lsls r2,#16               @ xm*q
100019c4: 0412         	lsls	r2, r2, #0x10
;  subs r0,r2
100019c6: 1a80         	subs	r0, r0, r2
;  sbcs r1,r3                @ y-=(ui64)q*x
100019c8: 4199         	sbcs	r1, r3
;  movs r2,r0
100019ca: 0002         	movs	r2, r0
;  movs r3,r1
100019cc: 000b         	movs	r3, r1
;  adds r7,#1
100019ce: 3701         	adds	r7, #0x1
;  subs r0,r4
100019d0: 1b00         	subs	r0, r0, r4
;  sbcs r1,r5                @ while(y>=x) y-=x,qu++;
100019d2: 41a9         	sbcs	r1, r5
;  bhs 1b
100019d4: d2f9         	bhs	0x100019ca <y64_x48+0xe8> @ imm = #-0xe
;  subs r0,r7,#1             @ correction to qu
100019d6: 1e78         	subs	r0, r7, #0x1
;  movs r1,#0
100019d8: 2100         	movs	r1, #0x0
;  pop {r4-r7,r15}
100019da: bdf0         	pop	{r4, r5, r6, r7, pc}

100019dc <last1>:
;  movs r7,#12
100019dc: 270c         	movs	r7, #0xc
;  subs r7,r5
100019de: 1b7f         	subs	r7, r7, r5
;  lsrs r6,r7                @ q>>=12-xsh
100019e0: 40fe         	lsrs	r6, r7
;  mov r7,r14
100019e2: 4677         	mov	r7, lr
;  lsrs r7,#13
100019e4: 0b7f         	lsrs	r7, r7, #0xd
;  lsls r7,r5
100019e6: 40af         	lsls	r7, r5
;  adds r7,r7                @ qu<<(xsh+1)
100019e8: 19ff         	adds	r7, r7, r7
;  b 2b
100019ea: e7e0         	b	0x100019ae <y64_x48+0xcc> @ imm = #-0x40

100019ec <y64_x64>:
;  movs r4,#0                @ q=0 if x>>32==0xffffffff
100019ec: 2400         	movs	r4, #0x0
;  adds r5,r3,#1
100019ee: 1c5d         	adds	r5, r3, #0x1
;  beq 1f
100019f0: d007         	beq	0x10001a02 <y64_x64+0x16> @ imm = #0xe
;  ldr r7,=SIO_BASE
100019f2: 4f14         	ldr	r7, [pc, #0x50]         @ 0x10001a44 <y64_x64+0x58>
;  str r5,[r7,#SIO_DIV_UDIVISOR_OFFSET]
100019f4: 667d         	str	r5, [r7, #0x64]
;  str r1,[r7,#SIO_DIV_UDIVIDEND_OFFSET]
100019f6: 6639         	str	r1, [r7, #0x60]
;  wait_div 0
100019f8: e7ff         	b	0x100019fa <y64_x64+0xe> @ imm = #-0x2
100019fa: e7ff         	b	0x100019fc <y64_x64+0x10> @ imm = #-0x2
100019fc: e7ff         	b	0x100019fe <y64_x64+0x12> @ imm = #-0x2
100019fe: e7ff         	b	0x10001a00 <y64_x64+0x14> @ imm = #-0x2
;  ldr r4,[r7,#SIO_DIV_QUOTIENT_OFFSET] @ q=(ui32)(y>>32)/((x>>32)+1)
10001a00: 6f3c         	ldr	r4, [r7, #0x70]
;  uxth r5,r2
10001a02: b295         	uxth	r5, r2
;  uxth r6,r3
10001a04: b29e         	uxth	r6, r3
;  muls r5,r4
10001a06: 4365         	muls	r5, r4, r5
;  muls r6,r4
10001a08: 4366         	muls	r6, r4, r6
;  subs r0,r5
10001a0a: 1b40         	subs	r0, r0, r5
;  sbcs r1,r6
10001a0c: 41b1         	sbcs	r1, r6
;  lsrs r5,r2,#16
10001a0e: 0c15         	lsrs	r5, r2, #0x10
;  lsrs r6,r3,#16
10001a10: 0c1e         	lsrs	r6, r3, #0x10
;  muls r5,r4
10001a12: 4365         	muls	r5, r4, r5
;  muls r6,r4
10001a14: 4366         	muls	r6, r4, r6
;  lsls r6,#16
10001a16: 0436         	lsls	r6, r6, #0x10
;  lsrs r7,r5,#16
10001a18: 0c2f         	lsrs	r7, r5, #0x10
;  orrs r6,r7
10001a1a: 433e         	orrs	r6, r7
;  lsls r5,#16
10001a1c: 042d         	lsls	r5, r5, #0x10
;  subs r0,r5
10001a1e: 1b40         	subs	r0, r0, r5
;  sbcs r1,r6                @   y-=(ui64)q*x
10001a20: 41b1         	sbcs	r1, r6
;  cmp r1,r3                 @   while(y>=x) y-=x,q++
10001a22: 4299         	cmp	r1, r3
;  bhs 1f
10001a24: d204         	bhs	0x10001a30 <y64_x64+0x44> @ imm = #0x8
;  movs r2,r0
10001a26: 0002         	movs	r2, r0
;  movs r3,r1
10001a28: 000b         	movs	r3, r1
;  movs r0,r4
10001a2a: 0020         	movs	r0, r4
;  movs r1,#0
10001a2c: 2100         	movs	r1, #0x0
;  pop {r4-r7,r15}
10001a2e: bdf0         	pop	{r4, r5, r6, r7, pc}
;  bne 2f
10001a30: d101         	bne	0x10001a36 <y64_x64+0x4a> @ imm = #0x2
;  cmp r0,r2
10001a32: 4290         	cmp	r0, r2
;  blo 3b
10001a34: d3f7         	blo	0x10001a26 <y64_x64+0x3a> @ imm = #-0x12
;  subs r0,r2
10001a36: 1a80         	subs	r0, r0, r2
;  sbcs r1,r3
10001a38: 4199         	sbcs	r1, r3
;  adds r4,#1
10001a3a: 3401         	adds	r4, #0x1
;  cmp r1,r3
10001a3c: 4299         	cmp	r1, r3
;  blo 3b
10001a3e: d3f2         	blo	0x10001a26 <y64_x64+0x3a> @ imm = #-0x1c
;  b 1b
10001a40: e7f6         	b	0x10001a30 <y64_x64+0x44> @ imm = #-0x14
10001a42: 00 00        	.short	0x0000
10001a44: 00 00 00 d0  	.word	0xd0000000
10001a48: ff ff ff ff  	.word	0xffffffff

10001a4c <__wrap___aeabi_drsub>:
;     eors r0, r1
10001a4c: 4048         	eors	r0, r1
;     eors r1, r0
10001a4e: 4041         	eors	r1, r0
;     eors r0, r1
10001a50: 4048         	eors	r0, r1

10001a52 <__wrap___aeabi_dsub>:
;    shimmable_table_tail_call SF_TABLE_FSUB dsub_shim
10001a52: b418         	push	{r3, r4}
10001a54: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x10001ac4 <ddiv_dsub_nan_helper+0x12>
10001a56: 685b         	ldr	r3, [r3, #0x4]
10001a58: 46fc         	mov	r12, pc
10001a5a: 9301         	str	r3, [sp, #0x4]
10001a5c: bd08         	pop	{r3, pc}
10001a5e: 04 df f7 1c  	.word	0x1cf7df04
10001a62: 00 10        	.short	0x1000

10001a64 <__wrap___aeabi_dadd>:
;    shimmable_table_tail_call SF_TABLE_FADD dadd_shim
10001a64: b418         	push	{r3, r4}
10001a66: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x10001ac4 <ddiv_dsub_nan_helper+0x12>
10001a68: 681b         	ldr	r3, [r3]
10001a6a: 46fc         	mov	r12, pc
10001a6c: 9301         	str	r3, [sp, #0x4]
10001a6e: bd08         	pop	{r3, pc}
10001a70: 00 df 01 1d  	.word	0x1d01df00
10001a74: 00 10        	.short	0x1000

10001a76 <__wrap___aeabi_ddiv>:
;     mov ip, r2
10001a76: 4694         	mov	r12, r2
;     ldr r2, =(SIO_BASE)
10001a78: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x10001ac8 <ddiv_dsub_nan_helper+0x16>
;     ldr r2, [r2, #SIO_DIV_CSR_OFFSET]
10001a7a: 6f92         	ldr	r2, [r2, #0x78]
;     lsrs r2, #SIO_DIV_CSR_DIRTY_SHIFT_FOR_CARRY
10001a7c: 0892         	lsrs	r2, r2, #0x2
;     bcs ddiv_save_state
10001a7e: d209         	bhs	0x10001a94 <ddiv_save_state> @ imm = #0x12
;     mov r2, ip
10001a80: 4662         	mov	r2, r12

10001a82 <ddiv_shim_call>:
;     shimmable_table_tail_call SF_TABLE_FDIV ddiv_shim
10001a82: b418         	push	{r3, r4}
10001a84: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x10001ac4 <ddiv_dsub_nan_helper+0x12>
10001a86: 68db         	ldr	r3, [r3, #0xc]
10001a88: 46fc         	mov	r12, pc
10001a8a: 9301         	str	r3, [sp, #0x4]
10001a8c: bd08         	pop	{r3, pc}
10001a8e: 0c df b9 1f  	.word	0x1fb9df0c
10001a92: 00 10        	.short	0x1000

10001a94 <ddiv_save_state>:
;     ldr r2, =(SIO_BASE)
10001a94: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x10001ac8 <ddiv_dsub_nan_helper+0x16>
;     save_div_state_and_lr
10001a96: b5f0         	push	{r4, r5, r6, r7, lr}
10001a98: 6e14         	ldr	r4, [r2, #0x60]
10001a9a: 6e55         	ldr	r5, [r2, #0x64]
10001a9c: 6f57         	ldr	r7, [r2, #0x74]
10001a9e: 6f16         	ldr	r6, [r2, #0x70]
;     mov r2, ip
10001aa0: 4662         	mov	r2, r12
;     bl ddiv_shim_call
10001aa2: f7ff ffee    	bl	0x10001a82 <ddiv_shim_call> @ imm = #-0x24
;     ldr r2, =(SIO_BASE)
10001aa6: 4a08         	ldr	r2, [pc, #0x20]         @ 0x10001ac8 <ddiv_dsub_nan_helper+0x16>
;     restore_div_state_and_return
10001aa8: 6614         	str	r4, [r2, #0x60]
10001aaa: 6655         	str	r5, [r2, #0x64]
10001aac: 6757         	str	r7, [r2, #0x74]
10001aae: 6716         	str	r6, [r2, #0x70]
10001ab0: bdf0         	pop	{r4, r5, r6, r7, pc}

10001ab2 <ddiv_dsub_nan_helper>:
;    shimmable_table_tail_call SF_TABLE_FMUL dmul_shim
10001ab2: b418         	push	{r3, r4}
10001ab4: 4b03         	ldr	r3, [pc, #0xc]          @ 0x10001ac4 <ddiv_dsub_nan_helper+0x12>
10001ab6: 689b         	ldr	r3, [r3, #0x8]
10001ab8: 46fc         	mov	r12, pc
10001aba: 9301         	str	r3, [sp, #0x4]
10001abc: bd08         	pop	{r3, pc}
10001abe: 08 df 5d 1e  	.word	0x1e5ddf08
10001ac2: 00 10        	.short	0x1000
10001ac4: 68 03 00 20  	.word	0x20000368
10001ac8: 00 00 00 d0  	.word	0xd0000000

10001acc <__wrap___aeabi_cdrcmple>:
;  push {r0-r7,r14}
10001acc: b5ff         	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
;     eors r0, r2
10001ace: 4050         	eors	r0, r2
;     eors r2, r0
10001ad0: 4042         	eors	r2, r0
;     eors r0, r2
10001ad2: 4050         	eors	r0, r2
;     eors r1, r3
10001ad4: 4059         	eors	r1, r3
;     eors r3, r1
10001ad6: 404b         	eors	r3, r1
;     eors r1, r3
10001ad8: 4059         	eors	r1, r3
;     b __aeabi_dfcmple_guts
10001ada: e000         	b	0x10001ade <__aeabi_dfcmple_guts> @ imm = #0x0

10001adc <__wrap___aeabi_cdcmple>:
;  push {r0-r7,r14}
10001adc: b5ff         	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}

10001ade <__aeabi_dfcmple_guts>:
;  ldr r7,=0x7ff                @ flush NaNs and denormals
10001ade: 4f15         	ldr	r7, [pc, #0x54]         @ 0x10001b34 <__aeabi_dfcmple_guts+0x56>
;  lsls r4,r1,#1
10001ae0: 004c         	lsls	r4, r1, #0x1
;  lsrs r4,#21
10001ae2: 0d64         	lsrs	r4, r4, #0x15
;  beq 1f
10001ae4: d003         	beq	0x10001aee <__aeabi_dfcmple_guts+0x10> @ imm = #0x6
;  cmp r4,r7
10001ae6: 42bc         	cmp	r4, r7
;  bne 2f
10001ae8: d104         	bne	0x10001af4 <__aeabi_dfcmple_guts+0x16> @ imm = #0x8
;  lsls r4, r1, #12
10001aea: 030c         	lsls	r4, r1, #0xc
;  bhi 7f
10001aec: d814         	bhi	0x10001b18 <__aeabi_dfcmple_guts+0x3a> @ imm = #0x28
;  movs r0,#0
10001aee: 2000         	movs	r0, #0x0
;  lsrs r1,#20
10001af0: 0d09         	lsrs	r1, r1, #0x14
;  lsls r1,#20
10001af2: 0509         	lsls	r1, r1, #0x14
;  lsls r4,r3,#1
10001af4: 005c         	lsls	r4, r3, #0x1
;  lsrs r4,#21
10001af6: 0d64         	lsrs	r4, r4, #0x15
;  beq 1f
10001af8: d003         	beq	0x10001b02 <__aeabi_dfcmple_guts+0x24> @ imm = #0x6
;  cmp r4,r7
10001afa: 42bc         	cmp	r4, r7
;  bne 2f
10001afc: d104         	bne	0x10001b08 <__aeabi_dfcmple_guts+0x2a> @ imm = #0x8
;  lsls r4, r3, #12
10001afe: 031c         	lsls	r4, r3, #0xc
;  bhi 7f
10001b00: d80a         	bhi	0x10001b18 <__aeabi_dfcmple_guts+0x3a> @ imm = #0x14
;  movs r2,#0
10001b02: 2200         	movs	r2, #0x0
;  lsrs r3,#20
10001b04: 0d1b         	lsrs	r3, r3, #0x14
;  lsls r3,#20
10001b06: 051b         	lsls	r3, r3, #0x14
;  movs r6,#1
10001b08: 2601         	movs	r6, #0x1
;  eors r3,r1
10001b0a: 404b         	eors	r3, r1
;  bmi 4f                        @ opposite signs? then can proceed on basis of sign of x
10001b0c: d409         	bmi	0x10001b22 <__aeabi_dfcmple_guts+0x44> @ imm = #0x12
;  eors r3,r1                    @ restore r3
10001b0e: 404b         	eors	r3, r1
;  bpl 2f
10001b10: d503         	bpl	0x10001b1a <__aeabi_dfcmple_guts+0x3c> @ imm = #0x6
;  cmp r3,r1
10001b12: 428b         	cmp	r3, r1
;  bne 7f
10001b14: d100         	bne	0x10001b18 <__aeabi_dfcmple_guts+0x3a> @ imm = #0x0
;  cmp r2,r0
10001b16: 4282         	cmp	r2, r0
;  pop {r0-r7,r15}
10001b18: bdff         	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}
;  cmp r1,r3
10001b1a: 4299         	cmp	r1, r3
;  bne 7b
10001b1c: d1fc         	bne	0x10001b18 <__aeabi_dfcmple_guts+0x3a> @ imm = #-0x8
;  cmp r0,r2
10001b1e: 4290         	cmp	r0, r2
;  pop {r0-r7,r15}
10001b20: bdff         	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}
;  orrs r3,r1                    @ make -0==+0
10001b22: 430b         	orrs	r3, r1
;  adds r3,r3
10001b24: 18db         	adds	r3, r3, r3
;  orrs r3,r0
10001b26: 4303         	orrs	r3, r0
;  orrs r3,r2
10001b28: 4313         	orrs	r3, r2
;  beq 7b
10001b2a: d0f5         	beq	0x10001b18 <__aeabi_dfcmple_guts+0x3a> @ imm = #-0x16
;  mvns r1, r1     @ carry inverse of r1 sign
10001b2c: 43c9         	mvns	r1, r1
;  adds r1, r1
10001b2e: 1849         	adds	r1, r1, r1
;  pop {r0-r7,r15}
10001b30: bdff         	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}
10001b32: 00 00        	.short	0x0000
10001b34: ff 07 00 00  	.word	0x000007ff

10001b38 <__wrap___aeabi_dcmplt>:
;     push {lr}
10001b38: b500         	push	{lr}
;     bl __aeabi_cdcmple
10001b3a: f7ff ffcf    	bl	0x10001adc <__wrap___aeabi_cdcmple> @ imm = #-0x62
;     sbcs r0, r0
10001b3e: 4180         	sbcs	r0, r0
;     pop {pc}
10001b40: bd00         	pop	{pc}
10001b42: 46c0         	mov	r8, r8

10001b44 <__wrap___aeabi_dcmple>:
;     push {lr}
10001b44: b500         	push	{lr}
;     bl __aeabi_cdcmple
10001b46: f7ff ffc9    	bl	0x10001adc <__wrap___aeabi_cdcmple> @ imm = #-0x6e
;     bls 1f
10001b4a: d901         	bls	0x10001b50 <__wrap___aeabi_dcmple+0xc> @ imm = #0x2
;     movs r0, #0
10001b4c: 2000         	movs	r0, #0x0
;     pop {pc}
10001b4e: bd00         	pop	{pc}
;     movs r0, #1
10001b50: 2001         	movs	r0, #0x1
;     pop {pc}
10001b52: bd00         	pop	{pc}

10001b54 <__wrap___aeabi_dcmpge>:
;     push {lr}
10001b54: b500         	push	{lr}
;     bl __aeabi_cdrcmple
10001b56: f7ff ffb9    	bl	0x10001acc <__wrap___aeabi_cdrcmple> @ imm = #-0x8e
;     bls 1f
10001b5a: d901         	bls	0x10001b60 <__wrap___aeabi_dcmpge+0xc> @ imm = #0x2
;     movs r0, #0
10001b5c: 2000         	movs	r0, #0x0
;     pop {pc}
10001b5e: bd00         	pop	{pc}
;     movs r0, #1
10001b60: 2001         	movs	r0, #0x1
;     pop {pc}
10001b62: bd00         	pop	{pc}

10001b64 <__wrap___aeabi_dcmpgt>:
;     push {lr}
10001b64: b500         	push	{lr}
;     bl __aeabi_cdrcmple
10001b66: f7ff ffb1    	bl	0x10001acc <__wrap___aeabi_cdrcmple> @ imm = #-0x9e
;     sbcs r0, r0
10001b6a: 4180         	sbcs	r0, r0
;     pop {pc}
10001b6c: bd00         	pop	{pc}

10001b6e <__wrap___aeabi_dcmpun>:
;    movs r0, #1
10001b6e: 2001         	movs	r0, #0x1
;    lsls r0, #21
10001b70: 0540         	lsls	r0, r0, #0x15
;    lsls r2, r1, #1
10001b72: 004a         	lsls	r2, r1, #0x1
;    adds r2, r0
10001b74: 1812         	adds	r2, r2, r0
;    bhi 1f
10001b76: d804         	bhi	0x10001b82 <__wrap___aeabi_dcmpun+0x14> @ imm = #0x8
;    lsls r2, r3, #1
10001b78: 005a         	lsls	r2, r3, #0x1
;    adds r2, r0
10001b7a: 1812         	adds	r2, r2, r0
;    bhi 1f
10001b7c: d801         	bhi	0x10001b82 <__wrap___aeabi_dcmpun+0x14> @ imm = #0x2
;    movs r0, #0
10001b7e: 2000         	movs	r0, #0x0
;    bx lr
10001b80: 4770         	bx	lr
;    movs r0, #1
10001b82: 2001         	movs	r0, #0x1
;    bx lr
10001b84: 4770         	bx	lr
10001b86: 0000         	movs	r0, r0

10001b88 <uint2double>:
;     movs r1, #0
10001b88: 2100         	movs	r1, #0x0
;     cmp r0, #0
10001b8a: 2800         	cmp	r0, #0x0
;     bne 2f
10001b8c: d105         	bne	0x10001b9a <int2double+0xa> @ imm = #0xa
;     bx lr
10001b8e: 4770         	bx	lr

10001b90 <int2double>:
;     asrs r1, r0, #31
10001b90: 17c1         	asrs	r1, r0, #0x1f
;     eors r0, r1
10001b92: 4048         	eors	r0, r1
;     subs r0, r1
10001b94: 1a40         	subs	r0, r0, r1
;     beq 1b
10001b96: d0fa         	beq	0x10001b8e <uint2double+0x6> @ imm = #-0xc
;     lsls r1, #31
10001b98: 07c9         	lsls	r1, r1, #0x1f
;     push {r0, r1, r4, lr}
10001b9a: b513         	push	{r0, r1, r4, lr}
;     ldr r3, =sf_clz_func
10001b9c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x10001bb8 <int2double+0x28>
;     ldr r3, [r3]
10001b9e: 681b         	ldr	r3, [r3]
;     blx r3
10001ba0: 4798         	blx	r3
;     pop {r2, r3}
10001ba2: bc0c         	pop	{r2, r3}
;     adds r4, r0, #1
10001ba4: 1c44         	adds	r4, r0, #0x1
;     lsls r2, r4
10001ba6: 40a2         	lsls	r2, r4
;     lsls r0, r2, #20
10001ba8: 0510         	lsls	r0, r2, #0x14
;     lsrs r2, #12
10001baa: 0b12         	lsrs	r2, r2, #0xc
;     ldr r1,=1055
10001bac: 4903         	ldr	r1, [pc, #0xc]          @ 0x10001bbc <int2double+0x2c>
;     subs r1, r4
10001bae: 1b09         	subs	r1, r1, r4
;     lsls r1, #20
10001bb0: 0509         	lsls	r1, r1, #0x14
;     orrs r1, r3
10001bb2: 4319         	orrs	r1, r3
;     orrs r1, r2
10001bb4: 4311         	orrs	r1, r2
;     pop {r4, pc}
10001bb6: bd10         	pop	{r4, pc}
10001bb8: c8 05 00 20  	.word	0x200005c8
10001bbc: 1f 04 00 00  	.word	0x0000041f

10001bc0 <double2int_z>:
;     push {r4, lr}
10001bc0: b510         	push	{r4, lr}
;     lsls r4, r1, #1
10001bc2: 004c         	lsls	r4, r1, #0x1
;     lsrs r2, r4, #21
10001bc4: 0d62         	lsrs	r2, r4, #0x15
;     movs r3, #0x80
10001bc6: 2380         	movs	r3, #0x80
;     adds r2, r3
10001bc8: 18d2         	adds	r2, r2, r3
;     lsls r3, #3
10001bca: 00db         	lsls	r3, r3, #0x3
;     subs r2, r3
10001bcc: 1ad2         	subs	r2, r2, r3
;     lsls r3, #21
10001bce: 055b         	lsls	r3, r3, #0x15
;     cmp r2, #126
10001bd0: 2a7e         	cmp	r2, #0x7e
;     ble 1f
10001bd2: dd10         	ble	0x10001bf6 <double2int_z+0x36> @ imm = #0x20
;     subs r2, #158
10001bd4: 3a9e         	subs	r2, #0x9e
;     bge 2f
10001bd6: da13         	bge	0x10001c00 <double2int_z+0x40> @ imm = #0x26
;     asrs r4, r1, #31
10001bd8: 17cc         	asrs	r4, r1, #0x1f
;     lsls r1, #12
10001bda: 0309         	lsls	r1, r1, #0xc
;     lsrs r1, #1
10001bdc: 0849         	lsrs	r1, r1, #0x1
;     orrs r1, r3
10001bde: 4319         	orrs	r1, r3
;     negs r2, r2
10001be0: 4252         	rsbs	r2, r2, #0
;     lsrs r1, r2
10001be2: 40d1         	lsrs	r1, r2
;     lsls r4, #1
10001be4: 0064         	lsls	r4, r4, #0x1
;     adds r4, #1
10001be6: 3401         	adds	r4, #0x1
;     adds r2, #21
10001be8: 3215         	adds	r2, #0x15
;     cmp r2, #32
10001bea: 2a20         	cmp	r2, #0x20
;     bge 3f
10001bec: da05         	bge	0x10001bfa <double2int_z+0x3a> @ imm = #0xa
;     lsrs r0, r2
10001bee: 40d0         	lsrs	r0, r2
;     orrs r0, r1
10001bf0: 4308         	orrs	r0, r1
;     muls r0, r4
10001bf2: 4360         	muls	r0, r4, r0
;     pop {r4, pc}
10001bf4: bd10         	pop	{r4, pc}
;     movs r0, #0
10001bf6: 2000         	movs	r0, #0x0
;     pop {r4, pc}
10001bf8: bd10         	pop	{r4, pc}
;     mov r0, r1
10001bfa: 4608         	mov	r0, r1
;     muls r0, r4
10001bfc: 4360         	muls	r0, r4, r0
;     pop {r4, pc}
10001bfe: bd10         	pop	{r4, pc}
;     lsrs r0, r1, #31
10001c00: 0fc8         	lsrs	r0, r1, #0x1f
;     adds r0, r3
10001c02: 18c0         	adds	r0, r0, r3
;     subs r0, #1
10001c04: 3801         	subs	r0, #0x1
;     pop {r4, pc}
10001c06: bd10         	pop	{r4, pc}

10001c08 <double2uint_z>:
;     shimmable_table_tail_call SF_TABLE_FLOAT2UINT double2uint_shim
10001c08: b418         	push	{r3, r4}
10001c0a: 4b04         	ldr	r3, [pc, #0x10]         @ 0x10001c1c <double2uint_z+0x14>
10001c0c: 6a5b         	ldr	r3, [r3, #0x24]
10001c0e: 46fc         	mov	r12, pc
10001c10: 9301         	str	r3, [sp, #0x4]
10001c12: bd08         	pop	{r3, pc}
10001c14: 24 df 69 21  	.word	0x2169df24
10001c18: 00 10 00 00  	.word	0x00001000
10001c1c: 68 03 00 20  	.word	0x20000368

10001c20 <__aeabi_double_init>:
;     return *(uint8_t*)0x13;
10001c20: 2313         	movs	r3, #0x13
; void __aeabi_double_init(void) {
10001c22: b570         	push	{r4, r5, r6, lr}
;     int rom_version = rp2040_rom_version();
10001c24: 781d         	ldrb	r5, [r3]
;     if (rom_version == 1) {
10001c26: 2d01         	cmp	r5, #0x1
10001c28: d019         	beq	0x10001c5e <__aeabi_double_init+0x3e> @ imm = #0x32
;     if (rom_version >= 2) {
10001c2a: dd14         	ble	0x10001c56 <__aeabi_double_init+0x36> @ imm = #0x28
;         void *rom_table_double = rom_data_lookup(rom_table_code('S', 'D'));
10001c2c: 481f         	ldr	r0, [pc, #0x7c]         @ 0x10001cac <__aeabi_double_init+0x8c>
10001c2e: f7ff fb8f    	bl	0x10001350 <rom_data_lookup> @ imm = #-0x8e2
10001c32: 0006         	movs	r6, r0
;         void *rom_table_float = rom_data_lookup(rom_table_code('S', 'F'));
10001c34: 481e         	ldr	r0, [pc, #0x78]         @ 0x10001cb0 <__aeabi_double_init+0x90>
10001c36: f7ff fb8b    	bl	0x10001350 <rom_data_lookup> @ imm = #-0x8ea
;         memcpy(&sd_table, rom_table_double, SF_TABLE_V2_SIZE);
10001c3a: 4c1e         	ldr	r4, [pc, #0x78]         @ 0x10001cb4 <__aeabi_double_init+0x94>
10001c3c: 2280         	movs	r2, #0x80
10001c3e: 0031         	movs	r1, r6
10001c40: 0020         	movs	r0, r4
10001c42: f000 fba5    	bl	0x10002390 <__wrap_memcpy> @ imm = #0x74a
;     if (rom_version < 3) {
10001c46: 2d02         	cmp	r5, #0x2
10001c48: d02d         	beq	0x10001ca6 <__aeabi_double_init+0x86> @ imm = #0x5a
;     sf_clz_func = rom_func_lookup(ROM_FUNC_CLZ32);
10001c4a: 481b         	ldr	r0, [pc, #0x6c]         @ 0x10001cb8 <__aeabi_double_init+0x98>
10001c4c: f7ff fb78    	bl	0x10001340 <rom_func_lookup> @ imm = #-0x910
10001c50: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x10001cbc <__aeabi_double_init+0x9c>
10001c52: 6018         	str	r0, [r3]
; }
10001c54: bd70         	pop	{r4, r5, r6, pc}
10001c56: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x10001cc0 <__aeabi_double_init+0xa0>
10001c58: 4c16         	ldr	r4, [pc, #0x58]         @ 0x10001cb4 <__aeabi_double_init+0x94>
;         sd_table[SF_TABLE_V3_FSINCOS / 4] = (uintptr_t) double_table_shim_on_use_helper;
10001c5a: 64a3         	str	r3, [r4, #0x48]
10001c5c: e7f5         	b	0x10001c4a <__aeabi_double_init+0x2a> @ imm = #-0x16
10001c5e: 4b18         	ldr	r3, [pc, #0x60]         @ 0x10001cc0 <__aeabi_double_init+0xa0>
;             sd_table[i] = (uintptr_t)double_table_shim_on_use_helper;
10001c60: 4c14         	ldr	r4, [pc, #0x50]         @ 0x10001cb4 <__aeabi_double_init+0x94>
10001c62: 6023         	str	r3, [r4]
10001c64: 6063         	str	r3, [r4, #0x4]
10001c66: 60a3         	str	r3, [r4, #0x8]
10001c68: 60e3         	str	r3, [r4, #0xc]
10001c6a: 6123         	str	r3, [r4, #0x10]
10001c6c: 6163         	str	r3, [r4, #0x14]
10001c6e: 61a3         	str	r3, [r4, #0x18]
10001c70: 61e3         	str	r3, [r4, #0x1c]
10001c72: 6223         	str	r3, [r4, #0x20]
10001c74: 6263         	str	r3, [r4, #0x24]
10001c76: 62a3         	str	r3, [r4, #0x28]
10001c78: 62e3         	str	r3, [r4, #0x2c]
10001c7a: 6323         	str	r3, [r4, #0x30]
10001c7c: 6363         	str	r3, [r4, #0x34]
10001c7e: 63a3         	str	r3, [r4, #0x38]
10001c80: 63e3         	str	r3, [r4, #0x3c]
10001c82: 6423         	str	r3, [r4, #0x40]
10001c84: 6463         	str	r3, [r4, #0x44]
10001c86: 64a3         	str	r3, [r4, #0x48]
10001c88: 64e3         	str	r3, [r4, #0x4c]
10001c8a: 6523         	str	r3, [r4, #0x50]
10001c8c: 6563         	str	r3, [r4, #0x54]
10001c8e: 65a3         	str	r3, [r4, #0x58]
10001c90: 65e3         	str	r3, [r4, #0x5c]
10001c92: 6623         	str	r3, [r4, #0x60]
10001c94: 6663         	str	r3, [r4, #0x64]
10001c96: 66a3         	str	r3, [r4, #0x68]
10001c98: 66e3         	str	r3, [r4, #0x6c]
10001c9a: 6723         	str	r3, [r4, #0x70]
10001c9c: 6763         	str	r3, [r4, #0x74]
10001c9e: 67a3         	str	r3, [r4, #0x78]
10001ca0: 67e3         	str	r3, [r4, #0x7c]
;         sd_table[SF_TABLE_V3_FSINCOS / 4] = (uintptr_t) double_table_shim_on_use_helper;
10001ca2: 64a3         	str	r3, [r4, #0x48]
10001ca4: e7d1         	b	0x10001c4a <__aeabi_double_init+0x2a> @ imm = #-0x5e
10001ca6: 4b06         	ldr	r3, [pc, #0x18]         @ 0x10001cc0 <__aeabi_double_init+0xa0>
10001ca8: 64a3         	str	r3, [r4, #0x48]
10001caa: e7ce         	b	0x10001c4a <__aeabi_double_init+0x2a> @ imm = #-0x64
10001cac: 53 44 00 00  	.word	0x00004453
10001cb0: 53 46 00 00  	.word	0x00004653
10001cb4: 68 03 00 20  	.word	0x20000368
10001cb8: 4c 33 00 00  	.word	0x0000334c
10001cbc: c8 05 00 20  	.word	0x200005c8
10001cc0: c5 1c 00 10  	.word	0x10001cc5

10001cc4 <double_table_shim_on_use_helper>:
;     push {r0-r2, lr}
10001cc4: b507         	push	{r0, r1, r2, lr}
;     mov r0, ip
10001cc6: 4660         	mov	r0, r12
;     ldrh r1, [r0]
10001cc8: 8801         	ldrh	r1, [r0]
;     lsrs r2, r1, #8
10001cca: 0a0a         	lsrs	r2, r1, #0x8
;     adds r0, #2
10001ccc: 3002         	adds	r0, #0x2
;     cmp r2, #0xdf
10001cce: 2adf         	cmp	r2, #0xdf
;     bne 1b
10001cd0: d1fa         	bne	0x10001cc8 <double_table_shim_on_use_helper+0x4> @ imm = #-0xc
;     uxtb r1, r1 // r1 holds table offset
10001cd2: b2c9         	uxtb	r1, r1
;     lsrs r2, r0, #2
10001cd4: 0882         	lsrs	r2, r0, #0x2
;     bcc 1f
10001cd6: d304         	blo	0x10001ce2 <double_table_shim_on_use_helper+0x1e> @ imm = #0x8
;     ldrh r2, [r0, #0]
10001cd8: 8802         	ldrh	r2, [r0]
;     ldrh r0, [r0, #2]
10001cda: 8840         	ldrh	r0, [r0, #0x2]
;     lsls r0, #16
10001cdc: 0400         	lsls	r0, r0, #0x10
;     orrs r0, r2
10001cde: 4310         	orrs	r0, r2
;     b 2f
10001ce0: e000         	b	0x10001ce4 <double_table_shim_on_use_helper+0x20> @ imm = #0x0
;     ldr r0, [r0]
10001ce2: 6800         	ldr	r0, [r0]
;     ldr r2, =sd_table
10001ce4: 4a01         	ldr	r2, [pc, #0x4]          @ 0x10001cec <double_table_shim_on_use_helper+0x28>
;     str r0, [r2, r1]
10001ce6: 5050         	str	r0, [r2, r1]
;     str r0, [sp, #12]
10001ce8: 9003         	str	r0, [sp, #0xc]
;     pop {r0-r2, pc}
10001cea: bd07         	pop	{r0, r1, r2, pc}
10001cec: 68 03 00 20  	.word	0x20000368

10001cf0 <drsub_shim>:
;     push {r0-r3}
10001cf0: b40f         	push	{r0, r1, r2, r3}
;     pop {r0-r1}
10001cf2: bc03         	pop	{r0, r1}
;     pop {r2-r3}
10001cf4: bc0c         	pop	{r2, r3}

10001cf6 <dsub_shim>:
;  push {r4-r7,r14}
10001cf6: b5f0         	push	{r4, r5, r6, r7, lr}
;  movs r4,#1
10001cf8: 2401         	movs	r4, #0x1
;  lsls r4,#31
10001cfa: 07e4         	lsls	r4, r4, #0x1f
;  eors r3,r4                    @ flip sign on second argument
10001cfc: 4063         	eors	r3, r4
;  b da_entry                    @ continue in dadd
10001cfe: e000         	b	0x10001d02 <da_entry>   @ imm = #0x0

10001d00 <dadd_shim>:
;  push {r4-r7,r14}
10001d00: b5f0         	push	{r4, r5, r6, r7, lr}

10001d02 <da_entry>:
;  mdunpacks r0,r1,r4,r6,r7
10001d02: 0d0c         	lsrs	r4, r1, #0x14
10001d04: 0fcf         	lsrs	r7, r1, #0x1f
10001d06: 1e66         	subs	r6, r4, #0x1
10001d08: 0536         	lsls	r6, r6, #0x14
10001d0a: 1b89         	subs	r1, r1, r6
10001d0c: 0564         	lsls	r4, r4, #0x15
10001d0e: d303         	blo	0x10001d18 <l8_1>       @ imm = #0x6
10001d10: 43c9         	mvns	r1, r1
10001d12: 4240         	rsbs	r0, r0, #0
10001d14: d300         	blo	0x10001d18 <l8_1>       @ imm = #0x0
10001d16: 3101         	adds	r1, #0x1

10001d18 <l8_1>:
10001d18: 0d64         	lsrs	r4, r4, #0x15
10001d1a: d003         	beq	0x10001d24 <l8_2>       @ imm = #0x6
10001d1c: 1c66         	adds	r6, r4, #0x1
10001d1e: 0af6         	lsrs	r6, r6, #0xb
10001d20: d007         	beq	0x10001d32 <l8_3>       @ imm = #0xe
10001d22: 1be4         	subs	r4, r4, r7

10001d24 <l8_2>:
10001d24: 2000         	movs	r0, #0x0
10001d26: 007f         	lsls	r7, r7, #0x1
10001d28: 1c79         	adds	r1, r7, #0x1
10001d2a: 0789         	lsls	r1, r1, #0x1e
10001d2c: 1289         	asrs	r1, r1, #0xa
10001d2e: 3c80         	subs	r4, #0x80
10001d30: 0324         	lsls	r4, r4, #0xc

10001d32 <l8_3>:
;  mdunpacks r2,r3,r5,r6,r7
10001d32: 0d1d         	lsrs	r5, r3, #0x14
10001d34: 0fdf         	lsrs	r7, r3, #0x1f
10001d36: 1e6e         	subs	r6, r5, #0x1
10001d38: 0536         	lsls	r6, r6, #0x14
10001d3a: 1b9b         	subs	r3, r3, r6
10001d3c: 056d         	lsls	r5, r5, #0x15
10001d3e: d303         	blo	0x10001d48 <l9_1>       @ imm = #0x6
10001d40: 43db         	mvns	r3, r3
10001d42: 4252         	rsbs	r2, r2, #0
10001d44: d300         	blo	0x10001d48 <l9_1>       @ imm = #0x0
10001d46: 3301         	adds	r3, #0x1

10001d48 <l9_1>:
10001d48: 0d6d         	lsrs	r5, r5, #0x15
10001d4a: d003         	beq	0x10001d54 <l9_2>       @ imm = #0x6
10001d4c: 1c6e         	adds	r6, r5, #0x1
10001d4e: 0af6         	lsrs	r6, r6, #0xb
10001d50: d007         	beq	0x10001d62 <l9_3>       @ imm = #0xe
10001d52: 1bed         	subs	r5, r5, r7

10001d54 <l9_2>:
10001d54: 2200         	movs	r2, #0x0
10001d56: 007f         	lsls	r7, r7, #0x1
10001d58: 1c7b         	adds	r3, r7, #0x1
10001d5a: 079b         	lsls	r3, r3, #0x1e
10001d5c: 129b         	asrs	r3, r3, #0xa
10001d5e: 3d80         	subs	r5, #0x80
10001d60: 032d         	lsls	r5, r5, #0xc

10001d62 <l9_3>:
;  subs r7,r5,r4                 @ ye-xe
10001d62: 1b2f         	subs	r7, r5, r4
;  subs r6,r4,r5                 @ xe-ye
10001d64: 1b66         	subs	r6, r4, r5
;  bmi da_ygtx
10001d66: d458         	bmi	0x10001e1a <da_ygtx>    @ imm = #0xb0
;  mov r12,r4                    @ save exponent
10001d68: 46a4         	mov	r12, r4
;  cmp r6,#32
10001d6a: 2e20         	cmp	r6, #0x20
;  bge da_xrgty                  @ xe rather greater than ye?
10001d6c: da46         	bge	0x10001dfc <da_xrgty>   @ imm = #0x8c
;  adds r7,#32
10001d6e: 3720         	adds	r7, #0x20
;  movs r4,r2
10001d70: 0014         	movs	r4, r2
;  lsls r4,r4,r7                 @ rounding bit + sticky bits
10001d72: 40bc         	lsls	r4, r7

10001d74 <da_xgty0>:
;  movs r5,r3
10001d74: 001d         	movs	r5, r3
;  lsls r5,r5,r7
10001d76: 40bd         	lsls	r5, r7
;  lsrs r2,r6
10001d78: 40f2         	lsrs	r2, r6
;  asrs r3,r6
10001d7a: 4133         	asrs	r3, r6
;  orrs r2,r5
10001d7c: 432a         	orrs	r2, r5

10001d7e <da_add>:
;  adds r0,r2
10001d7e: 1880         	adds	r0, r0, r2
;  adcs r1,r3
10001d80: 4159         	adcs	r1, r3

10001d82 <da_pack>:
;  lsrs r3,r1,#31                @ get sign bit
10001d82: 0fcb         	lsrs	r3, r1, #0x1f
;  beq 1f                        @ skip on positive
10001d84: d005         	beq	0x10001d92 <da_pack+0x10> @ imm = #0xa
;  mvns r1,r1                    @ negate mantissa
10001d86: 43c9         	mvns	r1, r1
;  mvns r0,r0
10001d88: 43c0         	mvns	r0, r0
;  movs r2,#0
10001d8a: 2200         	movs	r2, #0x0
;  negs r4,r4
10001d8c: 4264         	rsbs	r4, r4, #0
;  adcs r0,r2
10001d8e: 4150         	adcs	r0, r2
;  adcs r1,r2
10001d90: 4151         	adcs	r1, r2
;  mov r2,r12                    @ get exponent
10001d92: 4662         	mov	r2, r12
;  lsrs r5,r1,#21
10001d94: 0d4d         	lsrs	r5, r1, #0x15
;  bne da_0                      @ shift down required?
10001d96: d128         	bne	0x10001dea <da_0>       @ imm = #0x50
;  lsrs r5,r1,#20
10001d98: 0d0d         	lsrs	r5, r1, #0x14
;  bne da_1                      @ normalised?
10001d9a: d107         	bne	0x10001dac <da_1>       @ imm = #0xe
;  cmp r0,#0
10001d9c: 2800         	cmp	r0, #0x0
;  beq da_5                      @ could mantissa be zero?
10001d9e: d01f         	beq	0x10001de0 <da_5>       @ imm = #0x3e

10001da0 <da_2>:
;  adds r4,r4
10001da0: 1924         	adds	r4, r4, r4
;  adcs r0,r0
10001da2: 4140         	adcs	r0, r0
;  adcs r1,r1
10001da4: 4149         	adcs	r1, r1
;  subs r2,#1                    @ adjust exponent
10001da6: 3a01         	subs	r2, #0x1
;  lsrs r5,r1,#20
10001da8: 0d0d         	lsrs	r5, r1, #0x14
;  beq da_2
10001daa: d0f9         	beq	0x10001da0 <da_2>       @ imm = #-0xe

10001dac <da_1>:
;  lsls r4,#1                    @ check rounding bit
10001dac: 0064         	lsls	r4, r4, #0x1
;  bcc da_3
10001dae: d306         	blo	0x10001dbe <da_3>       @ imm = #0xc

10001db0 <da_4>:
;  adds r0,#1                    @ round up
10001db0: 3001         	adds	r0, #0x1
;  bcc 2f
10001db2: d300         	blo	0x10001db6 <da_4+0x6>   @ imm = #0x0
;  adds r1,#1
10001db4: 3101         	adds	r1, #0x1
;  cmp r4,#0                     @ sticky bits zero?
10001db6: 2c00         	cmp	r4, #0x0
;  bne da_3
10001db8: d101         	bne	0x10001dbe <da_3>       @ imm = #0x2
;  lsrs r0,#1                    @ round to even
10001dba: 0840         	lsrs	r0, r0, #0x1
;  lsls r0,#1
10001dbc: 0040         	lsls	r0, r0, #0x1

10001dbe <da_3>:
;  subs r2,#1
10001dbe: 3a01         	subs	r2, #0x1
;  bmi da_6
10001dc0: d40b         	bmi	0x10001dda <da_6>       @ imm = #0x16
;  adds r4,r2,#2                 @ check if exponent is overflowing
10001dc2: 1c94         	adds	r4, r2, #0x2
;  lsrs r4,#11
10001dc4: 0ae4         	lsrs	r4, r4, #0xb
;  bne da_7
10001dc6: d104         	bne	0x10001dd2 <da_7>       @ imm = #0x8
;  lsls r2,#20                   @ pack exponent and sign
10001dc8: 0512         	lsls	r2, r2, #0x14
;  add r1,r2
10001dca: 4411         	add	r1, r2
;  lsls r3,#31
10001dcc: 07db         	lsls	r3, r3, #0x1f
;  add r1,r3
10001dce: 4419         	add	r1, r3
;  pop {r4-r7,r15}
10001dd0: bdf0         	pop	{r4, r5, r6, r7, pc}

10001dd2 <da_7>:
;  lsls r1,r3,#31
10001dd2: 07d9         	lsls	r1, r3, #0x1f
;  ldr r3,=0x7ff00000
10001dd4: 4b20         	ldr	r3, [pc, #0x80]         @ 0x10001e58 <da_xmgty+0x4>
;  orrs r1,r3
10001dd6: 4319         	orrs	r1, r3
;  b 1f
10001dd8: e000         	b	0x10001ddc <da_6+0x2>   @ imm = #0x0

10001dda <da_6>:
;  lsls r1,r3,#31
10001dda: 07d9         	lsls	r1, r3, #0x1f
;  movs r0,#0
10001ddc: 2000         	movs	r0, #0x0
;  pop {r4-r7,r15}
10001dde: bdf0         	pop	{r4, r5, r6, r7, pc}

10001de0 <da_5>:
;  cmp r1,#0
10001de0: 2900         	cmp	r1, #0x0
;  bne da_2
10001de2: d1dd         	bne	0x10001da0 <da_2>       @ imm = #-0x46
;  cmp r4,#0
10001de4: 2c00         	cmp	r4, #0x0
;  bne da_2
10001de6: d1db         	bne	0x10001da0 <da_2>       @ imm = #-0x4a
;  pop {r4-r7,r15}
10001de8: bdf0         	pop	{r4, r5, r6, r7, pc}

10001dea <da_0>:
;  adds r2,#1                    @ adjust exponent
10001dea: 3201         	adds	r2, #0x1
;  lsls r6,r0,#31                @ save rounding bit
10001dec: 07c6         	lsls	r6, r0, #0x1f
;  lsrs r0,#1
10001dee: 0840         	lsrs	r0, r0, #0x1
;  lsls r5,r1,#31
10001df0: 07cd         	lsls	r5, r1, #0x1f
;  orrs r0,r5
10001df2: 4328         	orrs	r0, r5
;  lsrs r1,#1
10001df4: 0849         	lsrs	r1, r1, #0x1
;  cmp r6,#0
10001df6: 2e00         	cmp	r6, #0x0
;  beq da_3
10001df8: d0e1         	beq	0x10001dbe <da_3>       @ imm = #-0x3e
;  b da_4
10001dfa: e7d9         	b	0x10001db0 <da_4>       @ imm = #-0x4e

10001dfc <da_xrgty>:
;  cmp r6,#60
10001dfc: 2e3c         	cmp	r6, #0x3c
;  bge da_xmgty                  @ xe much greater than ye?
10001dfe: da29         	bge	0x10001e54 <da_xmgty>   @ imm = #0x52
;  subs r6,#32
10001e00: 3e20         	subs	r6, #0x20
;  adds r7,#64
10001e02: 3740         	adds	r7, #0x40
;  movs r4,r2
10001e04: 0014         	movs	r4, r2
;  lsls r4,r4,r7                 @ these would be shifted off the bottom of the sticky bits
10001e06: 40bc         	lsls	r4, r7
;  beq 1f
10001e08: d000         	beq	0x10001e0c <da_xrgty+0x10> @ imm = #0x0
;  movs r4,#1
10001e0a: 2401         	movs	r4, #0x1
;  lsrs r2,r2,r6
10001e0c: 40f2         	lsrs	r2, r6
;  orrs r4,r2
10001e0e: 4314         	orrs	r4, r2
;  movs r2,r3
10001e10: 001a         	movs	r2, r3
;  lsls r3,r3,r7
10001e12: 40bb         	lsls	r3, r7
;  orrs r4,r3
10001e14: 431c         	orrs	r4, r3
;  asrs r3,r2,#31                @ propagate sign bit
10001e16: 17d3         	asrs	r3, r2, #0x1f
;  b da_xgty0
10001e18: e7ac         	b	0x10001d74 <da_xgty0>   @ imm = #-0xa8

10001e1a <da_ygtx>:
;  mov r12,r5                    @ save exponent
10001e1a: 46ac         	mov	r12, r5
;  cmp r7,#32
10001e1c: 2f20         	cmp	r7, #0x20
;  bge da_yrgtx                  @ ye rather greater than xe?
10001e1e: da08         	bge	0x10001e32 <da_yrgtx>   @ imm = #0x10
;  adds r6,#32
10001e20: 3620         	adds	r6, #0x20
;  movs r4,r0
10001e22: 0004         	movs	r4, r0
;  lsls r4,r4,r6                 @ rounding bit + sticky bits
10001e24: 40b4         	lsls	r4, r6

10001e26 <da_ygtx0>:
;  movs r5,r1
10001e26: 000d         	movs	r5, r1
;  lsls r5,r5,r6
10001e28: 40b5         	lsls	r5, r6
;  lsrs r0,r7
10001e2a: 40f8         	lsrs	r0, r7
;  asrs r1,r7
10001e2c: 4139         	asrs	r1, r7
;  orrs r0,r5
10001e2e: 4328         	orrs	r0, r5
;  b da_add
10001e30: e7a5         	b	0x10001d7e <da_add>     @ imm = #-0xb6

10001e32 <da_yrgtx>:
;  cmp r7,#60
10001e32: 2f3c         	cmp	r7, #0x3c
;  bge da_ymgtx                  @ ye much greater than xe?
10001e34: da0c         	bge	0x10001e50 <da_ymgtx>   @ imm = #0x18
;  subs r7,#32
10001e36: 3f20         	subs	r7, #0x20
;  adds r6,#64
10001e38: 3640         	adds	r6, #0x40
;  movs r4,r0
10001e3a: 0004         	movs	r4, r0
;  lsls r4,r4,r6                 @ these would be shifted off the bottom of the sticky bits
10001e3c: 40b4         	lsls	r4, r6
;  beq 1f
10001e3e: d000         	beq	0x10001e42 <da_yrgtx+0x10> @ imm = #0x0
;  movs r4,#1
10001e40: 2401         	movs	r4, #0x1
;  lsrs r0,r0,r7
10001e42: 40f8         	lsrs	r0, r7
;  orrs r4,r0
10001e44: 4304         	orrs	r4, r0
;  movs r0,r1
10001e46: 0008         	movs	r0, r1
;  lsls r1,r1,r6
10001e48: 40b1         	lsls	r1, r6
;  orrs r4,r1
10001e4a: 430c         	orrs	r4, r1
;  asrs r1,r0,#31                @ propagate sign bit
10001e4c: 17c1         	asrs	r1, r0, #0x1f
;  b da_ygtx0
10001e4e: e7ea         	b	0x10001e26 <da_ygtx0>   @ imm = #-0x2c

10001e50 <da_ymgtx>:
;  movs r0,r2
10001e50: 0010         	movs	r0, r2
;  movs r1,r3
10001e52: 0019         	movs	r1, r3

10001e54 <da_xmgty>:
;  movs r4,#0                    @ clear sticky bits
10001e54: 2400         	movs	r4, #0x0
;  b da_pack
10001e56: e794         	b	0x10001d82 <da_pack>    @ imm = #-0xd8
10001e58: 00 00 f0 7f  	.word	0x7ff00000

10001e5c <dmul_shim>:
;  push {r4-r7,r14}
10001e5c: b5f0         	push	{r4, r5, r6, r7, lr}
;  mdunpack r0,r1,r4,r6,r5
10001e5e: 0d0c         	lsrs	r4, r1, #0x14
10001e60: 1e66         	subs	r6, r4, #0x1
10001e62: 0536         	lsls	r6, r6, #0x14
10001e64: 1b89         	subs	r1, r1, r6
10001e66: 0ae6         	lsrs	r6, r4, #0xb
10001e68: 0564         	lsls	r4, r4, #0x15
10001e6a: 0d64         	lsrs	r4, r4, #0x15
10001e6c: d002         	beq	0x10001e74 <l12_1>      @ imm = #0x4
10001e6e: 1c65         	adds	r5, r4, #0x1
10001e70: 0aed         	lsrs	r5, r5, #0xb
10001e72: d004         	beq	0x10001e7e <l12_2>      @ imm = #0x8

10001e74 <l12_1>:
10001e74: 2000         	movs	r0, #0x0
10001e76: 2101         	movs	r1, #0x1
10001e78: 0509         	lsls	r1, r1, #0x14
10001e7a: 3c80         	subs	r4, #0x80
10001e7c: 0324         	lsls	r4, r4, #0xc

10001e7e <l12_2>:
;  mov r12,r4
10001e7e: 46a4         	mov	r12, r4
;  mdunpack r2,r3,r4,r7,r5
10001e80: 0d1c         	lsrs	r4, r3, #0x14
10001e82: 1e67         	subs	r7, r4, #0x1
10001e84: 053f         	lsls	r7, r7, #0x14
10001e86: 1bdb         	subs	r3, r3, r7
10001e88: 0ae7         	lsrs	r7, r4, #0xb
10001e8a: 0564         	lsls	r4, r4, #0x15
10001e8c: 0d64         	lsrs	r4, r4, #0x15
10001e8e: d002         	beq	0x10001e96 <l13_1>      @ imm = #0x4
10001e90: 1c65         	adds	r5, r4, #0x1
10001e92: 0aed         	lsrs	r5, r5, #0xb
10001e94: d004         	beq	0x10001ea0 <l13_2>      @ imm = #0x8

10001e96 <l13_1>:
10001e96: 2200         	movs	r2, #0x0
10001e98: 2301         	movs	r3, #0x1
10001e9a: 051b         	lsls	r3, r3, #0x14
10001e9c: 3c80         	subs	r4, #0x80
10001e9e: 0324         	lsls	r4, r4, #0xc

10001ea0 <l13_2>:
;  eors r7,r6                    @ sign of result
10001ea0: 4077         	eors	r7, r6
;  add r4,r12                    @ exponent of result
10001ea2: 4464         	add	r4, r12
;  push {r0-r2,r4,r7}
10001ea4: b497         	push	{r0, r1, r2, r4, r7}
;  mul32_32_64 r0,r2, r0,r5, r4,r6,r7,r0,r5    @ XL*YL
10001ea6: b284         	uxth	r4, r0
10001ea8: b296         	uxth	r6, r2
10001eaa: 4374         	muls	r4, r6, r4
10001eac: 0c07         	lsrs	r7, r0, #0x10
10001eae: 437e         	muls	r6, r7, r6
10001eb0: 0c15         	lsrs	r5, r2, #0x10
10001eb2: 436f         	muls	r7, r5, r7
10001eb4: b280         	uxth	r0, r0
10001eb6: 4368         	muls	r0, r5, r0
10001eb8: 1836         	adds	r6, r6, r0
10001eba: d302         	blo	0x10001ec2 <l14_1>      @ imm = #0x4
10001ebc: 2001         	movs	r0, #0x1
10001ebe: 0400         	lsls	r0, r0, #0x10
10001ec0: 183f         	adds	r7, r7, r0

10001ec2 <l14_1>:
10001ec2: 0430         	lsls	r0, r6, #0x10
10001ec4: 0c35         	lsrs	r5, r6, #0x10
10001ec6: 1900         	adds	r0, r0, r4
10001ec8: 417d         	adcs	r5, r7
;  mov r12,r0                    @ save LL bits
10001eca: 4684         	mov	r12, r0
;  mul32_32_64 r1,r3, r6,r7, r0,r2,r4,r6,r7    @ XH*YH
10001ecc: b288         	uxth	r0, r1
10001ece: b29a         	uxth	r2, r3
10001ed0: 4350         	muls	r0, r2, r0
10001ed2: 0c0c         	lsrs	r4, r1, #0x10
10001ed4: 4362         	muls	r2, r4, r2
10001ed6: 0c1f         	lsrs	r7, r3, #0x10
10001ed8: 437c         	muls	r4, r7, r4
10001eda: b28e         	uxth	r6, r1
10001edc: 437e         	muls	r6, r7, r6
10001ede: 1992         	adds	r2, r2, r6
10001ee0: d302         	blo	0x10001ee8 <l15_1>      @ imm = #0x4
10001ee2: 2601         	movs	r6, #0x1
10001ee4: 0436         	lsls	r6, r6, #0x10
10001ee6: 19a4         	adds	r4, r4, r6

10001ee8 <l15_1>:
10001ee8: 0416         	lsls	r6, r2, #0x10
10001eea: 0c17         	lsrs	r7, r2, #0x10
10001eec: 1836         	adds	r6, r6, r0
10001eee: 4167         	adcs	r7, r4
;  pop {r0}                      @ XL
10001ef0: bc01         	pop	{r0}
;  mul32_32_64 r0,r3, r0,r3, r1,r2,r4,r0,r3    @ XL*YH
10001ef2: b281         	uxth	r1, r0
10001ef4: b29a         	uxth	r2, r3
10001ef6: 4351         	muls	r1, r2, r1
10001ef8: 0c04         	lsrs	r4, r0, #0x10
10001efa: 4362         	muls	r2, r4, r2
10001efc: 0c1b         	lsrs	r3, r3, #0x10
10001efe: 435c         	muls	r4, r3, r4
10001f00: b280         	uxth	r0, r0
10001f02: 4358         	muls	r0, r3, r0
10001f04: 1812         	adds	r2, r2, r0
10001f06: d302         	blo	0x10001f0e <l16_1>      @ imm = #0x4
10001f08: 2001         	movs	r0, #0x1
10001f0a: 0400         	lsls	r0, r0, #0x10
10001f0c: 1824         	adds	r4, r4, r0

10001f0e <l16_1>:
10001f0e: 0410         	lsls	r0, r2, #0x10
10001f10: 0c13         	lsrs	r3, r2, #0x10
10001f12: 1840         	adds	r0, r0, r1
10001f14: 4163         	adcs	r3, r4
;  adds r5,r0
10001f16: 182d         	adds	r5, r5, r0
;  adcs r6,r3
10001f18: 415e         	adcs	r6, r3
;  movs r0,#0
10001f1a: 2000         	movs	r0, #0x0
;  adcs r7,r0
10001f1c: 4147         	adcs	r7, r0
;  pop {r1,r2}                   @ XH,YL
10001f1e: bc06         	pop	{r1, r2}
;  mul32_32_64 r1,r2, r1,r2, r0,r3,r4, r1,r2   @ XH*YL
10001f20: b288         	uxth	r0, r1
10001f22: b293         	uxth	r3, r2
10001f24: 4358         	muls	r0, r3, r0
10001f26: 0c0c         	lsrs	r4, r1, #0x10
10001f28: 4363         	muls	r3, r4, r3
10001f2a: 0c12         	lsrs	r2, r2, #0x10
10001f2c: 4354         	muls	r4, r2, r4
10001f2e: b289         	uxth	r1, r1
10001f30: 4351         	muls	r1, r2, r1
10001f32: 185b         	adds	r3, r3, r1
10001f34: d302         	blo	0x10001f3c <l17_1>      @ imm = #0x4
10001f36: 2101         	movs	r1, #0x1
10001f38: 0409         	lsls	r1, r1, #0x10
10001f3a: 1864         	adds	r4, r4, r1

10001f3c <l17_1>:
10001f3c: 0419         	lsls	r1, r3, #0x10
10001f3e: 0c1a         	lsrs	r2, r3, #0x10
10001f40: 1809         	adds	r1, r1, r0
10001f42: 4162         	adcs	r2, r4
;  adds r5,r1
10001f44: 186d         	adds	r5, r5, r1
;  adcs r6,r2
10001f46: 4156         	adcs	r6, r2
;  movs r0,#0
10001f48: 2000         	movs	r0, #0x0
;  adcs r7,r0
10001f4a: 4147         	adcs	r7, r0
;  pop {r3,r4}                   @ exponent in r3, sign in r4
10001f4c: bc18         	pop	{r3, r4}
;  lsls r1,r7,#11
10001f4e: 02f9         	lsls	r1, r7, #0xb
;  lsrs r2,r6,#21
10001f50: 0d72         	lsrs	r2, r6, #0x15
;  orrs r1,r2
10001f52: 4311         	orrs	r1, r2
;  lsls r0,r6,#11
10001f54: 02f0         	lsls	r0, r6, #0xb
;  lsrs r2,r5,#21
10001f56: 0d6a         	lsrs	r2, r5, #0x15
;  orrs r0,r2
10001f58: 4310         	orrs	r0, r2
;  lsls r5,#11                   @ now r5:r0:r1 Q83=Q(51+32), extra LSBs in r12
10001f5a: 02ed         	lsls	r5, r5, #0xb
;  lsrs r2,r1,#20
10001f5c: 0d0a         	lsrs	r2, r1, #0x14
;  bne 1f                        @ skip if in range [2..4)
10001f5e: d103         	bne	0x10001f68 <l17_1+0x2c> @ imm = #0x6
;  adds r5,r5                    @ shift up so always [2..4) Q83, i.e. [1..2) Q84=Q(52+32)
10001f60: 196d         	adds	r5, r5, r5
;  adcs r0,r0
10001f62: 4140         	adcs	r0, r0
;  adcs r1,r1
10001f64: 4149         	adcs	r1, r1
;  subs r3,#1                    @ correct exponent
10001f66: 3b01         	subs	r3, #0x1
;  ldr r6,=0x3ff
10001f68: 4e12         	ldr	r6, [pc, #0x48]         @ 0x10001fb4 <dm_1+0xa>
;  subs r3,r6                    @ correct for exponent bias
10001f6a: 1b9b         	subs	r3, r3, r6
;  lsls r6,#1                    @ 0x7fe
10001f6c: 0076         	lsls	r6, r6, #0x1
;  cmp r3,r6
10001f6e: 42b3         	cmp	r3, r6
;  bhs dm_0                      @ exponent over- or underflow
10001f70: d20e         	bhs	0x10001f90 <dm_0>       @ imm = #0x1c
;  lsls r5,#1                    @ rounding bit to carry
10001f72: 006d         	lsls	r5, r5, #0x1
;  bcc 1f                        @ result is correctly rounded
10001f74: d307         	blo	0x10001f86 <l17_1+0x4a> @ imm = #0xe
;  adds r0,#1
10001f76: 3001         	adds	r0, #0x1
;  movs r6,#0
10001f78: 2600         	movs	r6, #0x0
;  adcs r1,r6                    @ round up
10001f7a: 4171         	adcs	r1, r6
;  mov r6,r12                    @ remaining sticky bits
10001f7c: 4666         	mov	r6, r12
;  orrs r5,r6
10001f7e: 4335         	orrs	r5, r6
;  bne 1f                        @ some sticky bits set?
10001f80: d101         	bne	0x10001f86 <l17_1+0x4a> @ imm = #0x2
;  lsrs r0,#1
10001f82: 0840         	lsrs	r0, r0, #0x1
;  lsls r0,#1                    @ round to even
10001f84: 0040         	lsls	r0, r0, #0x1
;  lsls r3,#20
10001f86: 051b         	lsls	r3, r3, #0x14
;  adds r1,r3
10001f88: 18c9         	adds	r1, r1, r3

10001f8a <dm_2>:
;  lsls r4,#31
10001f8a: 07e4         	lsls	r4, r4, #0x1f
;  add r1,r4
10001f8c: 4421         	add	r1, r4
;  pop {r4-r7,r15}
10001f8e: bdf0         	pop	{r4, r5, r6, r7, pc}

10001f90 <dm_0>:
;  bge dm_1                      @ overflow?
10001f90: da0b         	bge	0x10001faa <dm_1>       @ imm = #0x16
;  adds r3,#1                    @ would-be zero exponent?
10001f92: 3301         	adds	r3, #0x1
;  bne 1f
10001f94: d106         	bne	0x10001fa4 <dm_0+0x14>  @ imm = #0xc
;  adds r0,#1
10001f96: 3001         	adds	r0, #0x1
;  bne 1f                        @ all-ones mantissa?
10001f98: d104         	bne	0x10001fa4 <dm_0+0x14>  @ imm = #0x8
;  adds r1,#1
10001f9a: 3101         	adds	r1, #0x1
;  lsrs r7,r1,#21
10001f9c: 0d4f         	lsrs	r7, r1, #0x15
;  beq 1f
10001f9e: d001         	beq	0x10001fa4 <dm_0+0x14>  @ imm = #0x2
;  lsrs r1,#1
10001fa0: 0849         	lsrs	r1, r1, #0x1
;  b dm_2
10001fa2: e7f2         	b	0x10001f8a <dm_2>       @ imm = #-0x1c
;  lsls r1,r4,#31
10001fa4: 07e1         	lsls	r1, r4, #0x1f
;  movs r0,#0
10001fa6: 2000         	movs	r0, #0x0
;  pop {r4-r7,r15}
10001fa8: bdf0         	pop	{r4, r5, r6, r7, pc}

10001faa <dm_1>:
;  adds r6,#1                    @ 0x7ff
10001faa: 3601         	adds	r6, #0x1
;  lsls r1,r6,#20
10001fac: 0531         	lsls	r1, r6, #0x14
;  movs r0,#0
10001fae: 2000         	movs	r0, #0x0
;  b dm_2
10001fb0: e7eb         	b	0x10001f8a <dm_2>       @ imm = #-0x2a
10001fb2: 00 00        	.short	0x0000
10001fb4: ff 03 00 00  	.word	0x000003ff

10001fb8 <ddiv_shim>:
;  push {r4-r7,r14}
10001fb8: b5f0         	push	{r4, r5, r6, r7, lr}

10001fba <ddiv0>:
;  mdunpack r2,r3,r4,r7,r6       @ unpack divisor
10001fba: 0d1c         	lsrs	r4, r3, #0x14
10001fbc: 1e67         	subs	r7, r4, #0x1
10001fbe: 053f         	lsls	r7, r7, #0x14
10001fc0: 1bdb         	subs	r3, r3, r7
10001fc2: 0ae7         	lsrs	r7, r4, #0xb
10001fc4: 0564         	lsls	r4, r4, #0x15
10001fc6: 0d64         	lsrs	r4, r4, #0x15
10001fc8: d002         	beq	0x10001fd0 <l20_1>      @ imm = #0x4
10001fca: 1c66         	adds	r6, r4, #0x1
10001fcc: 0af6         	lsrs	r6, r6, #0xb
10001fce: d004         	beq	0x10001fda <l20_2>      @ imm = #0x8

10001fd0 <l20_1>:
10001fd0: 2200         	movs	r2, #0x0
10001fd2: 2301         	movs	r3, #0x1
10001fd4: 051b         	lsls	r3, r3, #0x14
10001fd6: 3c80         	subs	r4, #0x80
10001fd8: 0324         	lsls	r4, r4, #0xc

10001fda <l20_2>:
;  movs r5,#IOPORT>>24
10001fda: 25d0         	movs	r5, #0xd0
;  lsls r5,#24
10001fdc: 062d         	lsls	r5, r5, #0x18
;  movs r6,#0
10001fde: 2600         	movs	r6, #0x0
;  mvns r6,r6
10001fe0: 43f6         	mvns	r6, r6
;  str r6,[r5,#DIV_UDIVIDEND]
10001fe2: 662e         	str	r6, [r5, #0x60]
;  lsrs r6,r3,#4                 @ x0=(q16)x
10001fe4: 091e         	lsrs	r6, r3, #0x4
;  str r6,[r5,#DIV_UDIVISOR]
10001fe6: 666e         	str	r6, [r5, #0x64]
;  lsrs r6,r1,#31
10001fe8: 0fce         	lsrs	r6, r1, #0x1f
;  adds r6,r7
10001fea: 19f6         	adds	r6, r6, r7
;  mov r12,r6                    @ result sign in r12b0; r12b1 trashed
10001fec: 46b4         	mov	r12, r6
;  lsls r1,#1
10001fee: 0049         	lsls	r1, r1, #0x1
;  lsrs r7,r1,#21                @ exponent
10001ff0: 0d4f         	lsrs	r7, r1, #0x15
;  beq 1f                        @ zero exponent?
10001ff2: d002         	beq	0x10001ffa <l20_2+0x20> @ imm = #0x4
;  adds r6,r7,#1
10001ff4: 1c7e         	adds	r6, r7, #0x1
;  lsrs r6,#11
10001ff6: 0af6         	lsrs	r6, r6, #0xb
;  beq 2f                        @ exponent != 0x7ff? then done
10001ff8: d003         	beq	0x10002002 <l20_2+0x28> @ imm = #0x6
;  movs r0,#0
10001ffa: 2000         	movs	r0, #0x0
;  movs r1,#0
10001ffc: 2100         	movs	r1, #0x0
;  subs r7,#64                   @ less drastic fiddling of exponents to get 0/0, Inf/Inf correct
10001ffe: 3f40         	subs	r7, #0x40
;  lsls r7,#12
10002000: 033f         	lsls	r7, r7, #0xc
;  subs r6,r7,r4
10002002: 1b3e         	subs	r6, r7, r4
;  lsls r6,#2
10002004: 00b6         	lsls	r6, r6, #0x2
;  add r12,r12,r6                @ (signed) exponent in r12[31..8]
10002006: 44b4         	add	r12, r6
;  subs r7,#1                    @ implied 1
10002008: 3f01         	subs	r7, #0x1
;  lsls r7,#21
1000200a: 057f         	lsls	r7, r7, #0x15
;  subs r1,r7
1000200c: 1bc9         	subs	r1, r1, r7
;  lsrs r1,#1
1000200e: 0849         	lsrs	r1, r1, #0x1
;  ldr r6,[r5,#DIV_QUOTIENT]
10002010: 6f2e         	ldr	r6, [r5, #0x70]
;  adds r6,#1
10002012: 3601         	adds	r6, #0x1
;  lsrs r6,#1
10002014: 0876         	lsrs	r6, r6, #0x1
;  lsls r4,r3,#10
10002016: 029c         	lsls	r4, r3, #0xa
;  lsrs r5,r2,#22
10002018: 0d95         	lsrs	r5, r2, #0x16
;  orrs r5,r4                    @ x1=(q30)x
1000201a: 4325         	orrs	r5, r4
;  muls r5,r6                    @ u0*x1 Q45
1000201c: 4375         	muls	r5, r6, r5
;  asrs r5,#15                   @ v=u0*x1-1 Q30
1000201e: 13ed         	asrs	r5, r5, #0xf
;  muls r5,r6                    @ u0*v Q45
10002020: 4375         	muls	r5, r6, r5
;  asrs r5,#14
10002022: 13ad         	asrs	r5, r5, #0xe
;  adds r5,#1
10002024: 3501         	adds	r5, #0x1
;  asrs r5,#1                    @ round u0*v to Q30
10002026: 106d         	asrs	r5, r5, #0x1
;  lsls r6,#15
10002028: 03f6         	lsls	r6, r6, #0xf
;  subs r6,r5                    @ u1 Q30
1000202a: 1b76         	subs	r6, r6, r5
;  push {r2,r3}
1000202c: b40c         	push	{r2, r3}
;  lsls r4,r1,#11
1000202e: 02cc         	lsls	r4, r1, #0xb
;  lsrs r5,r0,#21
10002030: 0d45         	lsrs	r5, r0, #0x15
;  orrs r4,r5                    @ y0=(q31)y
10002032: 432c         	orrs	r4, r5
;  mul32_32_64 r4,r6, r4,r5, r2,r3,r7,r4,r5  @ y0*u1 Q61
10002034: b2a2         	uxth	r2, r4
10002036: b2b3         	uxth	r3, r6
10002038: 435a         	muls	r2, r3, r2
1000203a: 0c27         	lsrs	r7, r4, #0x10
1000203c: 437b         	muls	r3, r7, r3
1000203e: 0c35         	lsrs	r5, r6, #0x10
10002040: 436f         	muls	r7, r5, r7
10002042: b2a4         	uxth	r4, r4
10002044: 436c         	muls	r4, r5, r4
10002046: 191b         	adds	r3, r3, r4
10002048: d302         	blo	0x10002050 <l21_1>      @ imm = #0x4
1000204a: 2401         	movs	r4, #0x1
1000204c: 0424         	lsls	r4, r4, #0x10
1000204e: 193f         	adds	r7, r7, r4

10002050 <l21_1>:
10002050: 041c         	lsls	r4, r3, #0x10
10002052: 0c1d         	lsrs	r5, r3, #0x10
10002054: 18a4         	adds	r4, r4, r2
10002056: 417d         	adcs	r5, r7
;  adds r4,r4
10002058: 1924         	adds	r4, r4, r4
;  adcs r5,r5                    @ a0=(q30)(y0*u1)
1000205a: 416d         	adcs	r5, r5
;  ldr r2,[r13,#0]               @ xL
1000205c: 9a00         	ldr	r2, [sp]
;  mul32_32_64 r2,r5, r2,r3, r1,r4,r7,r2,r3  @ xL*a0
1000205e: b291         	uxth	r1, r2
10002060: b2ac         	uxth	r4, r5
10002062: 4361         	muls	r1, r4, r1
10002064: 0c17         	lsrs	r7, r2, #0x10
10002066: 437c         	muls	r4, r7, r4
10002068: 0c2b         	lsrs	r3, r5, #0x10
1000206a: 435f         	muls	r7, r3, r7
1000206c: b292         	uxth	r2, r2
1000206e: 435a         	muls	r2, r3, r2
10002070: 18a4         	adds	r4, r4, r2
10002072: d302         	blo	0x1000207a <l22_1>      @ imm = #0x4
10002074: 2201         	movs	r2, #0x1
10002076: 0412         	lsls	r2, r2, #0x10
10002078: 18bf         	adds	r7, r7, r2

1000207a <l22_1>:
1000207a: 0422         	lsls	r2, r4, #0x10
1000207c: 0c23         	lsrs	r3, r4, #0x10
1000207e: 1852         	adds	r2, r2, r1
10002080: 417b         	adcs	r3, r7
;  ldr r4,[r13,#4]               @ xH
10002082: 9c01         	ldr	r4, [sp, #0x4]
;  muls r4,r5                    @ xH*a0
10002084: 436c         	muls	r4, r5, r4
;  adds r3,r4                    @ r2:r3 now x*a0 Q82
10002086: 191b         	adds	r3, r3, r4
;  lsrs r2,#25
10002088: 0e52         	lsrs	r2, r2, #0x19
;  lsls r1,r3,#7
1000208a: 01d9         	lsls	r1, r3, #0x7
;  orrs r2,r1                    @ r2 now x*a0 Q57; r7:r2 is x*a0 Q89
1000208c: 430a         	orrs	r2, r1
;  lsls r4,r0,#5                 @ y Q57
1000208e: 0144         	lsls	r4, r0, #0x5
;  subs r0,r4,r2                 @ r0x=y-x*a0 Q57 (signed)
10002090: 1aa0         	subs	r0, r4, r2
;  muls32_32_64 r0,r6, r7,r6, r1,r2,r3, r7,r6   @ r7:r6 r0x*u1 Q87
10002092: b281         	uxth	r1, r0
10002094: b2b2         	uxth	r2, r6
10002096: 4351         	muls	r1, r2, r1
10002098: 1403         	asrs	r3, r0, #0x10
1000209a: 435a         	muls	r2, r3, r2
1000209c: 0c36         	lsrs	r6, r6, #0x10
1000209e: 4373         	muls	r3, r6, r3
100020a0: b287         	uxth	r7, r0
100020a2: 4377         	muls	r7, r6, r7
100020a4: 17d6         	asrs	r6, r2, #0x1f
100020a6: 19d2         	adds	r2, r2, r7
100020a8: 2700         	movs	r7, #0x0
100020aa: 417e         	adcs	r6, r7
100020ac: 0436         	lsls	r6, r6, #0x10
100020ae: 199b         	adds	r3, r3, r6
100020b0: 0417         	lsls	r7, r2, #0x10
100020b2: 0c16         	lsrs	r6, r2, #0x10
100020b4: 187f         	adds	r7, r7, r1
100020b6: 415e         	adcs	r6, r3
;  asrs r3,r6,#25
100020b8: 1673         	asrs	r3, r6, #0x19
;  adds r5,r3
100020ba: 18ed         	adds	r5, r5, r3
;  lsls r3,r6,#7                 @ r3:r5 a1 Q62 (but bottom 7 bits are zero so 55 bits of precision after binary point)
100020bc: 01f3         	lsls	r3, r6, #0x7
;  movs r6,#0
100020be: 2600         	movs	r6, #0x0
;  adds r3,#128                  @ for initial rounding to Q53
100020c0: 3380         	adds	r3, #0x80
;  adcs r5,r5,r6
100020c2: 4175         	adcs	r5, r6
;  lsrs  r1,r5,#30
100020c4: 0fa9         	lsrs	r1, r5, #0x1e
;  bne dd_0
100020c6: d106         	bne	0x100020d6 <dd_0>       @ imm = #0xc
;  lsls r4,#1                    @ y now Q58
100020c8: 0064         	lsls	r4, r4, #0x1
;  lsrs r1,r5,#9                 @ to Q52
100020ca: 0a69         	lsrs	r1, r5, #0x9
;  lsls r0,r5,#23
100020cc: 05e8         	lsls	r0, r5, #0x17
;  lsrs r3,#9                    @ 0.5ulp-significance bit in carry: if this is 1 we may need to correct result
100020ce: 0a5b         	lsrs	r3, r3, #0x9
;  orrs r0,r3
100020d0: 4318         	orrs	r0, r3
;  bcs dd_1
100020d2: d209         	bhs	0x100020e8 <dd_1>       @ imm = #0x12
;  b dd_2
100020d4: e02f         	b	0x10002136 <dd_2>       @ imm = #0x5e

100020d6 <dd_0>:
;  movs r2,#4
100020d6: 2204         	movs	r2, #0x4
;  add r12,r12,r2                @ fix exponent; r3:r5 now effectively Q61
100020d8: 4494         	add	r12, r2
;  adds r3,#128                  @ complete rounding to Q53
100020da: 3380         	adds	r3, #0x80
;  adcs r5,r5,r6
100020dc: 4175         	adcs	r5, r6
;  lsrs r1,r5,#10
100020de: 0aa9         	lsrs	r1, r5, #0xa
;  lsls r0,r5,#22
100020e0: 05a8         	lsls	r0, r5, #0x16
;  lsrs r3,#10                   @ 0.5ulp-significance bit in carry: if this is 1 we may need to correct result
100020e2: 0a9b         	lsrs	r3, r3, #0xa
;  orrs r0,r3
100020e4: 4318         	orrs	r0, r3
;  bcc dd_2
100020e6: d326         	blo	0x10002136 <dd_2>       @ imm = #0x4c

100020e8 <dd_1>:
;  adcs r0,r0,r0
100020e8: 4140         	adcs	r0, r0
;  adcs r1,r1,r1                 @ z Q53 with 1 in LSB
100020ea: 4149         	adcs	r1, r1
;  lsls r4,#16                   @ Q105-32=Q73
100020ec: 0424         	lsls	r4, r4, #0x10
;  ldr r2,[r13,#0]               @ xL Q52
100020ee: 9a00         	ldr	r2, [sp]
;  ldr r3,[r13,#4]               @ xH Q20
100020f0: 9b01         	ldr	r3, [sp, #0x4]
;  movs r5,r1                    @ zH Q21
100020f2: 000d         	movs	r5, r1
;  muls r5,r2                    @ zH*xL Q73
100020f4: 4355         	muls	r5, r2, r5
;  subs r4,r5
100020f6: 1b64         	subs	r4, r4, r5
;  muls r3,r0                    @ zL*xH Q73
100020f8: 4343         	muls	r3, r0, r3
;  subs r4,r3
100020fa: 1ae4         	subs	r4, r4, r3
;  mul32_32_64 r2,r0, r2,r3, r5,r6,r7,r2,r3  @ xL*zL
100020fc: b295         	uxth	r5, r2
100020fe: b286         	uxth	r6, r0
10002100: 4375         	muls	r5, r6, r5
10002102: 0c17         	lsrs	r7, r2, #0x10
10002104: 437e         	muls	r6, r7, r6
10002106: 0c03         	lsrs	r3, r0, #0x10
10002108: 435f         	muls	r7, r3, r7
1000210a: b292         	uxth	r2, r2
1000210c: 435a         	muls	r2, r3, r2
1000210e: 18b6         	adds	r6, r6, r2
10002110: d302         	blo	0x10002118 <l24_1>      @ imm = #0x4
10002112: 2201         	movs	r2, #0x1
10002114: 0412         	lsls	r2, r2, #0x10
10002116: 18bf         	adds	r7, r7, r2

10002118 <l24_1>:
10002118: 0432         	lsls	r2, r6, #0x10
1000211a: 0c33         	lsrs	r3, r6, #0x10
1000211c: 1952         	adds	r2, r2, r5
1000211e: 417b         	adcs	r3, r7
;  negs r2,r2                    @ borrow from low half?
10002120: 4252         	rsbs	r2, r2, #0
;  sbcs r4,r3                    @ y-xz Q73 (remainder bits 52..73)
10002122: 419c         	sbcs	r4, r3
;  cmp r4,#0
10002124: 2c00         	cmp	r4, #0x0
;  bmi 1f
10002126: d402         	bmi	0x1000212e <l24_1+0x16> @ imm = #0x4
;  movs r2,#0                    @ round up
10002128: 2200         	movs	r2, #0x0
;  adds r0,#1
1000212a: 3001         	adds	r0, #0x1
;  adcs r1,r2
1000212c: 4151         	adcs	r1, r2
;  lsrs r0,#1                    @ shift back down to Q52
1000212e: 0840         	lsrs	r0, r0, #0x1
;  lsls r2,r1,#31
10002130: 07ca         	lsls	r2, r1, #0x1f
;  orrs r0,r2
10002132: 4310         	orrs	r0, r2
;  lsrs r1,#1
10002134: 0849         	lsrs	r1, r1, #0x1

10002136 <dd_2>:
;  add r13,#8
10002136: b002         	add	sp, #0x8
;  mov r2,r12
10002138: 4662         	mov	r2, r12
;  lsls r7,r2,#31                @ result sign
1000213a: 07d7         	lsls	r7, r2, #0x1f
;  asrs r2,#2                    @ result exponent
1000213c: 1092         	asrs	r2, r2, #0x2
;  ldr r3,=0x3fd
1000213e: 4b08         	ldr	r3, [pc, #0x20]         @ 0x10002160 <dd_4+0x6>
;  adds r2,r3
10002140: 18d2         	adds	r2, r2, r3
;  ldr r3,=0x7fe
10002142: 4b08         	ldr	r3, [pc, #0x20]         @ 0x10002164 <dd_4+0xa>
;  cmp r2,r3
10002144: 429a         	cmp	r2, r3
;  bhs dd_3                      @ over- or underflow?
10002146: d203         	bhs	0x10002150 <dd_3>       @ imm = #0x6
;  lsls r2,#20
10002148: 0512         	lsls	r2, r2, #0x14
;  adds r1,r2                    @ pack exponent
1000214a: 1889         	adds	r1, r1, r2

1000214c <dd_5>:
;  adds r1,r7                    @ pack sign
1000214c: 19c9         	adds	r1, r1, r7
;  pop {r4-r7,r15}
1000214e: bdf0         	pop	{r4, r5, r6, r7, pc}

10002150 <dd_3>:
;  movs r0,#0
10002150: 2000         	movs	r0, #0x0
;  cmp r2,#0
10002152: 2a00         	cmp	r2, #0x0
;  bgt dd_4                      @ overflow?
10002154: dc01         	bgt	0x1000215a <dd_4>       @ imm = #0x2
;  movs r1,r7
10002156: 0039         	movs	r1, r7
;  pop {r4-r7,r15}
10002158: bdf0         	pop	{r4, r5, r6, r7, pc}

1000215a <dd_4>:
;  adds r3,#1                    @ 0x7ff
1000215a: 3301         	adds	r3, #0x1
;  lsls r1,r3,#20
1000215c: 0519         	lsls	r1, r3, #0x14
;  b dd_5
1000215e: e7f5         	b	0x1000214c <dd_5>       @ imm = #-0x16
10002160: fd 03 00 00  	.word	0x000003fd
10002164: fe 07 00 00  	.word	0x000007fe

10002168 <double2uint_shim>:
;  movs r2,#0                    @ and fall through
10002168: 2200         	movs	r2, #0x0

1000216a <double2ufix_shim>:
;  push {r14}
1000216a: b500         	push	{lr}
;  adds r2,#32
1000216c: 3220         	adds	r2, #0x20
;  bl double2ufix64_shim
1000216e: f000 f804    	bl	0x1000217a <double2ufix64_shim> @ imm = #0x8
;  movs r0,r1
10002172: 0008         	movs	r0, r1
;  pop {r15}
10002174: bd00         	pop	{pc}
10002176: 0000         	movs	r0, r0

10002178 <double2uint64_shim>:
;  movs r2,#0                    @ and fall through
10002178: 2200         	movs	r2, #0x0

1000217a <double2ufix64_shim>:
;  asrs r3,r1,#20                @ negative? return 0
1000217a: 150b         	asrs	r3, r1, #0x14
;  bmi ret_dzero
1000217c: d40a         	bmi	0x10002194 <ret_dzero>  @ imm = #0x14

1000217e <d2fix>:
;  push {r4,r14}
1000217e: b510         	push	{r4, lr}
;  mov r12,r2
10002180: 4694         	mov	r12, r2
;  bl dunpacks
10002182: f000 f831    	bl	0x100021e8 <dunpacks>   @ imm = #0x62
;  asrs r4,r2,#16
10002186: 1414         	asrs	r4, r2, #0x10
;  adds r4,#1
10002188: 3401         	adds	r4, #0x1
;  bge 1f
1000218a: da00         	bge	0x1000218e <d2fix+0x10> @ imm = #0x0
;  movs r1,#0                    @ -0 -> +0
1000218c: 2100         	movs	r1, #0x0
;  asrs r3,r1,#31
1000218e: 17cb         	asrs	r3, r1, #0x1f
;  ldr r4, =d2fix_a
10002190: 4c14         	ldr	r4, [pc, #0x50]         @ 0x100021e4 <d2fix_a+0x4a>
;  bx r4
10002192: 4720         	bx	r4

10002194 <ret_dzero>:
;  movs r0,#0
10002194: 2000         	movs	r0, #0x0
;  movs r1,#0
10002196: 2100         	movs	r1, #0x0
;  bx r14
10002198: 4770         	bx	lr

1000219a <d2fix_a>:
;  add r2,r12                    @ exponent plus offset for required binary point position
1000219a: 4462         	add	r2, r12
;  subs r2,#52                   @ required shift
1000219c: 3a34         	subs	r2, #0x34
;  bmi 1f                        @ shift down?
1000219e: d40c         	bmi	0x100021ba <d2fix_a+0x20> @ imm = #0x18
;  cmp r2,#12                    @ will clamp?
100021a0: 2a0c         	cmp	r2, #0xc
;  bge 2f
100021a2: da07         	bge	0x100021b4 <d2fix_a+0x1a> @ imm = #0xe
;  movs r4,r0
100021a4: 0004         	movs	r4, r0
;  lsls r1,r2
100021a6: 4091         	lsls	r1, r2
;  lsls r0,r2
100021a8: 4090         	lsls	r0, r2
;  negs r2,r2
100021aa: 4252         	rsbs	r2, r2, #0
;  adds r2,#32                   @ complementary shift
100021ac: 3220         	adds	r2, #0x20
;  lsrs r4,r2
100021ae: 40d4         	lsrs	r4, r2
;  orrs r1,r4
100021b0: 4321         	orrs	r1, r4
;  pop {r4,r15}
100021b2: bd10         	pop	{r4, pc}
;  mvns r0,r3
100021b4: 43d8         	mvns	r0, r3
;  mvns r1,r3                    @ overflow: clamp to extreme fixed-point values
100021b6: 43d9         	mvns	r1, r3
;  pop {r4,r15}
100021b8: bd10         	pop	{r4, pc}
;  adds r2,#32
100021ba: 3220         	adds	r2, #0x20
;  bmi 1f                        @ long shift?
100021bc: d407         	bmi	0x100021ce <d2fix_a+0x34> @ imm = #0xe
;  mov r4,r1
100021be: 460c         	mov	r4, r1
;  lsls r4,r2
100021c0: 4094         	lsls	r4, r2
;  negs r2,r2
100021c2: 4252         	rsbs	r2, r2, #0
;  adds r2,#32                   @ complementary shift
100021c4: 3220         	adds	r2, #0x20
;  asrs r1,r2
100021c6: 4111         	asrs	r1, r2
;  lsrs r0,r2
100021c8: 40d0         	lsrs	r0, r2
;  orrs r0,r4
100021ca: 4320         	orrs	r0, r4
;  pop {r4,r15}
100021cc: bd10         	pop	{r4, pc}
;  movs r0,r1
100021ce: 0008         	movs	r0, r1
;  asrs r1,#31                   @ shift down 32 places
100021d0: 17c9         	asrs	r1, r1, #0x1f
;  adds r2,#32
100021d2: 3220         	adds	r2, #0x20
;  bmi 1f                        @ very long shift?
100021d4: d403         	bmi	0x100021de <d2fix_a+0x44> @ imm = #0x6
;  negs r2,r2
100021d6: 4252         	rsbs	r2, r2, #0
;  adds r2,#32
100021d8: 3220         	adds	r2, #0x20
;  asrs r0,r2
100021da: 4110         	asrs	r0, r2
;  pop {r4,r15}
100021dc: bd10         	pop	{r4, pc}
;  movs r0,r3                    @ result very near zero: use sign extension bits
100021de: 0018         	movs	r0, r3
;  movs r1,r3
100021e0: 0019         	movs	r1, r3
;  pop {r4,r15}
100021e2: bd10         	pop	{r4, pc}
100021e4: 9b 21 00 10  	.word	0x1000219b

100021e8 <dunpacks>:
;  mdunpacks r0,r1,r2,r3,r4
100021e8: 0d0a         	lsrs	r2, r1, #0x14
100021ea: 0fcc         	lsrs	r4, r1, #0x1f
100021ec: 1e53         	subs	r3, r2, #0x1
100021ee: 051b         	lsls	r3, r3, #0x14
100021f0: 1ac9         	subs	r1, r1, r3
100021f2: 0552         	lsls	r2, r2, #0x15
100021f4: d303         	blo	0x100021fe <l60_1>      @ imm = #0x6
100021f6: 43c9         	mvns	r1, r1
100021f8: 4240         	rsbs	r0, r0, #0
100021fa: d300         	blo	0x100021fe <l60_1>      @ imm = #0x0
100021fc: 3101         	adds	r1, #0x1

100021fe <l60_1>:
100021fe: 0d52         	lsrs	r2, r2, #0x15
10002200: d003         	beq	0x1000220a <l60_2>      @ imm = #0x6
10002202: 1c53         	adds	r3, r2, #0x1
10002204: 0adb         	lsrs	r3, r3, #0xb
10002206: d007         	beq	0x10002218 <l60_3>      @ imm = #0xe
10002208: 1b12         	subs	r2, r2, r4

1000220a <l60_2>:
1000220a: 2000         	movs	r0, #0x0
1000220c: 0064         	lsls	r4, r4, #0x1
1000220e: 1c61         	adds	r1, r4, #0x1
10002210: 0789         	lsls	r1, r1, #0x1e
10002212: 1289         	asrs	r1, r1, #0xa
10002214: 3a80         	subs	r2, #0x80
10002216: 0312         	lsls	r2, r2, #0xc

10002218 <l60_3>:
;  ldr r3,=0x3ff
10002218: 4b01         	ldr	r3, [pc, #0x4]          @ 0x10002220 <l60_3+0x8>
;  subs r2,r3                    @ exponent without offset
1000221a: 1ad2         	subs	r2, r2, r3
;  bx r14
1000221c: 4770         	bx	lr
1000221e: 00 00        	.short	0x0000
10002220: ff 03 00 00  	.word	0x000003ff

10002224 <__wrap___aeabi_lmul>:
;     muls   r1, r2
10002224: 4351         	muls	r1, r2, r1
;     muls   r3, r0
10002226: 4343         	muls	r3, r0, r3
;     adds   r1, r3
10002228: 18c9         	adds	r1, r1, r3
;     mov    r12, r1
1000222a: 468c         	mov	r12, r1
;     lsrs   r1, r2, #16
1000222c: 0c11         	lsrs	r1, r2, #0x10
;     uxth   r3, r0
1000222e: b283         	uxth	r3, r0
;     muls   r3, r1
10002230: 434b         	muls	r3, r1, r3
;     push   {r4}
10002232: b410         	push	{r4}
;     lsrs   r4, r0, #16
10002234: 0c04         	lsrs	r4, r0, #0x10
;     muls   r1, r4
10002236: 4361         	muls	r1, r4, r1
;     uxth   r2, r2
10002238: b292         	uxth	r2, r2
;     uxth   r0, r0
1000223a: b280         	uxth	r0, r0
;     muls   r0, r2
1000223c: 4350         	muls	r0, r2, r0
;     muls   r2, r4
1000223e: 4362         	muls	r2, r4, r2
;     lsls   r4, r3, #16
10002240: 041c         	lsls	r4, r3, #0x10
;     lsrs   r3, #16
10002242: 0c1b         	lsrs	r3, r3, #0x10
;     adds   r0, r4
10002244: 1900         	adds	r0, r0, r4
;     pop    {r4}
10002246: bc10         	pop	{r4}
;     adcs   r1, r3
10002248: 4159         	adcs	r1, r3
;     lsls   r3, r2, #16
1000224a: 0413         	lsls	r3, r2, #0x10
;     lsrs   r2, #16
1000224c: 0c12         	lsrs	r2, r2, #0x10
;     adds   r0, r3
1000224e: 18c0         	adds	r0, r0, r3
;     adcs   r1, r2
10002250: 4151         	adcs	r1, r2
;     add    r1, r12
10002252: 4461         	add	r1, r12
;     bx lr
10002254: 4770         	bx	lr
10002256: 0000         	movs	r0, r0

10002258 <__wrap___aeabi_frsub>:
;     eors r0, r1
10002258: 4048         	eors	r0, r1
;     eors r1, r0
1000225a: 4041         	eors	r1, r0
;     eors r0, r1
1000225c: 4048         	eors	r0, r1

1000225e <__wrap___aeabi_fsub>:
;     table_tail_call SF_TABLE_FSUB
1000225e: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x10002298 <fdiv_fsub_nan_helper+0x6>
10002260: 685b         	ldr	r3, [r3, #0x4]
10002262: 4718         	bx	r3

10002264 <__wrap___aeabi_fadd>:
;     table_tail_call SF_TABLE_FADD
10002264: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x10002298 <fdiv_fsub_nan_helper+0x6>
10002266: 681b         	ldr	r3, [r3]
10002268: 4718         	bx	r3

1000226a <__wrap___aeabi_fdiv>:
;     ldr r2, =(SIO_BASE)
1000226a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x1000229c <fdiv_fsub_nan_helper+0xa>
;     ldr r3, [r2, #SIO_DIV_CSR_OFFSET]
1000226c: 6f93         	ldr	r3, [r2, #0x78]
;     lsrs r3, #SIO_DIV_CSR_DIRTY_SHIFT_FOR_CARRY
1000226e: 089b         	lsrs	r3, r3, #0x2
;     bcs fdiv_save_state
10002270: d202         	bhs	0x10002278 <fdiv_save_state> @ imm = #0x4

10002272 <fdiv_shim_call>:
;     table_tail_call SF_TABLE_FDIV
10002272: 4b09         	ldr	r3, [pc, #0x24]         @ 0x10002298 <fdiv_fsub_nan_helper+0x6>
10002274: 68db         	ldr	r3, [r3, #0xc]
10002276: 4718         	bx	r3

10002278 <fdiv_save_state>:
;     save_div_state_and_lr
10002278: b5f0         	push	{r4, r5, r6, r7, lr}
1000227a: 6e14         	ldr	r4, [r2, #0x60]
1000227c: 6e55         	ldr	r5, [r2, #0x64]
1000227e: 6f57         	ldr	r7, [r2, #0x74]
10002280: 6f16         	ldr	r6, [r2, #0x70]
;     bl fdiv_shim_call
10002282: f7ff fff6    	bl	0x10002272 <fdiv_shim_call> @ imm = #-0x14
;     ldr r2, =(SIO_BASE)
10002286: 4a05         	ldr	r2, [pc, #0x14]         @ 0x1000229c <fdiv_fsub_nan_helper+0xa>
;     restore_div_state_and_return
10002288: 6614         	str	r4, [r2, #0x60]
1000228a: 6655         	str	r5, [r2, #0x64]
1000228c: 6757         	str	r7, [r2, #0x74]
1000228e: 6716         	str	r6, [r2, #0x70]
10002290: bdf0         	pop	{r4, r5, r6, r7, pc}

10002292 <fdiv_fsub_nan_helper>:
;     table_tail_call SF_TABLE_FMUL
10002292: 4b01         	ldr	r3, [pc, #0x4]          @ 0x10002298 <fdiv_fsub_nan_helper+0x6>
10002294: 689b         	ldr	r3, [r3, #0x8]
10002296: 4718         	bx	r3
10002298: 68 04 00 20  	.word	0x20000468
1000229c: 00 00 00 d0  	.word	0xd0000000

100022a0 <float2uint_z>:
;     table_tail_call SF_TABLE_FLOAT2UINT
100022a0: 4b01         	ldr	r3, [pc, #0x4]          @ 0x100022a8 <float2uint_z+0x8>
100022a2: 6a5b         	ldr	r3, [r3, #0x24]
100022a4: 4718         	bx	r3
100022a6: 00 00        	.short	0x0000
100022a8: 68 04 00 20  	.word	0x20000468

100022ac <__wrap___aeabi_f2d>:
;     shimmable_table_tail_call SF_TABLE_FLOAT2DOUBLE float2double_shim
100022ac: 4b03         	ldr	r3, [pc, #0xc]          @ 0x100022bc <__wrap___aeabi_f2d+0x10>
100022ae: 6fdb         	ldr	r3, [r3, #0x7c]
100022b0: 46fc         	mov	r12, pc
100022b2: 4718         	bx	r3
100022b4: 7c df 51 23  	.word	0x2351df7c
100022b8: 00 10 00 00  	.word	0x00001000
100022bc: 68 04 00 20  	.word	0x20000468

100022c0 <__aeabi_float_init>:
;     return *(uint8_t*)0x13;
100022c0: 2313         	movs	r3, #0x13
; void __aeabi_float_init(void) {
100022c2: b510         	push	{r4, lr}
;     void *rom_table = rom_data_lookup(rom_table_code('S', 'F'));
100022c4: 4812         	ldr	r0, [pc, #0x48]         @ 0x10002310 <__aeabi_float_init+0x50>
;     int rom_version = rp2040_rom_version();
100022c6: 781c         	ldrb	r4, [r3]
;     void *rom_table = rom_data_lookup(rom_table_code('S', 'F'));
100022c8: f7ff f842    	bl	0x10001350 <rom_data_lookup> @ imm = #-0xf7c
100022cc: 0001         	movs	r1, r0
;     if (rom_version == 1) {
100022ce: 2c01         	cmp	r4, #0x1
100022d0: d00a         	beq	0x100022e8 <__aeabi_float_init+0x28> @ imm = #0x14
;     if (rom_version >= 2) {
100022d2: dd03         	ble	0x100022dc <__aeabi_float_init+0x1c> @ imm = #0x6
;         memcpy(&sf_table, rom_table, SF_TABLE_V2_SIZE);
100022d4: 2280         	movs	r2, #0x80
100022d6: 480f         	ldr	r0, [pc, #0x3c]         @ 0x10002314 <__aeabi_float_init+0x54>
100022d8: f000 f85a    	bl	0x10002390 <__wrap_memcpy> @ imm = #0xb4
;     sf_clz_func = rom_func_lookup(ROM_FUNC_CLZ32);
100022dc: 480e         	ldr	r0, [pc, #0x38]         @ 0x10002318 <__aeabi_float_init+0x58>
100022de: f7ff f82f    	bl	0x10001340 <rom_func_lookup> @ imm = #-0xfa2
100022e2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x1000231c <__aeabi_float_init+0x5c>
100022e4: 6018         	str	r0, [r3]
; }
100022e6: bd10         	pop	{r4, pc}
;         memcpy(&sf_table, rom_table, SF_TABLE_V1_SIZE);
100022e8: 4c0a         	ldr	r4, [pc, #0x28]         @ 0x10002314 <__aeabi_float_init+0x54>
100022ea: 2254         	movs	r2, #0x54
100022ec: 0020         	movs	r0, r4
100022ee: f000 f84f    	bl	0x10002390 <__wrap_memcpy> @ imm = #0x9e
;             sf_table[i] = (uintptr_t)float_table_shim_on_use_helper;
100022f2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x10002320 <__aeabi_float_init+0x60>
100022f4: 6563         	str	r3, [r4, #0x54]
100022f6: 65a3         	str	r3, [r4, #0x58]
100022f8: 65e3         	str	r3, [r4, #0x5c]
100022fa: 6623         	str	r3, [r4, #0x60]
100022fc: 6663         	str	r3, [r4, #0x64]
100022fe: 66a3         	str	r3, [r4, #0x68]
10002300: 66e3         	str	r3, [r4, #0x6c]
10002302: 6723         	str	r3, [r4, #0x70]
10002304: 6763         	str	r3, [r4, #0x74]
10002306: 67a3         	str	r3, [r4, #0x78]
10002308: 67e3         	str	r3, [r4, #0x7c]
;         sf_table[SF_TABLE_FLOAT2INT/4] = sf_table[SF_TABLE_FLOAT2FIX/4] = (uintptr_t)float_table_shim_on_use_helper;
1000230a: 6223         	str	r3, [r4, #0x20]
1000230c: 61e3         	str	r3, [r4, #0x1c]
;     if (rom_version >= 2) {
1000230e: e7e5         	b	0x100022dc <__aeabi_float_init+0x1c> @ imm = #-0x36
10002310: 53 46 00 00  	.word	0x00004653
10002314: 68 04 00 20  	.word	0x20000468
10002318: 4c 33 00 00  	.word	0x0000334c
1000231c: c8 05 00 20  	.word	0x200005c8
10002320: 25 23 00 10  	.word	0x10002325

10002324 <float_table_shim_on_use_helper>:
;     push {r0-r2, lr}
10002324: b507         	push	{r0, r1, r2, lr}
;     mov r0, ip
10002326: 4660         	mov	r0, r12
;     ldrh r1, [r0]
10002328: 8801         	ldrh	r1, [r0]
;     lsrs r2, r1, #8
1000232a: 0a0a         	lsrs	r2, r1, #0x8
;     adds r0, #2
1000232c: 3002         	adds	r0, #0x2
;     cmp r2, #0xdf
1000232e: 2adf         	cmp	r2, #0xdf
;     bne 1b
10002330: d1fa         	bne	0x10002328 <float_table_shim_on_use_helper+0x4> @ imm = #-0xc
;     uxtb r1, r1 // r1 holds table offset
10002332: b2c9         	uxtb	r1, r1
;     lsrs r2, r0, #2
10002334: 0882         	lsrs	r2, r0, #0x2
;     bcc 1f
10002336: d304         	blo	0x10002342 <float_table_shim_on_use_helper+0x1e> @ imm = #0x8
;     ldrh r2, [r0, #0]
10002338: 8802         	ldrh	r2, [r0]
;     ldrh r0, [r0, #2]
1000233a: 8840         	ldrh	r0, [r0, #0x2]
;     lsls r0, #16
1000233c: 0400         	lsls	r0, r0, #0x10
;     orrs r0, r2
1000233e: 4310         	orrs	r0, r2
;     b 2f
10002340: e000         	b	0x10002344 <float_table_shim_on_use_helper+0x20> @ imm = #0x0
;     ldr r0, [r0]
10002342: 6800         	ldr	r0, [r0]
;     ldr r2, =sf_table
10002344: 4a01         	ldr	r2, [pc, #0x4]          @ 0x1000234c <float_table_shim_on_use_helper+0x28>
;     str r0, [r2, r1]
10002346: 5050         	str	r0, [r2, r1]
;     str r0, [sp, #12]
10002348: 9003         	str	r0, [sp, #0xc]
;     pop {r0-r2, pc}
1000234a: bd07         	pop	{r0, r1, r2, pc}
1000234c: 68 04 00 20  	.word	0x20000468

10002350 <float2double_shim>:
;  lsrs r3,r0,#31                @ sign bit
10002350: 0fc3         	lsrs	r3, r0, #0x1f
;  lsls r3,#31
10002352: 07db         	lsls	r3, r3, #0x1f
;  lsls r1,r0,#1
10002354: 0041         	lsls	r1, r0, #0x1
;  lsrs r2,r1,#24                @ exponent
10002356: 0e0a         	lsrs	r2, r1, #0x18
;  beq 1f                        @ zero?
10002358: d007         	beq	0x1000236a <float2double_shim+0x1a> @ imm = #0xe
;  cmp r2,#0xff                  @ Inf?
1000235a: 2aff         	cmp	r2, #0xff
;  beq 2f
1000235c: d008         	beq	0x10002370 <float2double_shim+0x20> @ imm = #0x10
;  lsrs r1,#4                    @ exponent and top 20 bits of mantissa
1000235e: 0909         	lsrs	r1, r1, #0x4
;  ldr r2,=(0x3ff-0x7f)<<20     @ difference in exponent offsets
10002360: 4a05         	ldr	r2, [pc, #0x14]         @ 0x10002378 <float2double_shim+0x28>
;  adds r1,r2
10002362: 1889         	adds	r1, r1, r2
;  orrs r1,r3
10002364: 4319         	orrs	r1, r3
;  lsls r0,#29                   @ bottom 3 bits of mantissa
10002366: 0740         	lsls	r0, r0, #0x1d
;  bx r14
10002368: 4770         	bx	lr
;  movs r1,r3                    @ return signed zero
1000236a: 0019         	movs	r1, r3
;  movs r0,#0
1000236c: 2000         	movs	r0, #0x0
;  bx r14
1000236e: 4770         	bx	lr
;  ldr r1,=0x7ff00000           @ return signed infinity
10002370: 4902         	ldr	r1, [pc, #0x8]          @ 0x1000237c <float2double_shim+0x2c>
;  adds r1,r3
10002372: 18c9         	adds	r1, r1, r3
;  b 3b
10002374: e7fa         	b	0x1000236c <float2double_shim+0x1c> @ imm = #-0xc
10002376: 00 00        	.short	0x0000
10002378: 00 00 00 38  	.word	0x38000000
1000237c: 00 00 f0 7f  	.word	0x7ff00000

10002380 <__aeabi_mem_init>:
;     ldr r0, =aeabi_mem_funcs
10002380: 4801         	ldr	r0, [pc, #0x4]          @ 0x10002388 <__aeabi_mem_init+0x8>
;     movs r1, #MEM_FUNC_COUNT
10002382: 2104         	movs	r1, #0x4
;     ldr r3, =rom_funcs_lookup
10002384: 4b01         	ldr	r3, [pc, #0x4]          @ 0x1000238c <__aeabi_mem_init+0xc>
;     bx r3
10002386: 4718         	bx	r3
10002388: d0 01 00 20  	.word	0x200001d0
1000238c: 61 13 00 10  	.word	0x10001361

10002390 <__wrap_memcpy>:
;     ldr r3, =aeabi_mem_funcs
10002390: 4b01         	ldr	r3, [pc, #0x4]          @ 0x10002398 <__wrap_memcpy+0x8>
;     ldr r3, [r3, #MEMCPY]
10002392: 685b         	ldr	r3, [r3, #0x4]
;     bx r3
10002394: 4718         	bx	r3
10002396: 00 00        	.short	0x0000
10002398: d0 01 00 20  	.word	0x200001d0

1000239c <_out_null>:
; }
1000239c: 4770         	bx	lr
1000239e: 46c0         	mov	r8, r8

100023a0 <_out_rev>:
;                        unsigned int width, unsigned int flags) {
100023a0: b5f8         	push	{r3, r4, r5, r6, r7, lr}
100023a2: 4657         	mov	r7, r10
100023a4: 46de         	mov	lr, r11
100023a6: 464e         	mov	r6, r9
100023a8: 4645         	mov	r5, r8
100023aa: b5e0         	push	{r5, r6, r7, lr}
100023ac: 4699         	mov	r9, r3
100023ae: 9b0a         	ldr	r3, [sp, #0x28]
100023b0: 0007         	movs	r7, r0
100023b2: 469a         	mov	r10, r3
;     if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
100023b4: 9b0d         	ldr	r3, [sp, #0x34]
;                        unsigned int width, unsigned int flags) {
100023b6: 4688         	mov	r8, r1
100023b8: 4693         	mov	r11, r2
100023ba: 9c0b         	ldr	r4, [sp, #0x2c]
;     if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
100023bc: 079b         	lsls	r3, r3, #0x1e
100023be: d13b         	bne	0x10002438 <_out_rev+0x98> @ imm = #0x76
;         for (size_t i = len; i < width; i++) {
100023c0: 9b0c         	ldr	r3, [sp, #0x30]
100023c2: 429c         	cmp	r4, r3
100023c4: d23d         	bhs	0x10002442 <_out_rev+0xa2> @ imm = #0x7a
100023c6: 1b1e         	subs	r6, r3, r4
100023c8: 940b         	str	r4, [sp, #0x2c]
100023ca: 0015         	movs	r5, r2
100023cc: 000c         	movs	r4, r1
100023ce: 445e         	add	r6, r11
;             out(' ', buffer, idx++, maxlen);
100023d0: 002a         	movs	r2, r5
100023d2: 464b         	mov	r3, r9
100023d4: 3501         	adds	r5, #0x1
100023d6: 0021         	movs	r1, r4
100023d8: 2020         	movs	r0, #0x20
100023da: 47b8         	blx	r7
;         for (size_t i = len; i < width; i++) {
100023dc: 42b5         	cmp	r5, r6
100023de: d1f7         	bne	0x100023d0 <_out_rev+0x30> @ imm = #-0x12
;     while (len) {
100023e0: 46a0         	mov	r8, r4
100023e2: 9c0b         	ldr	r4, [sp, #0x2c]
100023e4: 2c00         	cmp	r4, #0x0
100023e6: d020         	beq	0x1000242a <_out_rev+0x8a> @ imm = #0x40
100023e8: 4645         	mov	r5, r8
100023ea: 1936         	adds	r6, r6, r4
;         out(buf[--len], buffer, idx++, maxlen);
100023ec: 4653         	mov	r3, r10
100023ee: 1b32         	subs	r2, r6, r4
100023f0: 3c01         	subs	r4, #0x1
100023f2: 5d18         	ldrb	r0, [r3, r4]
100023f4: 0029         	movs	r1, r5
100023f6: 464b         	mov	r3, r9
100023f8: 47b8         	blx	r7
;     while (len) {
100023fa: 2c00         	cmp	r4, #0x0
100023fc: d1f6         	bne	0x100023ec <_out_rev+0x4c> @ imm = #-0x14
100023fe: 002b         	movs	r3, r5
10002400: 0035         	movs	r5, r6
10002402: 4698         	mov	r8, r3
;     if (flags & FLAGS_LEFT) {
10002404: 9b0d         	ldr	r3, [sp, #0x34]
10002406: 079b         	lsls	r3, r3, #0x1e
10002408: d50f         	bpl	0x1000242a <_out_rev+0x8a> @ imm = #0x1e
;         while (idx - start_idx < width) {
1000240a: 465b         	mov	r3, r11
1000240c: 1aec         	subs	r4, r5, r3
1000240e: 9b0c         	ldr	r3, [sp, #0x30]
10002410: 42a3         	cmp	r3, r4
10002412: d90a         	bls	0x1000242a <_out_rev+0x8a> @ imm = #0x14
10002414: 4646         	mov	r6, r8
10002416: 4698         	mov	r8, r3
;             out(' ', buffer, idx++, maxlen);
10002418: 002a         	movs	r2, r5
1000241a: 464b         	mov	r3, r9
1000241c: 0031         	movs	r1, r6
1000241e: 2020         	movs	r0, #0x20
;         while (idx - start_idx < width) {
10002420: 3401         	adds	r4, #0x1
;             out(' ', buffer, idx++, maxlen);
10002422: 47b8         	blx	r7
10002424: 3501         	adds	r5, #0x1
;         while (idx - start_idx < width) {
10002426: 4544         	cmp	r4, r8
10002428: d3f6         	blo	0x10002418 <_out_rev+0x78> @ imm = #-0x14
; }
1000242a: 0028         	movs	r0, r5
1000242c: bcf0         	pop	{r4, r5, r6, r7}
1000242e: 46bb         	mov	r11, r7
10002430: 46b2         	mov	r10, r6
10002432: 46a9         	mov	r9, r5
10002434: 46a0         	mov	r8, r4
10002436: bdf8         	pop	{r3, r4, r5, r6, r7, pc}
;     while (len) {
10002438: 0016         	movs	r6, r2
1000243a: 0015         	movs	r5, r2
1000243c: 2c00         	cmp	r4, #0x0
1000243e: d1d3         	bne	0x100023e8 <_out_rev+0x48> @ imm = #-0x5a
10002440: e7e0         	b	0x10002404 <_out_rev+0x64> @ imm = #-0x40
10002442: 0016         	movs	r6, r2
10002444: 0015         	movs	r5, r2
10002446: 2c00         	cmp	r4, #0x0
10002448: d1ce         	bne	0x100023e8 <_out_rev+0x48> @ imm = #-0x64
1000244a: e7ee         	b	0x1000242a <_out_rev+0x8a> @ imm = #-0x24

1000244c <_ntoa_format>:
;                            unsigned int flags) {
1000244c: b5f0         	push	{r4, r5, r6, r7, lr}
1000244e: 4645         	mov	r5, r8
10002450: 46de         	mov	lr, r11
10002452: 4657         	mov	r7, r10
10002454: 464e         	mov	r6, r9
10002456: b5e0         	push	{r5, r6, r7, lr}
10002458: b085         	sub	sp, #0x14
1000245a: 469c         	mov	r12, r3
1000245c: ab10         	add	r3, sp, #0x40
1000245e: 781b         	ldrb	r3, [r3]
10002460: 9f14         	ldr	r7, [sp, #0x50]
10002462: 4693         	mov	r11, r2
10002464: 4698         	mov	r8, r3
10002466: 9c0f         	ldr	r4, [sp, #0x3c]
10002468: 9e12         	ldr	r6, [sp, #0x48]
1000246a: 9d13         	ldr	r5, [sp, #0x4c]
;     if (!(flags & FLAGS_LEFT)) {
1000246c: 07bb         	lsls	r3, r7, #0x1e
1000246e: d44c         	bmi	0x1000250a <_ntoa_format+0xbe> @ imm = #0x98
;         if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
10002470: 2d00         	cmp	r5, #0x0
10002472: d142         	bne	0x100024fa <_ntoa_format+0xae> @ imm = #0x84
;         while ((len < prec) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
10002474: 42b4         	cmp	r4, r6
10002476: d248         	bhs	0x1000250a <_ntoa_format+0xbe> @ imm = #0x90
;         if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
10002478: 2301         	movs	r3, #0x1
1000247a: 403b         	ands	r3, r7
1000247c: 4699         	mov	r9, r3
;             buf[len++] = '0';
1000247e: 9b0e         	ldr	r3, [sp, #0x38]
10002480: 3b01         	subs	r3, #0x1
10002482: 469a         	mov	r10, r3
10002484: 2330         	movs	r3, #0x30
10002486: e004         	b	0x10002492 <_ntoa_format+0x46> @ imm = #0x8
10002488: 4652         	mov	r2, r10
1000248a: 3401         	adds	r4, #0x1
1000248c: 5513         	strb	r3, [r2, r4]
;         while ((len < prec) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
1000248e: 42a6         	cmp	r6, r4
10002490: d901         	bls	0x10002496 <_ntoa_format+0x4a> @ imm = #0x2
10002492: 2c20         	cmp	r4, #0x20
10002494: d1f8         	bne	0x10002488 <_ntoa_format+0x3c> @ imm = #-0x10
;         while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
10002496: 464b         	mov	r3, r9
10002498: 2b00         	cmp	r3, #0x0
1000249a: d100         	bne	0x1000249e <_ntoa_format+0x52> @ imm = #0x0
1000249c: e083         	b	0x100025a6 <_ntoa_format+0x15a> @ imm = #0x106
;             buf[len++] = '0';
1000249e: 9b0e         	ldr	r3, [sp, #0x38]
100024a0: 3b01         	subs	r3, #0x1
100024a2: 4699         	mov	r9, r3
100024a4: 2330         	movs	r3, #0x30
;         while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
100024a6: 42a5         	cmp	r5, r4
100024a8: d805         	bhi	0x100024b6 <_ntoa_format+0x6a> @ imm = #0xa
100024aa: e02e         	b	0x1000250a <_ntoa_format+0xbe> @ imm = #0x5c
;             buf[len++] = '0';
100024ac: 464a         	mov	r2, r9
100024ae: 3401         	adds	r4, #0x1
100024b0: 5513         	strb	r3, [r2, r4]
;         while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
100024b2: 42ac         	cmp	r4, r5
100024b4: d029         	beq	0x1000250a <_ntoa_format+0xbe> @ imm = #0x52
100024b6: 2c20         	cmp	r4, #0x20
100024b8: d1f8         	bne	0x100024ac <_ntoa_format+0x60> @ imm = #-0x10
;     if (flags & FLAGS_HASH) {
100024ba: 06fb         	lsls	r3, r7, #0x1b
100024bc: d50c         	bpl	0x100024d8 <_ntoa_format+0x8c> @ imm = #0x18
;         if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
100024be: 057b         	lsls	r3, r7, #0x15
100024c0: d454         	bmi	0x1000256c <_ntoa_format+0x120> @ imm = #0xa8
100024c2: 42a6         	cmp	r6, r4
100024c4: d063         	beq	0x1000258e <_ntoa_format+0x142> @ imm = #0xc6
100024c6: 42a5         	cmp	r5, r4
100024c8: d061         	beq	0x1000258e <_ntoa_format+0x142> @ imm = #0xc2
;         if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
100024ca: 9b11         	ldr	r3, [sp, #0x44]
100024cc: 2b10         	cmp	r3, #0x10
100024ce: d050         	beq	0x10002572 <_ntoa_format+0x126> @ imm = #0xa0
;         } else if ((base == 2U) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
100024d0: 2b02         	cmp	r3, #0x2
100024d2: d057         	beq	0x10002584 <_ntoa_format+0x138> @ imm = #0xae
;         if (len < PICO_PRINTF_NTOA_BUFFER_SIZE) {
100024d4: 2c20         	cmp	r4, #0x20
100024d6: d132         	bne	0x1000253e <_ntoa_format+0xf2> @ imm = #0x64
100024d8: 2320         	movs	r3, #0x20
;     return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
100024da: 9301         	str	r3, [sp, #0x4]
100024dc: 9b0e         	ldr	r3, [sp, #0x38]
100024de: 465a         	mov	r2, r11
100024e0: 9300         	str	r3, [sp]
100024e2: 9703         	str	r7, [sp, #0xc]
100024e4: 4663         	mov	r3, r12
100024e6: 9502         	str	r5, [sp, #0x8]
100024e8: f7ff ff5a    	bl	0x100023a0 <_out_rev>   @ imm = #-0x14c
; }
100024ec: b005         	add	sp, #0x14
100024ee: bcf0         	pop	{r4, r5, r6, r7}
100024f0: 46bb         	mov	r11, r7
100024f2: 46b2         	mov	r10, r6
100024f4: 46a9         	mov	r9, r5
100024f6: 46a0         	mov	r8, r4
100024f8: bdf0         	pop	{r4, r5, r6, r7, pc}
;         if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
100024fa: 2301         	movs	r3, #0x1
100024fc: 403b         	ands	r3, r7
100024fe: 4699         	mov	r9, r3
10002500: 2301         	movs	r3, #0x1
10002502: 423b         	tst	r3, r7
10002504: d12a         	bne	0x1000255c <_ntoa_format+0x110> @ imm = #0x54
;         while ((len < prec) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
10002506: 42b4         	cmp	r4, r6
10002508: d3b9         	blo	0x1000247e <_ntoa_format+0x32> @ imm = #-0x8e
;     if (flags & FLAGS_HASH) {
1000250a: 06fb         	lsls	r3, r7, #0x1b
1000250c: d51c         	bpl	0x10002548 <_ntoa_format+0xfc> @ imm = #0x38
;         if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
1000250e: 057b         	lsls	r3, r7, #0x15
10002510: d4db         	bmi	0x100024ca <_ntoa_format+0x7e> @ imm = #-0x4a
10002512: 2c00         	cmp	r4, #0x0
10002514: d1d5         	bne	0x100024c2 <_ntoa_format+0x76> @ imm = #-0x56
;         if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
10002516: 9b11         	ldr	r3, [sp, #0x44]
10002518: 2b10         	cmp	r3, #0x10
1000251a: d05b         	beq	0x100025d4 <_ntoa_format+0x188> @ imm = #0xb6
;         } else if ((base == 2U) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
1000251c: 9b11         	ldr	r3, [sp, #0x44]
1000251e: 2b02         	cmp	r3, #0x2
10002520: d06b         	beq	0x100025fa <_ntoa_format+0x1ae> @ imm = #0xd6
;             buf[len++] = '0';
10002522: 2330         	movs	r3, #0x30
10002524: 2401         	movs	r4, #0x1
10002526: 9a0e         	ldr	r2, [sp, #0x38]
10002528: 7013         	strb	r3, [r2]
;         if (negative) {
1000252a: 4643         	mov	r3, r8
1000252c: 2b00         	cmp	r3, #0x0
1000252e: d110         	bne	0x10002552 <_ntoa_format+0x106> @ imm = #0x20
;         } else if (flags & FLAGS_PLUS) {
10002530: 077b         	lsls	r3, r7, #0x1d
10002532: d53e         	bpl	0x100025b2 <_ntoa_format+0x166> @ imm = #0x7c
;             buf[len++] = '+';  // ignore the space if the '+' exists
10002534: 262b         	movs	r6, #0x2b
10002536: 9a0e         	ldr	r2, [sp, #0x38]
10002538: 1c63         	adds	r3, r4, #0x1
1000253a: 5516         	strb	r6, [r2, r4]
1000253c: e7cd         	b	0x100024da <_ntoa_format+0x8e> @ imm = #-0x66
;             buf[len++] = '0';
1000253e: 0023         	movs	r3, r4
10002540: 3401         	adds	r4, #0x1
10002542: 2630         	movs	r6, #0x30
10002544: 9a0e         	ldr	r2, [sp, #0x38]
10002546: 54d6         	strb	r6, [r2, r3]
;     if (len < PICO_PRINTF_NTOA_BUFFER_SIZE) {
10002548: 2c20         	cmp	r4, #0x20
1000254a: d0c5         	beq	0x100024d8 <_ntoa_format+0x8c> @ imm = #-0x76
;         if (negative) {
1000254c: 4643         	mov	r3, r8
1000254e: 2b00         	cmp	r3, #0x0
10002550: d0ee         	beq	0x10002530 <_ntoa_format+0xe4> @ imm = #-0x24
;             buf[len++] = '-';
10002552: 262d         	movs	r6, #0x2d
10002554: 9a0e         	ldr	r2, [sp, #0x38]
10002556: 1c63         	adds	r3, r4, #0x1
10002558: 5516         	strb	r6, [r2, r4]
1000255a: e7be         	b	0x100024da <_ntoa_format+0x8e> @ imm = #-0x84
;         if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
1000255c: 4643         	mov	r3, r8
1000255e: 2b00         	cmp	r3, #0x0
10002560: d02f         	beq	0x100025c2 <_ntoa_format+0x176> @ imm = #0x5e
;             width--;
10002562: 3d01         	subs	r5, #0x1
;         while ((len < prec) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
10002564: 42b4         	cmp	r4, r6
10002566: d200         	bhs	0x1000256a <_ntoa_format+0x11e> @ imm = #0x0
10002568: e789         	b	0x1000247e <_ntoa_format+0x32> @ imm = #-0xee
1000256a: e798         	b	0x1000249e <_ntoa_format+0x52> @ imm = #-0xd0
;         if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
1000256c: 9b11         	ldr	r3, [sp, #0x44]
1000256e: 2b10         	cmp	r3, #0x10
10002570: d1b2         	bne	0x100024d8 <_ntoa_format+0x8c> @ imm = #-0x9c
10002572: 06bb         	lsls	r3, r7, #0x1a
10002574: d537         	bpl	0x100025e6 <_ntoa_format+0x19a> @ imm = #0x6e
;         } else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
10002576: 2c20         	cmp	r4, #0x20
10002578: d0ae         	beq	0x100024d8 <_ntoa_format+0x8c> @ imm = #-0xa4
;             buf[len++] = 'X';
1000257a: 2358         	movs	r3, #0x58
1000257c: 9a0e         	ldr	r2, [sp, #0x38]
1000257e: 5513         	strb	r3, [r2, r4]
10002580: 3401         	adds	r4, #0x1
10002582: e7a7         	b	0x100024d4 <_ntoa_format+0x88> @ imm = #-0xb2
;         } else if ((base == 2U) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
10002584: 2c20         	cmp	r4, #0x20
10002586: d0a7         	beq	0x100024d8 <_ntoa_format+0x8c> @ imm = #-0xb2
;             buf[len++] = 'X';
10002588: 0023         	movs	r3, r4
1000258a: 3401         	adds	r4, #0x1
1000258c: e007         	b	0x1000259e <_ntoa_format+0x152> @ imm = #0xe
;             len--;
1000258e: 1e63         	subs	r3, r4, #0x1
;             if (len && (base == 16U)) {
10002590: 2c01         	cmp	r4, #0x1
10002592: d0c0         	beq	0x10002516 <_ntoa_format+0xca> @ imm = #-0x80
10002594: 9a11         	ldr	r2, [sp, #0x44]
10002596: 2a10         	cmp	r2, #0x10
10002598: d031         	beq	0x100025fe <_ntoa_format+0x1b2> @ imm = #0x62
;         } else if ((base == 2U) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
1000259a: 2a02         	cmp	r2, #0x2
1000259c: d1d1         	bne	0x10002542 <_ntoa_format+0xf6> @ imm = #-0x5e
;             buf[len++] = 'b';
1000259e: 2662         	movs	r6, #0x62
100025a0: 9a0e         	ldr	r2, [sp, #0x38]
100025a2: 54d6         	strb	r6, [r2, r3]
100025a4: e796         	b	0x100024d4 <_ntoa_format+0x88> @ imm = #-0xd4
;     if (flags & FLAGS_HASH) {
100025a6: 06fb         	lsls	r3, r7, #0x1b
100025a8: d5ce         	bpl	0x10002548 <_ntoa_format+0xfc> @ imm = #-0x64
;         if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
100025aa: 057b         	lsls	r3, r7, #0x15
100025ac: d400         	bmi	0x100025b0 <_ntoa_format+0x164> @ imm = #0x0
100025ae: e788         	b	0x100024c2 <_ntoa_format+0x76> @ imm = #-0xf0
100025b0: e78b         	b	0x100024ca <_ntoa_format+0x7e> @ imm = #-0xea
;         } else if (flags & FLAGS_SPACE) {
100025b2: 0023         	movs	r3, r4
100025b4: 073e         	lsls	r6, r7, #0x1c
100025b6: d590         	bpl	0x100024da <_ntoa_format+0x8e> @ imm = #-0xe0
;             buf[len++] = ' ';
100025b8: 2620         	movs	r6, #0x20
100025ba: 9a0e         	ldr	r2, [sp, #0x38]
100025bc: 3301         	adds	r3, #0x1
100025be: 5516         	strb	r6, [r2, r4]
100025c0: e78b         	b	0x100024da <_ntoa_format+0x8e> @ imm = #-0xea
;         if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
100025c2: 230c         	movs	r3, #0xc
100025c4: 403b         	ands	r3, r7
;             width--;
100025c6: 1e5a         	subs	r2, r3, #0x1
100025c8: 4193         	sbcs	r3, r2
100025ca: 1aed         	subs	r5, r5, r3
;         while ((len < prec) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
100025cc: 42b4         	cmp	r4, r6
100025ce: d200         	bhs	0x100025d2 <_ntoa_format+0x186> @ imm = #0x0
100025d0: e755         	b	0x1000247e <_ntoa_format+0x32> @ imm = #-0x156
100025d2: e764         	b	0x1000249e <_ntoa_format+0x52> @ imm = #-0x138
;         if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
100025d4: 06bb         	lsls	r3, r7, #0x1a
100025d6: d40e         	bmi	0x100025f6 <_ntoa_format+0x1aa> @ imm = #0x1c
100025d8: 2378         	movs	r3, #0x78
;             buf[len++] = 'b';
100025da: 9a0e         	ldr	r2, [sp, #0x38]
;             buf[len++] = '0';
100025dc: 2402         	movs	r4, #0x2
;             buf[len++] = 'b';
100025de: 7013         	strb	r3, [r2]
;             buf[len++] = '0';
100025e0: 2330         	movs	r3, #0x30
100025e2: 7053         	strb	r3, [r2, #0x1]
;     if (len < PICO_PRINTF_NTOA_BUFFER_SIZE) {
100025e4: e7a1         	b	0x1000252a <_ntoa_format+0xde> @ imm = #-0xbe
;         if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
100025e6: 2c20         	cmp	r4, #0x20
100025e8: d100         	bne	0x100025ec <_ntoa_format+0x1a0> @ imm = #0x0
100025ea: e775         	b	0x100024d8 <_ntoa_format+0x8c> @ imm = #-0x116
;             buf[len++] = 'x';
100025ec: 2378         	movs	r3, #0x78
100025ee: 9a0e         	ldr	r2, [sp, #0x38]
100025f0: 5513         	strb	r3, [r2, r4]
100025f2: 3401         	adds	r4, #0x1
100025f4: e76e         	b	0x100024d4 <_ntoa_format+0x88> @ imm = #-0x124
;             buf[len++] = 'X';
100025f6: 2358         	movs	r3, #0x58
100025f8: e7ef         	b	0x100025da <_ntoa_format+0x18e> @ imm = #-0x22
;         } else if ((base == 2U) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
100025fa: 3360         	adds	r3, #0x60
100025fc: e7ed         	b	0x100025da <_ntoa_format+0x18e> @ imm = #-0x26
;             buf[len++] = 'x';
100025fe: 9a0e         	ldr	r2, [sp, #0x38]
;                 len--;
10002600: 1ea6         	subs	r6, r4, #0x2
;             buf[len++] = 'x';
10002602: 4691         	mov	r9, r2
10002604: 444e         	add	r6, r9
;         if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PICO_PRINTF_NTOA_BUFFER_SIZE)) {
10002606: 06ba         	lsls	r2, r7, #0x1a
10002608: d502         	bpl	0x10002610 <_ntoa_format+0x1c4> @ imm = #0x4
;             buf[len++] = 'X';
1000260a: 2258         	movs	r2, #0x58
1000260c: 7032         	strb	r2, [r6]
;         if (len < PICO_PRINTF_NTOA_BUFFER_SIZE) {
1000260e: e798         	b	0x10002542 <_ntoa_format+0xf6> @ imm = #-0xd0
;             buf[len++] = 'x';
10002610: 2278         	movs	r2, #0x78
10002612: 7032         	strb	r2, [r6]
;         if (len < PICO_PRINTF_NTOA_BUFFER_SIZE) {
10002614: e795         	b	0x10002542 <_ntoa_format+0xf6> @ imm = #-0xd6
10002616: 46c0         	mov	r8, r8

10002618 <_out_char>:
; static inline void _out_char(char character, void *buffer, size_t idx, size_t maxlen) {
10002618: b510         	push	{r4, lr}
;     if (character) {
1000261a: 2800         	cmp	r0, #0x0
1000261c: d100         	bne	0x10002620 <_out_char+0x8> @ imm = #0x0
; }
1000261e: bd10         	pop	{r4, pc}
;     putchar(character);
10002620: f001 fc64    	bl	0x10003eec <stdio_putchar> @ imm = #0x18c8
; }
10002624: e7fb         	b	0x1000261e <_out_char+0x6> @ imm = #-0xa
10002626: 46c0         	mov	r8, r8

10002628 <_out_fct>:
; static inline void _out_fct(char character, void *buffer, size_t idx, size_t maxlen) {
10002628: 000b         	movs	r3, r1
1000262a: b510         	push	{r4, lr}
;     if (character) {
1000262c: 2800         	cmp	r0, #0x0
1000262e: d002         	beq	0x10002636 <_out_fct+0xe> @ imm = #0x4
;         ((out_fct_wrap_type *) buffer)->fct(character, ((out_fct_wrap_type *) buffer)->arg);
10002630: 6849         	ldr	r1, [r1, #0x4]
10002632: 681b         	ldr	r3, [r3]
10002634: 4798         	blx	r3
; }
10002636: bd10         	pop	{r4, pc}

10002638 <_ftoa>:
;                     unsigned int width, unsigned int flags) {
10002638: b5f0         	push	{r4, r5, r6, r7, lr}
1000263a: 4657         	mov	r7, r10
1000263c: 46de         	mov	lr, r11
1000263e: 464e         	mov	r6, r9
10002640: 4645         	mov	r5, r8
10002642: b5e0         	push	{r5, r6, r7, lr}
10002644: b095         	sub	sp, #0x54
10002646: 4683         	mov	r11, r0
10002648: 000f         	movs	r7, r1
1000264a: 4692         	mov	r10, r2
1000264c: 4698         	mov	r8, r3
;     if (is_nan(value))
1000264e: 9a1e         	ldr	r2, [sp, #0x78]
10002650: 9b1f         	ldr	r3, [sp, #0x7c]
10002652: 0010         	movs	r0, r2
10002654: 0019         	movs	r1, r3
;                     unsigned int width, unsigned int flags) {
10002656: 9e20         	ldr	r6, [sp, #0x80]
;     if (is_nan(value))
10002658: f7ff fa89    	bl	0x10001b6e <__wrap___aeabi_dcmpun> @ imm = #-0xaee
1000265c: 2800         	cmp	r0, #0x0
1000265e: d000         	beq	0x10002662 <_ftoa+0x2a> @ imm = #0x0
10002660: e1ea         	b	0x10002a38 <_ftoa+0x400> @ imm = #0x3d4
;     if (value < -DBL_MAX)
10002662: 981e         	ldr	r0, [sp, #0x78]
10002664: 991f         	ldr	r1, [sp, #0x7c]
10002666: 2201         	movs	r2, #0x1
10002668: 4bc5         	ldr	r3, [pc, #0x314]        @ 0x10002980 <_ftoa+0x348>
1000266a: 4252         	rsbs	r2, r2, #0
1000266c: f7ff fa64    	bl	0x10001b38 <__wrap___aeabi_dcmplt> @ imm = #-0xb38
10002670: 2800         	cmp	r0, #0x0
10002672: d000         	beq	0x10002676 <_ftoa+0x3e> @ imm = #0x0
10002674: e114         	b	0x100028a0 <_ftoa+0x268> @ imm = #0x228
;     if (value > DBL_MAX)
10002676: 981e         	ldr	r0, [sp, #0x78]
10002678: 991f         	ldr	r1, [sp, #0x7c]
1000267a: 2201         	movs	r2, #0x1
1000267c: 4bc1         	ldr	r3, [pc, #0x304]        @ 0x10002984 <_ftoa+0x34c>
1000267e: 4252         	rsbs	r2, r2, #0
10002680: f7ff fa70    	bl	0x10001b64 <__wrap___aeabi_dcmpgt> @ imm = #-0xb20
10002684: 2800         	cmp	r0, #0x0
10002686: d000         	beq	0x1000268a <_ftoa+0x52> @ imm = #0x0
10002688: e0e9         	b	0x1000285e <_ftoa+0x226> @ imm = #0x1d2
;     if ((value > PICO_PRINTF_MAX_FLOAT) || (value < -PICO_PRINTF_MAX_FLOAT)) {
1000268a: 981e         	ldr	r0, [sp, #0x78]
1000268c: 991f         	ldr	r1, [sp, #0x7c]
1000268e: 2200         	movs	r2, #0x0
10002690: 4bbd         	ldr	r3, [pc, #0x2f4]        @ 0x10002988 <_ftoa+0x350>
10002692: f7ff fa67    	bl	0x10001b64 <__wrap___aeabi_dcmpgt> @ imm = #-0xb32
10002696: 2800         	cmp	r0, #0x0
10002698: d000         	beq	0x1000269c <_ftoa+0x64> @ imm = #0x0
1000269a: e0c8         	b	0x1000282e <_ftoa+0x1f6> @ imm = #0x190
1000269c: 981e         	ldr	r0, [sp, #0x78]
1000269e: 991f         	ldr	r1, [sp, #0x7c]
100026a0: 2200         	movs	r2, #0x0
100026a2: 4bba         	ldr	r3, [pc, #0x2e8]        @ 0x1000298c <_ftoa+0x354>
100026a4: f7ff fa48    	bl	0x10001b38 <__wrap___aeabi_dcmplt> @ imm = #-0xb70
100026a8: 2800         	cmp	r0, #0x0
100026aa: d000         	beq	0x100026ae <_ftoa+0x76> @ imm = #0x0
100026ac: e0bf         	b	0x1000282e <_ftoa+0x1f6> @ imm = #0x17e
;     if (value < 0) {
100026ae: 981e         	ldr	r0, [sp, #0x78]
100026b0: 991f         	ldr	r1, [sp, #0x7c]
100026b2: 2200         	movs	r2, #0x0
100026b4: 2300         	movs	r3, #0x0
100026b6: f7ff fa3f    	bl	0x10001b38 <__wrap___aeabi_dcmplt> @ imm = #-0xb82
100026ba: 2800         	cmp	r0, #0x0
100026bc: d000         	beq	0x100026c0 <_ftoa+0x88> @ imm = #0x0
100026be: e0e4         	b	0x1000288a <_ftoa+0x252> @ imm = #0x1c8
;     bool negative = false;
100026c0: 2300         	movs	r3, #0x0
100026c2: 930b         	str	r3, [sp, #0x2c]
;     if (!(flags & FLAGS_PRECISION)) {
100026c4: 9b22         	ldr	r3, [sp, #0x88]
100026c6: 055b         	lsls	r3, r3, #0x15
100026c8: d400         	bmi	0x100026cc <_ftoa+0x94> @ imm = #0x0
;         prec = PICO_PRINTF_DEFAULT_FLOAT_PRECISION;
100026ca: 2606         	movs	r6, #0x6
100026cc: 2400         	movs	r4, #0x0
;         buf[len++] = '0';
100026ce: 2330         	movs	r3, #0x30
100026d0: e007         	b	0x100026e2 <_ftoa+0xaa> @ imm = #0xe
100026d2: 2117         	movs	r1, #0x17
100026d4: aa06         	add	r2, sp, #0x18
100026d6: 3401         	adds	r4, #0x1
100026d8: 1852         	adds	r2, r2, r1
100026da: 5513         	strb	r3, [r2, r4]
;         prec--;
100026dc: 3e01         	subs	r6, #0x1
;     while ((len < PICO_PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
100026de: 2c20         	cmp	r4, #0x20
100026e0: d001         	beq	0x100026e6 <_ftoa+0xae> @ imm = #0x2
100026e2: 2e09         	cmp	r6, #0x9
100026e4: d8f5         	bhi	0x100026d2 <_ftoa+0x9a> @ imm = #-0x16
;     int whole = (int) value;
100026e6: 981e         	ldr	r0, [sp, #0x78]
100026e8: 991f         	ldr	r1, [sp, #0x7c]
100026ea: f7ff fa69    	bl	0x10001bc0 <double2int_z> @ imm = #-0xb2e
;     double tmp = (value - whole) * pow10[prec];
100026ee: 4ba8         	ldr	r3, [pc, #0x2a0]        @ 0x10002990 <_ftoa+0x358>
100026f0: 00f2         	lsls	r2, r6, #0x3
100026f2: 189b         	adds	r3, r3, r2
100026f4: 681a         	ldr	r2, [r3]
100026f6: 685b         	ldr	r3, [r3, #0x4]
;     int whole = (int) value;
100026f8: 0005         	movs	r5, r0
;     double tmp = (value - whole) * pow10[prec];
100026fa: 9208         	str	r2, [sp, #0x20]
100026fc: 9309         	str	r3, [sp, #0x24]
100026fe: f7ff fa47    	bl	0x10001b90 <int2double> @ imm = #-0xb72
10002702: 0002         	movs	r2, r0
10002704: 000b         	movs	r3, r1
10002706: 981e         	ldr	r0, [sp, #0x78]
10002708: 991f         	ldr	r1, [sp, #0x7c]
1000270a: f7ff f9a2    	bl	0x10001a52 <__wrap___aeabi_dsub> @ imm = #-0xcbc
1000270e: 9a08         	ldr	r2, [sp, #0x20]
10002710: 9b09         	ldr	r3, [sp, #0x24]
10002712: f7ff f9ce    	bl	0x10001ab2 <ddiv_dsub_nan_helper> @ imm = #-0xc64
;     unsigned long frac = (unsigned long) tmp;
10002716: 9006         	str	r0, [sp, #0x18]
10002718: 9107         	str	r1, [sp, #0x1c]
1000271a: f7ff fa75    	bl	0x10001c08 <double2uint_z> @ imm = #-0xb16
1000271e: 4681         	mov	r9, r0
;     diff = tmp - frac;
10002720: f7ff fa32    	bl	0x10001b88 <uint2double> @ imm = #-0xb9c
10002724: 0002         	movs	r2, r0
10002726: 000b         	movs	r3, r1
10002728: 9806         	ldr	r0, [sp, #0x18]
1000272a: 9907         	ldr	r1, [sp, #0x1c]
1000272c: f7ff f991    	bl	0x10001a52 <__wrap___aeabi_dsub> @ imm = #-0xcde
;     if (diff > 0.5) {
10002730: 2200         	movs	r2, #0x0
10002732: 4b98         	ldr	r3, [pc, #0x260]        @ 0x10002994 <_ftoa+0x35c>
;     diff = tmp - frac;
10002734: 9006         	str	r0, [sp, #0x18]
10002736: 9107         	str	r1, [sp, #0x1c]
;     if (diff > 0.5) {
10002738: f7ff fa14    	bl	0x10001b64 <__wrap___aeabi_dcmpgt> @ imm = #-0xbd8
1000273c: 2800         	cmp	r0, #0x0
1000273e: d100         	bne	0x10002742 <_ftoa+0x10a> @ imm = #0x0
10002740: e10d         	b	0x1000295e <_ftoa+0x326> @ imm = #0x21a
;         ++frac;
10002742: 2301         	movs	r3, #0x1
10002744: 469c         	mov	r12, r3
10002746: 44e1         	add	r9, r12
;         if (frac >= pow10[prec]) {
10002748: 4648         	mov	r0, r9
1000274a: f7ff fa1d    	bl	0x10001b88 <uint2double> @ imm = #-0xbc6
1000274e: 0002         	movs	r2, r0
10002750: 000b         	movs	r3, r1
10002752: 9808         	ldr	r0, [sp, #0x20]
10002754: 9909         	ldr	r1, [sp, #0x24]
10002756: f7ff f9f5    	bl	0x10001b44 <__wrap___aeabi_dcmple> @ imm = #-0xc16
1000275a: 2800         	cmp	r0, #0x0
1000275c: d002         	beq	0x10002764 <_ftoa+0x12c> @ imm = #0x4
;             frac = 0;
1000275e: 2300         	movs	r3, #0x0
10002760: 4699         	mov	r9, r3
;             ++whole;
10002762: 3501         	adds	r5, #0x1
;     if (prec == 0U) {
10002764: 2e00         	cmp	r6, #0x0
10002766: d100         	bne	0x1000276a <_ftoa+0x132> @ imm = #0x0
10002768: e0d9         	b	0x1000291e <_ftoa+0x2e6> @ imm = #0x1b2
1000276a: 9506         	str	r5, [sp, #0x18]
1000276c: 464d         	mov	r5, r9
1000276e: 46b9         	mov	r9, r7
10002770: e014         	b	0x1000279c <_ftoa+0x164> @ imm = #0x28
;             buf[len++] = (char) (48U + (frac % 10U));
10002772: aa06         	add	r2, sp, #0x18
10002774: 4694         	mov	r12, r2
10002776: 2317         	movs	r3, #0x17
10002778: 210a         	movs	r1, #0xa
1000277a: 4463         	add	r3, r12
1000277c: 0028         	movs	r0, r5
1000277e: 3401         	adds	r4, #0x1
10002780: 191f         	adds	r7, r3, r4
10002782: f7fe ff2b    	bl	0x100015dc <divmod_u32u32> @ imm = #-0x11aa
10002786: 3130         	adds	r1, #0x30
10002788: 7039         	strb	r1, [r7]
;             if (!(frac /= 10U)) {
1000278a: 0028         	movs	r0, r5
1000278c: 210a         	movs	r1, #0xa
;             --count;
1000278e: 3e01         	subs	r6, #0x1
;             if (!(frac /= 10U)) {
10002790: f7fe ff24    	bl	0x100015dc <divmod_u32u32> @ imm = #-0x11b8
10002794: 2d09         	cmp	r5, #0x9
10002796: d800         	bhi	0x1000279a <_ftoa+0x162> @ imm = #0x0
10002798: e117         	b	0x100029ca <_ftoa+0x392> @ imm = #0x22e
1000279a: 0005         	movs	r5, r0
;         while (len < PICO_PRINTF_FTOA_BUFFER_SIZE) {
1000279c: 2c20         	cmp	r4, #0x20
1000279e: d1e8         	bne	0x10002772 <_ftoa+0x13a> @ imm = #-0x30
100027a0: 464f         	mov	r7, r9
100027a2: 9d06         	ldr	r5, [sp, #0x18]
;             if (!(frac /= 10U)) {
100027a4: 2420         	movs	r4, #0x20
100027a6: ae0c         	add	r6, sp, #0x30
;         buf[len++] = (char) (48 + (whole % 10));
100027a8: aa06         	add	r2, sp, #0x18
100027aa: 2317         	movs	r3, #0x17
100027ac: 4694         	mov	r12, r2
100027ae: 4463         	add	r3, r12
100027b0: 4699         	mov	r9, r3
100027b2: 465b         	mov	r3, r11
100027b4: 46b3         	mov	r11, r6
100027b6: 9306         	str	r3, [sp, #0x18]
100027b8: e00f         	b	0x100027da <_ftoa+0x1a2> @ imm = #0x1e
100027ba: 464b         	mov	r3, r9
100027bc: 0028         	movs	r0, r5
100027be: 210a         	movs	r1, #0xa
100027c0: 3401         	adds	r4, #0x1
100027c2: 18e6         	adds	r6, r4, r3
100027c4: f7fe fee2    	bl	0x1000158c <divmod_s32s32> @ imm = #-0x123c
100027c8: 3130         	adds	r1, #0x30
;         if (!(whole /= 10)) {
100027ca: 0028         	movs	r0, r5
;         buf[len++] = (char) (48 + (whole % 10));
100027cc: 7031         	strb	r1, [r6]
;         if (!(whole /= 10)) {
100027ce: 210a         	movs	r1, #0xa
100027d0: f7fe fedc    	bl	0x1000158c <divmod_s32s32> @ imm = #-0x1248
100027d4: 1e05         	subs	r5, r0, #0x0
100027d6: d100         	bne	0x100027da <_ftoa+0x1a2> @ imm = #0x0
100027d8: e0e4         	b	0x100029a4 <_ftoa+0x36c> @ imm = #0x1c8
;     while (len < PICO_PRINTF_FTOA_BUFFER_SIZE) {
100027da: 2c20         	cmp	r4, #0x20
100027dc: d1ed         	bne	0x100027ba <_ftoa+0x182> @ imm = #-0x26
100027de: 9b06         	ldr	r3, [sp, #0x18]
100027e0: 465e         	mov	r6, r11
100027e2: 469b         	mov	r11, r3
;     if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
100027e4: 2303         	movs	r3, #0x3
100027e6: 9a22         	ldr	r2, [sp, #0x88]
100027e8: 4013         	ands	r3, r2
100027ea: 2b01         	cmp	r3, #0x1
100027ec: d118         	bne	0x10002820 <_ftoa+0x1e8> @ imm = #0x30
;         if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
100027ee: 9b21         	ldr	r3, [sp, #0x84]
100027f0: 2b00         	cmp	r3, #0x0
100027f2: d015         	beq	0x10002820 <_ftoa+0x1e8> @ imm = #0x2a
100027f4: 9b0b         	ldr	r3, [sp, #0x2c]
100027f6: 2b00         	cmp	r3, #0x0
100027f8: d100         	bne	0x100027fc <_ftoa+0x1c4> @ imm = #0x0
100027fa: e0fd         	b	0x100029f8 <_ftoa+0x3c0> @ imm = #0x1fa
;             width--;
100027fc: 9b21         	ldr	r3, [sp, #0x84]
100027fe: 3b01         	subs	r3, #0x1
10002800: 9321         	str	r3, [sp, #0x84]
;         while ((len < width) && (len < PICO_PRINTF_FTOA_BUFFER_SIZE)) {
10002802: 2b20         	cmp	r3, #0x20
10002804: d90c         	bls	0x10002820 <_ftoa+0x1e8> @ imm = #0x18
;             buf[len++] = '0';
10002806: 2330         	movs	r3, #0x30
10002808: 9a21         	ldr	r2, [sp, #0x84]
1000280a: e007         	b	0x1000281c <_ftoa+0x1e4> @ imm = #0xe
1000280c: 2017         	movs	r0, #0x17
1000280e: a906         	add	r1, sp, #0x18
10002810: 3401         	adds	r4, #0x1
10002812: 1809         	adds	r1, r1, r0
10002814: 550b         	strb	r3, [r1, r4]
;         while ((len < width) && (len < PICO_PRINTF_FTOA_BUFFER_SIZE)) {
10002816: 4294         	cmp	r4, r2
10002818: d300         	blo	0x1000281c <_ftoa+0x1e4> @ imm = #0x0
1000281a: e0cc         	b	0x100029b6 <_ftoa+0x37e> @ imm = #0x198
1000281c: 2c20         	cmp	r4, #0x20
1000281e: d1f5         	bne	0x1000280c <_ftoa+0x1d4> @ imm = #-0x16
;     return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
10002820: 9b22         	ldr	r3, [sp, #0x88]
10002822: 9401         	str	r4, [sp, #0x4]
10002824: 9303         	str	r3, [sp, #0xc]
10002826: 9b21         	ldr	r3, [sp, #0x84]
10002828: 9600         	str	r6, [sp]
1000282a: 9302         	str	r3, [sp, #0x8]
1000282c: e022         	b	0x10002874 <_ftoa+0x23c> @ imm = #0x44
;         return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
1000282e: 9b22         	ldr	r3, [sp, #0x88]
10002830: 4652         	mov	r2, r10
10002832: 9304         	str	r3, [sp, #0x10]
10002834: 9b21         	ldr	r3, [sp, #0x84]
10002836: 0039         	movs	r1, r7
10002838: 9303         	str	r3, [sp, #0xc]
1000283a: 4658         	mov	r0, r11
1000283c: 9b1e         	ldr	r3, [sp, #0x78]
1000283e: 9c1f         	ldr	r4, [sp, #0x7c]
10002840: 9602         	str	r6, [sp, #0x8]
10002842: 9300         	str	r3, [sp]
10002844: 9401         	str	r4, [sp, #0x4]
10002846: 4643         	mov	r3, r8
10002848: f000 f94a    	bl	0x10002ae0 <_etoa>      @ imm = #0x294
1000284c: 0004         	movs	r4, r0
; }
1000284e: 0020         	movs	r0, r4
10002850: b015         	add	sp, #0x54
10002852: bcf0         	pop	{r4, r5, r6, r7}
10002854: 46bb         	mov	r11, r7
10002856: 46b2         	mov	r10, r6
10002858: 46a9         	mov	r9, r5
1000285a: 46a0         	mov	r8, r4
1000285c: bdf0         	pop	{r4, r5, r6, r7, pc}
;         return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U,
1000285e: 9b22         	ldr	r3, [sp, #0x88]
10002860: 075b         	lsls	r3, r3, #0x1d
10002862: d40f         	bmi	0x10002884 <_ftoa+0x24c> @ imm = #0x1e
10002864: 2203         	movs	r2, #0x3
10002866: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x10002998 <_ftoa+0x360>
10002868: 9922         	ldr	r1, [sp, #0x88]
1000286a: 9201         	str	r2, [sp, #0x4]
1000286c: 9103         	str	r1, [sp, #0xc]
1000286e: 9921         	ldr	r1, [sp, #0x84]
10002870: 9300         	str	r3, [sp]
10002872: 9102         	str	r1, [sp, #0x8]
;     return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
10002874: 4643         	mov	r3, r8
10002876: 4652         	mov	r2, r10
10002878: 0039         	movs	r1, r7
1000287a: 4658         	mov	r0, r11
1000287c: f7ff fd90    	bl	0x100023a0 <_out_rev>   @ imm = #-0x4e0
10002880: 0004         	movs	r4, r0
10002882: e7e4         	b	0x1000284e <_ftoa+0x216> @ imm = #-0x38
;         return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U,
10002884: 2204         	movs	r2, #0x4
10002886: 4b45         	ldr	r3, [pc, #0x114]        @ 0x1000299c <_ftoa+0x364>
10002888: e7ee         	b	0x10002868 <_ftoa+0x230> @ imm = #-0x24
;         value = 0 - value;
1000288a: 9a1e         	ldr	r2, [sp, #0x78]
1000288c: 9b1f         	ldr	r3, [sp, #0x7c]
1000288e: 2000         	movs	r0, #0x0
10002890: 2100         	movs	r1, #0x0
10002892: f7ff f8de    	bl	0x10001a52 <__wrap___aeabi_dsub> @ imm = #-0xe44
;         negative = true;
10002896: 2301         	movs	r3, #0x1
;         value = 0 - value;
10002898: 901e         	str	r0, [sp, #0x78]
1000289a: 911f         	str	r1, [sp, #0x7c]
;         negative = true;
1000289c: 930b         	str	r3, [sp, #0x2c]
1000289e: e711         	b	0x100026c4 <_ftoa+0x8c> @ imm = #-0x1de
;     if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
100028a0: 9b22         	ldr	r3, [sp, #0x88]
100028a2: 4654         	mov	r4, r10
100028a4: 079b         	lsls	r3, r3, #0x1e
100028a6: d111         	bne	0x100028cc <_ftoa+0x294> @ imm = #0x22
;         for (size_t i = len; i < width; i++) {
100028a8: 9b21         	ldr	r3, [sp, #0x84]
100028aa: 2b04         	cmp	r3, #0x4
100028ac: d90e         	bls	0x100028cc <_ftoa+0x294> @ imm = #0x1c
100028ae: 9b21         	ldr	r3, [sp, #0x84]
100028b0: 4655         	mov	r5, r10
100028b2: 469c         	mov	r12, r3
100028b4: 465e         	mov	r6, r11
100028b6: 3c04         	subs	r4, #0x4
100028b8: 4464         	add	r4, r12
;             out(' ', buffer, idx++, maxlen);
100028ba: 002a         	movs	r2, r5
100028bc: 4643         	mov	r3, r8
100028be: 3501         	adds	r5, #0x1
100028c0: 0039         	movs	r1, r7
100028c2: 2020         	movs	r0, #0x20
100028c4: 47b0         	blx	r6
;         for (size_t i = len; i < width; i++) {
100028c6: 42a5         	cmp	r5, r4
100028c8: d1f7         	bne	0x100028ba <_ftoa+0x282> @ imm = #-0x12
100028ca: 46b3         	mov	r11, r6
;     while (len) {
100028cc: 4d34         	ldr	r5, [pc, #0xd0]         @ 0x100029a0 <_ftoa+0x368>
;         for (size_t i = len; i < width; i++) {
100028ce: 0026         	movs	r6, r4
100028d0: 1f2b         	subs	r3, r5, #0x4
100028d2: 4699         	mov	r9, r3
100028d4: 465b         	mov	r3, r11
100028d6: 46a3         	mov	r11, r4
100028d8: 001c         	movs	r4, r3
;         out(buf[--len], buffer, idx++, maxlen);
100028da: 0032         	movs	r2, r6
100028dc: 78e8         	ldrb	r0, [r5, #0x3]
100028de: 4643         	mov	r3, r8
100028e0: 0039         	movs	r1, r7
;     while (len) {
100028e2: 3d01         	subs	r5, #0x1
;         out(buf[--len], buffer, idx++, maxlen);
100028e4: 47a0         	blx	r4
100028e6: 3601         	adds	r6, #0x1
;     while (len) {
100028e8: 454d         	cmp	r5, r9
100028ea: d1f6         	bne	0x100028da <_ftoa+0x2a2> @ imm = #-0x14
100028ec: 0023         	movs	r3, r4
100028ee: 465c         	mov	r4, r11
100028f0: 469b         	mov	r11, r3
;     if (flags & FLAGS_LEFT) {
100028f2: 9b22         	ldr	r3, [sp, #0x88]
100028f4: 3404         	adds	r4, #0x4
100028f6: 079b         	lsls	r3, r3, #0x1e
100028f8: d5a9         	bpl	0x1000284e <_ftoa+0x216> @ imm = #-0xae
;         while (idx - start_idx < width) {
100028fa: 4653         	mov	r3, r10
100028fc: 9a21         	ldr	r2, [sp, #0x84]
100028fe: 1ae3         	subs	r3, r4, r3
10002900: 429a         	cmp	r2, r3
10002902: d9a4         	bls	0x1000284e <_ftoa+0x216> @ imm = #-0xb8
10002904: 465e         	mov	r6, r11
10002906: 0015         	movs	r5, r2
;             out(' ', buffer, idx++, maxlen);
10002908: 0022         	movs	r2, r4
1000290a: 4643         	mov	r3, r8
1000290c: 0039         	movs	r1, r7
1000290e: 2020         	movs	r0, #0x20
10002910: 47b0         	blx	r6
;         while (idx - start_idx < width) {
10002912: 4653         	mov	r3, r10
;             out(' ', buffer, idx++, maxlen);
10002914: 3401         	adds	r4, #0x1
;         while (idx - start_idx < width) {
10002916: 1ae3         	subs	r3, r4, r3
10002918: 429d         	cmp	r5, r3
1000291a: d8f5         	bhi	0x10002908 <_ftoa+0x2d0> @ imm = #-0x16
1000291c: e797         	b	0x1000284e <_ftoa+0x216> @ imm = #-0xd2
;         diff = value - (double) whole;
1000291e: 0028         	movs	r0, r5
10002920: f7ff f936    	bl	0x10001b90 <int2double> @ imm = #-0xd94
10002924: 0002         	movs	r2, r0
10002926: 000b         	movs	r3, r1
10002928: 981e         	ldr	r0, [sp, #0x78]
1000292a: 991f         	ldr	r1, [sp, #0x7c]
1000292c: f7ff f891    	bl	0x10001a52 <__wrap___aeabi_dsub> @ imm = #-0xede
;         if (!((diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
10002930: 2200         	movs	r2, #0x0
10002932: 4b18         	ldr	r3, [pc, #0x60]         @ 0x10002994 <_ftoa+0x35c>
10002934: 9006         	str	r0, [sp, #0x18]
10002936: 9107         	str	r1, [sp, #0x1c]
10002938: f7ff f8fe    	bl	0x10001b38 <__wrap___aeabi_dcmplt> @ imm = #-0xe04
1000293c: ae0c         	add	r6, sp, #0x30
1000293e: 2800         	cmp	r0, #0x0
10002940: d000         	beq	0x10002944 <_ftoa+0x30c> @ imm = #0x0
10002942: e731         	b	0x100027a8 <_ftoa+0x170> @ imm = #-0x19e
10002944: 9806         	ldr	r0, [sp, #0x18]
10002946: 9907         	ldr	r1, [sp, #0x1c]
10002948: 2200         	movs	r2, #0x0
1000294a: 4b12         	ldr	r3, [pc, #0x48]         @ 0x10002994 <_ftoa+0x35c>
1000294c: f7ff f90a    	bl	0x10001b64 <__wrap___aeabi_dcmpgt> @ imm = #-0xdec
10002950: 2800         	cmp	r0, #0x0
10002952: d000         	beq	0x10002956 <_ftoa+0x31e> @ imm = #0x0
10002954: e728         	b	0x100027a8 <_ftoa+0x170> @ imm = #-0x1b0
10002956: 2301         	movs	r3, #0x1
10002958: 3501         	adds	r5, #0x1
1000295a: 439d         	bics	r5, r3
1000295c: e724         	b	0x100027a8 <_ftoa+0x170> @ imm = #-0x1b8
;     } else if (diff < 0.5) {
1000295e: 2200         	movs	r2, #0x0
10002960: 9806         	ldr	r0, [sp, #0x18]
10002962: 9907         	ldr	r1, [sp, #0x1c]
10002964: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x10002994 <_ftoa+0x35c>
10002966: f7ff f8e7    	bl	0x10001b38 <__wrap___aeabi_dcmplt> @ imm = #-0xe32
1000296a: 2800         	cmp	r0, #0x0
1000296c: d000         	beq	0x10002970 <_ftoa+0x338> @ imm = #0x0
1000296e: e6f9         	b	0x10002764 <_ftoa+0x12c> @ imm = #-0x20e
;     } else if ((frac == 0U) || (frac & 1U)) {
10002970: 464b         	mov	r3, r9
10002972: 2b00         	cmp	r3, #0x0
10002974: d15c         	bne	0x10002a30 <_ftoa+0x3f8> @ imm = #0xb8
;         ++frac;
10002976: 2301         	movs	r3, #0x1
10002978: 469c         	mov	r12, r3
1000297a: 44e1         	add	r9, r12
1000297c: e6f2         	b	0x10002764 <_ftoa+0x12c> @ imm = #-0x21c
1000297e: 46c0         	mov	r8, r8
10002980: ff ff ef ff  	.word	0xffefffff
10002984: ff ff ef 7f  	.word	0x7fefffff
10002988: 65 cd cd 41  	.word	0x41cdcd65
1000298c: 65 cd cd c1  	.word	0xc1cdcd65
10002990: 30 46 00 10  	.word	0x10004630
10002994: 00 00 e0 3f  	.word	0x3fe00000
10002998: c4 43 00 10  	.word	0x100043c4
1000299c: bc 43 00 10  	.word	0x100043bc
100029a0: cc 43 00 10  	.word	0x100043cc
100029a4: 9b06         	ldr	r3, [sp, #0x18]
100029a6: 465e         	mov	r6, r11
100029a8: 469b         	mov	r11, r3
;     if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
100029aa: 2303         	movs	r3, #0x3
100029ac: 9a22         	ldr	r2, [sp, #0x88]
100029ae: 4013         	ands	r3, r2
100029b0: 2b01         	cmp	r3, #0x1
100029b2: d100         	bne	0x100029b6 <_ftoa+0x37e> @ imm = #0x0
100029b4: e081         	b	0x10002aba <_ftoa+0x482> @ imm = #0x102
;     if (len < PICO_PRINTF_FTOA_BUFFER_SIZE) {
100029b6: 2c20         	cmp	r4, #0x20
100029b8: d100         	bne	0x100029bc <_ftoa+0x384> @ imm = #0x0
100029ba: e731         	b	0x10002820 <_ftoa+0x1e8> @ imm = #-0x19e
;         if (negative) {
100029bc: 9b0b         	ldr	r3, [sp, #0x2c]
100029be: 2b00         	cmp	r3, #0x0
100029c0: d027         	beq	0x10002a12 <_ftoa+0x3da> @ imm = #0x4e
;             buf[len++] = '-';
100029c2: 232d         	movs	r3, #0x2d
100029c4: 5533         	strb	r3, [r6, r4]
100029c6: 3401         	adds	r4, #0x1
100029c8: e72a         	b	0x10002820 <_ftoa+0x1e8> @ imm = #-0x1ac
;         while ((len < PICO_PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
100029ca: 464f         	mov	r7, r9
100029cc: 9d06         	ldr	r5, [sp, #0x18]
100029ce: 2c20         	cmp	r4, #0x20
100029d0: d100         	bne	0x100029d4 <_ftoa+0x39c> @ imm = #0x0
100029d2: e6e7         	b	0x100027a4 <_ftoa+0x16c> @ imm = #-0x232
;             buf[len++] = '0';
100029d4: 2230         	movs	r2, #0x30
100029d6: 1933         	adds	r3, r6, r4
100029d8: e007         	b	0x100029ea <_ftoa+0x3b2> @ imm = #0xe
100029da: 2017         	movs	r0, #0x17
100029dc: a906         	add	r1, sp, #0x18
100029de: 3401         	adds	r4, #0x1
100029e0: 1809         	adds	r1, r1, r0
100029e2: 550a         	strb	r2, [r1, r4]
;         while ((len < PICO_PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
100029e4: 2c20         	cmp	r4, #0x20
100029e6: d100         	bne	0x100029ea <_ftoa+0x3b2> @ imm = #0x0
100029e8: e6dc         	b	0x100027a4 <_ftoa+0x16c> @ imm = #-0x248
100029ea: 42a3         	cmp	r3, r4
100029ec: d1f5         	bne	0x100029da <_ftoa+0x3a2> @ imm = #-0x16
;             buf[len++] = '.';
100029ee: 222e         	movs	r2, #0x2e
100029f0: ae0c         	add	r6, sp, #0x30
100029f2: 3401         	adds	r4, #0x1
100029f4: 54f2         	strb	r2, [r6, r3]
100029f6: e6d7         	b	0x100027a8 <_ftoa+0x170> @ imm = #-0x252
;         if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
100029f8: 230c         	movs	r3, #0xc
100029fa: 9a22         	ldr	r2, [sp, #0x88]
100029fc: 4213         	tst	r3, r2
100029fe: d057         	beq	0x10002ab0 <_ftoa+0x478> @ imm = #0xae
;             width--;
10002a00: 9b21         	ldr	r3, [sp, #0x84]
10002a02: 3b01         	subs	r3, #0x1
10002a04: 9321         	str	r3, [sp, #0x84]
;         while ((len < width) && (len < PICO_PRINTF_FTOA_BUFFER_SIZE)) {
10002a06: 42a3         	cmp	r3, r4
10002a08: d900         	bls	0x10002a0c <_ftoa+0x3d4> @ imm = #0x0
10002a0a: e6fc         	b	0x10002806 <_ftoa+0x1ce> @ imm = #-0x208
;     if (len < PICO_PRINTF_FTOA_BUFFER_SIZE) {
10002a0c: 2c20         	cmp	r4, #0x20
10002a0e: d100         	bne	0x10002a12 <_ftoa+0x3da> @ imm = #0x0
10002a10: e706         	b	0x10002820 <_ftoa+0x1e8> @ imm = #-0x1f4
;         } else if (flags & FLAGS_PLUS) {
10002a12: 9b22         	ldr	r3, [sp, #0x88]
10002a14: 075b         	lsls	r3, r3, #0x1d
10002a16: d503         	bpl	0x10002a20 <_ftoa+0x3e8> @ imm = #0x6
;             buf[len++] = '+';  // ignore the space if the '+' exists
10002a18: 232b         	movs	r3, #0x2b
10002a1a: 5533         	strb	r3, [r6, r4]
10002a1c: 3401         	adds	r4, #0x1
10002a1e: e6ff         	b	0x10002820 <_ftoa+0x1e8> @ imm = #-0x202
;         } else if (flags & FLAGS_SPACE) {
10002a20: 9b22         	ldr	r3, [sp, #0x88]
10002a22: 071b         	lsls	r3, r3, #0x1c
10002a24: d400         	bmi	0x10002a28 <_ftoa+0x3f0> @ imm = #0x0
10002a26: e6fb         	b	0x10002820 <_ftoa+0x1e8> @ imm = #-0x20a
;             buf[len++] = ' ';
10002a28: 2320         	movs	r3, #0x20
10002a2a: 5533         	strb	r3, [r6, r4]
10002a2c: 3401         	adds	r4, #0x1
10002a2e: e6f7         	b	0x10002820 <_ftoa+0x1e8> @ imm = #-0x212
;     } else if ((frac == 0U) || (frac & 1U)) {
10002a30: 07db         	lsls	r3, r3, #0x1f
10002a32: d400         	bmi	0x10002a36 <_ftoa+0x3fe> @ imm = #0x0
10002a34: e696         	b	0x10002764 <_ftoa+0x12c> @ imm = #-0x2d4
10002a36: e79e         	b	0x10002976 <_ftoa+0x33e> @ imm = #-0xc4
;     if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
10002a38: 9b22         	ldr	r3, [sp, #0x88]
10002a3a: 4655         	mov	r5, r10
10002a3c: 079b         	lsls	r3, r3, #0x1e
10002a3e: d111         	bne	0x10002a64 <_ftoa+0x42c> @ imm = #0x22
;         for (size_t i = len; i < width; i++) {
10002a40: 9b21         	ldr	r3, [sp, #0x84]
10002a42: 2b03         	cmp	r3, #0x3
10002a44: d90e         	bls	0x10002a64 <_ftoa+0x42c> @ imm = #0x1c
10002a46: 9b21         	ldr	r3, [sp, #0x84]
10002a48: 4654         	mov	r4, r10
10002a4a: 469c         	mov	r12, r3
10002a4c: 465e         	mov	r6, r11
10002a4e: 3d03         	subs	r5, #0x3
10002a50: 4465         	add	r5, r12
;             out(' ', buffer, idx++, maxlen);
10002a52: 0022         	movs	r2, r4
10002a54: 4643         	mov	r3, r8
10002a56: 3401         	adds	r4, #0x1
10002a58: 0039         	movs	r1, r7
10002a5a: 2020         	movs	r0, #0x20
10002a5c: 47b0         	blx	r6
;         for (size_t i = len; i < width; i++) {
10002a5e: 42ac         	cmp	r4, r5
10002a60: d1f7         	bne	0x10002a52 <_ftoa+0x41a> @ imm = #-0x12
10002a62: 46b3         	mov	r11, r6
;     while (len) {
10002a64: 46b9         	mov	r9, r7
10002a66: 465f         	mov	r7, r11
10002a68: 4e1c         	ldr	r6, [pc, #0x70]         @ 0x10002adc <_ftoa+0x4a4>
10002a6a: 1cec         	adds	r4, r5, #0x3
;         out(buf[--len], buffer, idx++, maxlen);
10002a6c: 002a         	movs	r2, r5
10002a6e: 78b0         	ldrb	r0, [r6, #0x2]
10002a70: 4643         	mov	r3, r8
10002a72: 4649         	mov	r1, r9
10002a74: 3501         	adds	r5, #0x1
10002a76: 47b8         	blx	r7
;     while (len) {
10002a78: 3e01         	subs	r6, #0x1
10002a7a: 42ac         	cmp	r4, r5
10002a7c: d1f6         	bne	0x10002a6c <_ftoa+0x434> @ imm = #-0x14
;     if (flags & FLAGS_LEFT) {
10002a7e: 9b22         	ldr	r3, [sp, #0x88]
10002a80: 46bb         	mov	r11, r7
10002a82: 464f         	mov	r7, r9
10002a84: 079b         	lsls	r3, r3, #0x1e
10002a86: d400         	bmi	0x10002a8a <_ftoa+0x452> @ imm = #0x0
10002a88: e6e1         	b	0x1000284e <_ftoa+0x216> @ imm = #-0x23e
;         while (idx - start_idx < width) {
10002a8a: 4653         	mov	r3, r10
10002a8c: 9a21         	ldr	r2, [sp, #0x84]
10002a8e: 1ae3         	subs	r3, r4, r3
10002a90: 429a         	cmp	r2, r3
10002a92: d800         	bhi	0x10002a96 <_ftoa+0x45e> @ imm = #0x0
10002a94: e6db         	b	0x1000284e <_ftoa+0x216> @ imm = #-0x24a
10002a96: 465e         	mov	r6, r11
10002a98: 0015         	movs	r5, r2
;             out(' ', buffer, idx++, maxlen);
10002a9a: 0022         	movs	r2, r4
10002a9c: 4643         	mov	r3, r8
10002a9e: 0039         	movs	r1, r7
10002aa0: 2020         	movs	r0, #0x20
10002aa2: 47b0         	blx	r6
;         while (idx - start_idx < width) {
10002aa4: 4653         	mov	r3, r10
;             out(' ', buffer, idx++, maxlen);
10002aa6: 3401         	adds	r4, #0x1
;         while (idx - start_idx < width) {
10002aa8: 1ae3         	subs	r3, r4, r3
10002aaa: 42ab         	cmp	r3, r5
10002aac: d3f5         	blo	0x10002a9a <_ftoa+0x462> @ imm = #-0x16
10002aae: e6ce         	b	0x1000284e <_ftoa+0x216> @ imm = #-0x264
;         while ((len < width) && (len < PICO_PRINTF_FTOA_BUFFER_SIZE)) {
10002ab0: 9b21         	ldr	r3, [sp, #0x84]
10002ab2: 42a3         	cmp	r3, r4
10002ab4: d900         	bls	0x10002ab8 <_ftoa+0x480> @ imm = #0x0
10002ab6: e6a6         	b	0x10002806 <_ftoa+0x1ce> @ imm = #-0x2b4
10002ab8: e6b2         	b	0x10002820 <_ftoa+0x1e8> @ imm = #-0x29c
;         if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
10002aba: 9b21         	ldr	r3, [sp, #0x84]
10002abc: 2b00         	cmp	r3, #0x0
10002abe: d100         	bne	0x10002ac2 <_ftoa+0x48a> @ imm = #0x0
10002ac0: e779         	b	0x100029b6 <_ftoa+0x37e> @ imm = #-0x10e
10002ac2: 9b0b         	ldr	r3, [sp, #0x2c]
10002ac4: 2b00         	cmp	r3, #0x0
10002ac6: d097         	beq	0x100029f8 <_ftoa+0x3c0> @ imm = #-0xd2
;             width--;
10002ac8: 9b21         	ldr	r3, [sp, #0x84]
10002aca: 3b01         	subs	r3, #0x1
10002acc: 9321         	str	r3, [sp, #0x84]
;         while ((len < width) && (len < PICO_PRINTF_FTOA_BUFFER_SIZE)) {
10002ace: 429c         	cmp	r4, r3
10002ad0: d200         	bhs	0x10002ad4 <_ftoa+0x49c> @ imm = #0x0
10002ad2: e698         	b	0x10002806 <_ftoa+0x1ce> @ imm = #-0x2d0
;     if (len < PICO_PRINTF_FTOA_BUFFER_SIZE) {
10002ad4: 2c20         	cmp	r4, #0x20
10002ad6: d000         	beq	0x10002ada <_ftoa+0x4a2> @ imm = #0x0
10002ad8: e773         	b	0x100029c2 <_ftoa+0x38a> @ imm = #-0x11a
10002ada: e6a1         	b	0x10002820 <_ftoa+0x1e8> @ imm = #-0x2be
10002adc: c8 43 00 10  	.word	0x100043c8

10002ae0 <_etoa>:
;                     unsigned int width, unsigned int flags) {
10002ae0: b5f0         	push	{r4, r5, r6, r7, lr}
10002ae2: 46de         	mov	lr, r11
10002ae4: 4657         	mov	r7, r10
10002ae6: 464e         	mov	r6, r9
10002ae8: 4645         	mov	r5, r8
10002aea: b5e0         	push	{r5, r6, r7, lr}
10002aec: b099         	sub	sp, #0x64
10002aee: 4681         	mov	r9, r0
10002af0: 468b         	mov	r11, r1
10002af2: 4692         	mov	r10, r2
10002af4: 4698         	mov	r8, r3
;     if (is_nan(value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
10002af6: 9a22         	ldr	r2, [sp, #0x88]
10002af8: 9b23         	ldr	r3, [sp, #0x8c]
10002afa: 0010         	movs	r0, r2
10002afc: 0019         	movs	r1, r3
10002afe: f7ff f836    	bl	0x10001b6e <__wrap___aeabi_dcmpun> @ imm = #-0xf94
10002b02: 2800         	cmp	r0, #0x0
10002b04: d000         	beq	0x10002b08 <_etoa+0x28> @ imm = #0x0
10002b06: e0ca         	b	0x10002c9e <_etoa+0x1be> @ imm = #0x194
10002b08: 9822         	ldr	r0, [sp, #0x88]
10002b0a: 9923         	ldr	r1, [sp, #0x8c]
10002b0c: 2201         	movs	r2, #0x1
10002b0e: 4b82         	ldr	r3, [pc, #0x208]        @ 0x10002d18 <_etoa+0x238>
10002b10: 4252         	rsbs	r2, r2, #0
10002b12: f7ff f827    	bl	0x10001b64 <__wrap___aeabi_dcmpgt> @ imm = #-0xfb2
10002b16: 2800         	cmp	r0, #0x0
10002b18: d000         	beq	0x10002b1c <_etoa+0x3c> @ imm = #0x0
10002b1a: e0c0         	b	0x10002c9e <_etoa+0x1be> @ imm = #0x180
10002b1c: 9822         	ldr	r0, [sp, #0x88]
10002b1e: 9923         	ldr	r1, [sp, #0x8c]
10002b20: 2201         	movs	r2, #0x1
10002b22: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x10002d1c <_etoa+0x23c>
10002b24: 4252         	rsbs	r2, r2, #0
10002b26: f7ff f807    	bl	0x10001b38 <__wrap___aeabi_dcmplt> @ imm = #-0xff2
10002b2a: 2800         	cmp	r0, #0x0
10002b2c: d000         	beq	0x10002b30 <_etoa+0x50> @ imm = #0x0
10002b2e: e0b6         	b	0x10002c9e <_etoa+0x1be> @ imm = #0x16c
;     if (negative) {
10002b30: 9822         	ldr	r0, [sp, #0x88]
10002b32: 9923         	ldr	r1, [sp, #0x8c]
10002b34: 2200         	movs	r2, #0x0
10002b36: 2300         	movs	r3, #0x0
10002b38: f7fe fffe    	bl	0x10001b38 <__wrap___aeabi_dcmplt> @ imm = #-0x1004
10002b3c: 2800         	cmp	r0, #0x0
10002b3e: d000         	beq	0x10002b42 <_etoa+0x62> @ imm = #0x0
10002b40: e1c9         	b	0x10002ed6 <_etoa+0x3f6> @ imm = #0x392
10002b42: 9b22         	ldr	r3, [sp, #0x88]
10002b44: 9c23         	ldr	r4, [sp, #0x8c]
10002b46: 9308         	str	r3, [sp, #0x20]
10002b48: 9409         	str	r4, [sp, #0x24]
;     conv.F = value;
10002b4a: 9808         	ldr	r0, [sp, #0x20]
10002b4c: 9909         	ldr	r1, [sp, #0x24]
;     if (!(flags & FLAGS_PRECISION)) {
10002b4e: 2380         	movs	r3, #0x80
10002b50: 9a26         	ldr	r2, [sp, #0x98]
10002b52: 00db         	lsls	r3, r3, #0x3
10002b54: 401a         	ands	r2, r3
10002b56: 920d         	str	r2, [sp, #0x34]
;     if (flags & FLAGS_ADAPT_EXP) {
10002b58: 2280         	movs	r2, #0x80
10002b5a: 9c26         	ldr	r4, [sp, #0x98]
10002b5c: 0112         	lsls	r2, r2, #0x4
10002b5e: 4014         	ands	r4, r2
10002b60: 0022         	movs	r2, r4
10002b62: 940b         	str	r4, [sp, #0x2c]
;     if (!(flags & FLAGS_PRECISION)) {
10002b64: 9c26         	ldr	r4, [sp, #0x98]
;     conv.F = value;
10002b66: 0007         	movs	r7, r0
10002b68: 000e         	movs	r6, r1
;     if (!(flags & FLAGS_PRECISION)) {
10002b6a: 421c         	tst	r4, r3
10002b6c: d000         	beq	0x10002b70 <_etoa+0x90> @ imm = #0x0
10002b6e: e0ad         	b	0x10002ccc <_etoa+0x1ec> @ imm = #0x15a
;     if (conv.U) {
10002b70: 000b         	movs	r3, r1
10002b72: 4303         	orrs	r3, r0
10002b74: d000         	beq	0x10002b78 <_etoa+0x98> @ imm = #0x0
10002b76: e0d5         	b	0x10002d24 <_etoa+0x244> @ imm = #0x1aa
;     if (flags & FLAGS_ADAPT_EXP) {
10002b78: 2a00         	cmp	r2, #0x0
10002b7a: d000         	beq	0x10002b7e <_etoa+0x9e> @ imm = #0x0
10002b7c: e20a         	b	0x10002f94 <_etoa+0x4b4> @ imm = #0x414
10002b7e: 0022         	movs	r2, r4
;         prec = PICO_PRINTF_DEFAULT_FLOAT_PRECISION;
10002b80: 3306         	adds	r3, #0x6
10002b82: 9324         	str	r3, [sp, #0x90]
;     if ((flags & FLAGS_LEFT) && minwidth) {
10002b84: 2302         	movs	r3, #0x2
10002b86: 4013         	ands	r3, r2
10002b88: 930c         	str	r3, [sp, #0x30]
10002b8a: 2302         	movs	r3, #0x2
10002b8c: 4213         	tst	r3, r2
10002b8e: d000         	beq	0x10002b92 <_etoa+0xb2> @ imm = #0x0
10002b90: e202         	b	0x10002f98 <_etoa+0x4b8> @ imm = #0x404
;     if (width > minwidth) {
10002b92: 9b25         	ldr	r3, [sp, #0x94]
10002b94: 2b04         	cmp	r3, #0x4
10002b96: d200         	bhs	0x10002b9a <_etoa+0xba> @ imm = #0x0
10002b98: e20f         	b	0x10002fba <_etoa+0x4da> @ imm = #0x41e
10002b9a: 3b04         	subs	r3, #0x4
10002b9c: 930b         	str	r3, [sp, #0x2c]
10002b9e: 2300         	movs	r3, #0x0
10002ba0: 2504         	movs	r5, #0x4
10002ba2: 930a         	str	r3, [sp, #0x28]
;     idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
10002ba4: 2200         	movs	r2, #0x0
10002ba6: 9822         	ldr	r0, [sp, #0x88]
10002ba8: 9923         	ldr	r1, [sp, #0x8c]
10002baa: 2300         	movs	r3, #0x0
10002bac: f7fe ffc4    	bl	0x10001b38 <__wrap___aeabi_dcmplt> @ imm = #-0x1078
10002bb0: 2800         	cmp	r0, #0x0
10002bb2: d000         	beq	0x10002bb6 <_etoa+0xd6> @ imm = #0x0
10002bb4: e203         	b	0x10002fbe <_etoa+0x4de> @ imm = #0x406
10002bb6: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x10002d20 <_etoa+0x240>
10002bb8: 9a26         	ldr	r2, [sp, #0x98]
10002bba: 4013         	ands	r3, r2
10002bbc: 9304         	str	r3, [sp, #0x10]
10002bbe: 9b0b         	ldr	r3, [sp, #0x2c]
10002bc0: 9303         	str	r3, [sp, #0xc]
10002bc2: 9b24         	ldr	r3, [sp, #0x90]
10002bc4: 9302         	str	r3, [sp, #0x8]
10002bc6: 9b08         	ldr	r3, [sp, #0x20]
10002bc8: 9c09         	ldr	r4, [sp, #0x24]
10002bca: 9300         	str	r3, [sp]
10002bcc: 9401         	str	r4, [sp, #0x4]
10002bce: 4659         	mov	r1, r11
10002bd0: 4643         	mov	r3, r8
10002bd2: 4652         	mov	r2, r10
10002bd4: 4648         	mov	r0, r9
10002bd6: f7ff fd2f    	bl	0x10002638 <_ftoa>      @ imm = #-0x5a2
10002bda: 0002         	movs	r2, r0
;         out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
10002bdc: 2020         	movs	r0, #0x20
10002bde: 9b26         	ldr	r3, [sp, #0x98]
10002be0: 271f         	movs	r7, #0x1f
10002be2: 4003         	ands	r3, r0
10002be4: 4259         	rsbs	r1, r3, #0
10002be6: 414b         	adcs	r3, r1
10002be8: 425b         	rsbs	r3, r3, #0
10002bea: 4018         	ands	r0, r3
10002bec: 1c53         	adds	r3, r2, #0x1
10002bee: 9308         	str	r3, [sp, #0x20]
10002bf0: 4659         	mov	r1, r11
10002bf2: 4643         	mov	r3, r8
10002bf4: 3045         	adds	r0, #0x45
10002bf6: 47c8         	blx	r9
;         idx = _ntoa_long(out, buffer, idx, maxlen, (uint)((expval < 0) ? -expval : expval), expval < 0, 10, 0, minwidth - 1,
10002bf8: 9a0a         	ldr	r2, [sp, #0x28]
10002bfa: 17d3         	asrs	r3, r2, #0x1f
10002bfc: 18d4         	adds	r4, r2, r3
10002bfe: 405c         	eors	r4, r3
10002c00: 0fd3         	lsrs	r3, r2, #0x1f
10002c02: 930a         	str	r3, [sp, #0x28]
10002c04: 1e6b         	subs	r3, r5, #0x1
10002c06: 930b         	str	r3, [sp, #0x2c]
;     if (!(flags & FLAGS_PRECISION) || value) {
10002c08: ab08         	add	r3, sp, #0x20
10002c0a: 469c         	mov	r12, r3
;         idx = _ntoa_long(out, buffer, idx, maxlen, (uint)((expval < 0) ? -expval : expval), expval < 0, 10, 0, minwidth - 1,
10002c0c: 2500         	movs	r5, #0x0
10002c0e: 4467         	add	r7, r12
10002c10: e001         	b	0x10002c16 <_etoa+0x136> @ imm = #0x2
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
10002c12: 2d20         	cmp	r5, #0x20
10002c14: d00f         	beq	0x10002c36 <_etoa+0x156> @ imm = #0x1e
;             const char digit = (char) (value % base);
10002c16: 0020         	movs	r0, r4
10002c18: 210a         	movs	r1, #0xa
10002c1a: f7fe fcdf    	bl	0x100015dc <divmod_u32u32> @ imm = #-0x1642
;             buf[len++] = (char)(digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10);
10002c1e: 3501         	adds	r5, #0x1
10002c20: 197e         	adds	r6, r7, r5
10002c22: 3130         	adds	r1, #0x30
10002c24: 7031         	strb	r1, [r6]
;             value /= base;
10002c26: 0020         	movs	r0, r4
10002c28: 210a         	movs	r1, #0xa
10002c2a: f7fe fcd7    	bl	0x100015dc <divmod_u32u32> @ imm = #-0x1652
10002c2e: 0026         	movs	r6, r4
10002c30: 0004         	movs	r4, r0
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
10002c32: 2e09         	cmp	r6, #0x9
10002c34: d8ed         	bhi	0x10002c12 <_etoa+0x132> @ imm = #-0x26
;     return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int) base, prec, width, flags);
10002c36: 2305         	movs	r3, #0x5
10002c38: 9306         	str	r3, [sp, #0x18]
10002c3a: 9b0b         	ldr	r3, [sp, #0x2c]
10002c3c: 4659         	mov	r1, r11
10002c3e: 9305         	str	r3, [sp, #0x14]
10002c40: 2300         	movs	r3, #0x0
10002c42: 9304         	str	r3, [sp, #0x10]
10002c44: 330a         	adds	r3, #0xa
10002c46: 9303         	str	r3, [sp, #0xc]
10002c48: 9b0a         	ldr	r3, [sp, #0x28]
10002c4a: 4648         	mov	r0, r9
10002c4c: 9302         	str	r3, [sp, #0x8]
10002c4e: ab10         	add	r3, sp, #0x40
10002c50: 9300         	str	r3, [sp]
10002c52: 9a08         	ldr	r2, [sp, #0x20]
10002c54: 4643         	mov	r3, r8
10002c56: 9501         	str	r5, [sp, #0x4]
10002c58: f7ff fbf8    	bl	0x1000244c <_ntoa_format> @ imm = #-0x810
;         if (flags & FLAGS_LEFT) {
10002c5c: 9b0c         	ldr	r3, [sp, #0x30]
10002c5e: 2b00         	cmp	r3, #0x0
10002c60: d02d         	beq	0x10002cbe <_etoa+0x1de> @ imm = #0x5a
;             while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
10002c62: 4653         	mov	r3, r10
10002c64: 1ac4         	subs	r4, r0, r3
10002c66: 9b25         	ldr	r3, [sp, #0x94]
10002c68: 42a3         	cmp	r3, r4
10002c6a: d928         	bls	0x10002cbe <_etoa+0x1de> @ imm = #0x50
10002c6c: 464d         	mov	r5, r9
10002c6e: 465f         	mov	r7, r11
10002c70: 4681         	mov	r9, r0
10002c72: 001e         	movs	r6, r3
10002c74: 4653         	mov	r3, r10
10002c76: 0039         	movs	r1, r7
10002c78: 191a         	adds	r2, r3, r4
10002c7a: 2020         	movs	r0, #0x20
10002c7c: 4643         	mov	r3, r8
10002c7e: 3401         	adds	r4, #0x1
10002c80: 47a8         	blx	r5
10002c82: 42a6         	cmp	r6, r4
10002c84: d8f6         	bhi	0x10002c74 <_etoa+0x194> @ imm = #-0x14
10002c86: 4653         	mov	r3, r10
10002c88: 4648         	mov	r0, r9
10002c8a: 9925         	ldr	r1, [sp, #0x94]
10002c8c: 1ac2         	subs	r2, r0, r3
10002c8e: 3201         	adds	r2, #0x1
10002c90: 2300         	movs	r3, #0x0
10002c92: 4291         	cmp	r1, r2
10002c94: d300         	blo	0x10002c98 <_etoa+0x1b8> @ imm = #0x0
10002c96: e186         	b	0x10002fa6 <_etoa+0x4c6> @ imm = #0x30c
10002c98: 3001         	adds	r0, #0x1
10002c9a: 1818         	adds	r0, r3, r0
10002c9c: e00f         	b	0x10002cbe <_etoa+0x1de> @ imm = #0x1e
;         return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
10002c9e: 9b26         	ldr	r3, [sp, #0x98]
10002ca0: 9304         	str	r3, [sp, #0x10]
10002ca2: 9b25         	ldr	r3, [sp, #0x94]
10002ca4: 9303         	str	r3, [sp, #0xc]
10002ca6: 9b24         	ldr	r3, [sp, #0x90]
10002ca8: 9302         	str	r3, [sp, #0x8]
10002caa: 9b22         	ldr	r3, [sp, #0x88]
10002cac: 9c23         	ldr	r4, [sp, #0x8c]
;     idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
10002cae: 9300         	str	r3, [sp]
10002cb0: 9401         	str	r4, [sp, #0x4]
10002cb2: 4643         	mov	r3, r8
10002cb4: 4652         	mov	r2, r10
10002cb6: 4659         	mov	r1, r11
10002cb8: 4648         	mov	r0, r9
10002cba: f7ff fcbd    	bl	0x10002638 <_ftoa>      @ imm = #-0x686
; }
10002cbe: b019         	add	sp, #0x64
10002cc0: bcf0         	pop	{r4, r5, r6, r7}
10002cc2: 46bb         	mov	r11, r7
10002cc4: 46b2         	mov	r10, r6
10002cc6: 46a9         	mov	r9, r5
10002cc8: 46a0         	mov	r8, r4
10002cca: bdf0         	pop	{r4, r5, r6, r7, pc}
;     if (conv.U) {
10002ccc: 4301         	orrs	r1, r0
10002cce: d12b         	bne	0x10002d28 <_etoa+0x248> @ imm = #0x56
;     if (flags & FLAGS_ADAPT_EXP) {
10002cd0: 9b0b         	ldr	r3, [sp, #0x2c]
10002cd2: 0022         	movs	r2, r4
10002cd4: 2b00         	cmp	r3, #0x0
10002cd6: d100         	bne	0x10002cda <_etoa+0x1fa> @ imm = #0x0
10002cd8: e754         	b	0x10002b84 <_etoa+0xa4> @ imm = #-0x158
;         expval = 0;
10002cda: 2300         	movs	r3, #0x0
10002cdc: 930a         	str	r3, [sp, #0x28]
;             if ((int) prec > expval) {
10002cde: 9b24         	ldr	r3, [sp, #0x90]
10002ce0: 9a0a         	ldr	r2, [sp, #0x28]
10002ce2: 2400         	movs	r4, #0x0
10002ce4: 4293         	cmp	r3, r2
10002ce6: dd00         	ble	0x10002cea <_etoa+0x20a> @ imm = #0x0
10002ce8: e185         	b	0x10002ff6 <_etoa+0x516> @ imm = #0x30a
;     idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
10002cea: 9822         	ldr	r0, [sp, #0x88]
10002cec: 9923         	ldr	r1, [sp, #0x8c]
10002cee: 2200         	movs	r2, #0x0
10002cf0: 2300         	movs	r3, #0x0
10002cf2: f7fe ff21    	bl	0x10001b38 <__wrap___aeabi_dcmplt> @ imm = #-0x11be
10002cf6: 2800         	cmp	r0, #0x0
10002cf8: d000         	beq	0x10002cfc <_etoa+0x21c> @ imm = #0x0
10002cfa: e135         	b	0x10002f68 <_etoa+0x488> @ imm = #0x26a
10002cfc: 9b26         	ldr	r3, [sp, #0x98]
10002cfe: 4a08         	ldr	r2, [pc, #0x20]         @ 0x10002d20 <_etoa+0x240>
10002d00: 9402         	str	r4, [sp, #0x8]
10002d02: 401a         	ands	r2, r3
10002d04: 2380         	movs	r3, #0x80
10002d06: 00db         	lsls	r3, r3, #0x3
10002d08: 4313         	orrs	r3, r2
10002d0a: 9304         	str	r3, [sp, #0x10]
10002d0c: 9b25         	ldr	r3, [sp, #0x94]
10002d0e: 9303         	str	r3, [sp, #0xc]
10002d10: 9b08         	ldr	r3, [sp, #0x20]
10002d12: 9c09         	ldr	r4, [sp, #0x24]
10002d14: e7cb         	b	0x10002cae <_etoa+0x1ce> @ imm = #-0x6a
10002d16: 46c0         	mov	r8, r8
10002d18: ff ff ef 7f  	.word	0x7fefffff
10002d1c: ff ff ef ff  	.word	0xffefffff
10002d20: ff f7 ff ff  	.word	0xfffff7ff
;         prec = PICO_PRINTF_DEFAULT_FLOAT_PRECISION;
10002d24: 2306         	movs	r3, #0x6
10002d26: 9324         	str	r3, [sp, #0x90]
;         int exp2 = (int) ((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
10002d28: 4bb4         	ldr	r3, [pc, #0x2d0]        @ 0x10002ffc <_etoa+0x51c>
10002d2a: 0070         	lsls	r0, r6, #0x1
10002d2c: 469c         	mov	r12, r3
10002d2e: 0d40         	lsrs	r0, r0, #0x15
10002d30: 4460         	add	r0, r12
;         expval = (int) (0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
10002d32: f7fe ff2d    	bl	0x10001b90 <int2double> @ imm = #-0x11a6
10002d36: 4ab2         	ldr	r2, [pc, #0x2c8]        @ 0x10003000 <_etoa+0x520>
10002d38: 4bb2         	ldr	r3, [pc, #0x2c8]        @ 0x10003004 <_etoa+0x524>
10002d3a: f7fe feba    	bl	0x10001ab2 <ddiv_dsub_nan_helper> @ imm = #-0x128c
10002d3e: 4ab2         	ldr	r2, [pc, #0x2c8]        @ 0x10003008 <_etoa+0x528>
10002d40: 4bb2         	ldr	r3, [pc, #0x2c8]        @ 0x1000300c <_etoa+0x52c>
10002d42: f7fe fe8f    	bl	0x10001a64 <__wrap___aeabi_dadd> @ imm = #-0x12e2
;         conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
10002d46: 0336         	lsls	r6, r6, #0xc
10002d48: 4bb1         	ldr	r3, [pc, #0x2c4]        @ 0x10003010 <_etoa+0x530>
10002d4a: 0b36         	lsrs	r6, r6, #0xc
10002d4c: 4333         	orrs	r3, r6
;         expval = (int) (0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
10002d4e: 0004         	movs	r4, r0
10002d50: 000d         	movs	r5, r1
;         conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
10002d52: 0038         	movs	r0, r7
10002d54: 0019         	movs	r1, r3
;         expval = (int) (0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
10002d56: 2200         	movs	r2, #0x0
10002d58: 4bae         	ldr	r3, [pc, #0x2b8]        @ 0x10003014 <_etoa+0x534>
10002d5a: f7fe fe7a    	bl	0x10001a52 <__wrap___aeabi_dsub> @ imm = #-0x130c
10002d5e: 4aae         	ldr	r2, [pc, #0x2b8]        @ 0x10003018 <_etoa+0x538>
10002d60: 4bae         	ldr	r3, [pc, #0x2b8]        @ 0x1000301c <_etoa+0x53c>
10002d62: f7fe fea6    	bl	0x10001ab2 <ddiv_dsub_nan_helper> @ imm = #-0x12b4
10002d66: 0002         	movs	r2, r0
10002d68: 000b         	movs	r3, r1
10002d6a: 0020         	movs	r0, r4
10002d6c: 0029         	movs	r1, r5
10002d6e: f7fe fe79    	bl	0x10001a64 <__wrap___aeabi_dadd> @ imm = #-0x130e
10002d72: f7fe ff25    	bl	0x10001bc0 <double2int_z> @ imm = #-0x11b6
10002d76: 900a         	str	r0, [sp, #0x28]
;         exp2 = (int) (expval * 3.321928094887362 + 0.5);
10002d78: f7fe ff0a    	bl	0x10001b90 <int2double> @ imm = #-0x11ec
10002d7c: 4aa8         	ldr	r2, [pc, #0x2a0]        @ 0x10003020 <_etoa+0x540>
10002d7e: 4ba9         	ldr	r3, [pc, #0x2a4]        @ 0x10003024 <_etoa+0x544>
10002d80: 0004         	movs	r4, r0
10002d82: 000d         	movs	r5, r1
10002d84: f7fe fe95    	bl	0x10001ab2 <ddiv_dsub_nan_helper> @ imm = #-0x12d6
10002d88: 2200         	movs	r2, #0x0
10002d8a: 4ba7         	ldr	r3, [pc, #0x29c]        @ 0x10003028 <_etoa+0x548>
10002d8c: f7fe fe6a    	bl	0x10001a64 <__wrap___aeabi_dadd> @ imm = #-0x132c
10002d90: f7fe ff16    	bl	0x10001bc0 <double2int_z> @ imm = #-0x11d4
;         const double z = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
10002d94: 4aa5         	ldr	r2, [pc, #0x294]        @ 0x1000302c <_etoa+0x54c>
;         exp2 = (int) (expval * 3.321928094887362 + 0.5);
10002d96: 0006         	movs	r6, r0
;         const double z = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
10002d98: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x10003030 <_etoa+0x550>
10002d9a: 0020         	movs	r0, r4
10002d9c: 0029         	movs	r1, r5
10002d9e: f7fe fe88    	bl	0x10001ab2 <ddiv_dsub_nan_helper> @ imm = #-0x12f0
10002da2: 0004         	movs	r4, r0
10002da4: 0030         	movs	r0, r6
10002da6: 000d         	movs	r5, r1
10002da8: 960c         	str	r6, [sp, #0x30]
10002daa: f7fe fef1    	bl	0x10001b90 <int2double> @ imm = #-0x121e
10002dae: 4aa1         	ldr	r2, [pc, #0x284]        @ 0x10003034 <_etoa+0x554>
10002db0: 4ba1         	ldr	r3, [pc, #0x284]        @ 0x10003038 <_etoa+0x558>
10002db2: f7fe fe7e    	bl	0x10001ab2 <ddiv_dsub_nan_helper> @ imm = #-0x1304
10002db6: 0002         	movs	r2, r0
10002db8: 000b         	movs	r3, r1
10002dba: 0020         	movs	r0, r4
10002dbc: 0029         	movs	r1, r5
10002dbe: f7fe fe48    	bl	0x10001a52 <__wrap___aeabi_dsub> @ imm = #-0x1370
;         const double z2 = z * z;
10002dc2: 0002         	movs	r2, r0
10002dc4: 000b         	movs	r3, r1
;         const double z = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
10002dc6: 0006         	movs	r6, r0
10002dc8: 000f         	movs	r7, r1
;         const double z2 = z * z;
10002dca: f7fe fe72    	bl	0x10001ab2 <ddiv_dsub_nan_helper> @ imm = #-0x131c
;         conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
10002dce: 0032         	movs	r2, r6
;         const double z2 = z * z;
10002dd0: 0004         	movs	r4, r0
10002dd2: 000d         	movs	r5, r1
;         conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
10002dd4: 003b         	movs	r3, r7
10002dd6: 0030         	movs	r0, r6
10002dd8: 0039         	movs	r1, r7
10002dda: f7fe fe43    	bl	0x10001a64 <__wrap___aeabi_dadd> @ imm = #-0x137a
10002dde: 2200         	movs	r2, #0x0
10002de0: 900e         	str	r0, [sp, #0x38]
10002de2: 910f         	str	r1, [sp, #0x3c]
10002de4: 4b95         	ldr	r3, [pc, #0x254]        @ 0x1000303c <_etoa+0x55c>
10002de6: 0020         	movs	r0, r4
10002de8: 0029         	movs	r1, r5
10002dea: f7fe fe44    	bl	0x10001a76 <__wrap___aeabi_ddiv> @ imm = #-0x1378
10002dee: 2200         	movs	r2, #0x0
10002df0: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x10003040 <_etoa+0x560>
10002df2: f7fe fe37    	bl	0x10001a64 <__wrap___aeabi_dadd> @ imm = #-0x1392
10002df6: 0002         	movs	r2, r0
10002df8: 000b         	movs	r3, r1
10002dfa: 0020         	movs	r0, r4
10002dfc: 0029         	movs	r1, r5
10002dfe: f7fe fe3a    	bl	0x10001a76 <__wrap___aeabi_ddiv> @ imm = #-0x138c
10002e02: 2200         	movs	r2, #0x0
10002e04: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x10003044 <_etoa+0x564>
10002e06: f7fe fe2d    	bl	0x10001a64 <__wrap___aeabi_dadd> @ imm = #-0x13a6
10002e0a: 0002         	movs	r2, r0
10002e0c: 000b         	movs	r3, r1
10002e0e: 0020         	movs	r0, r4
10002e10: 0029         	movs	r1, r5
10002e12: f7fe fe30    	bl	0x10001a76 <__wrap___aeabi_ddiv> @ imm = #-0x13a0
10002e16: 000d         	movs	r5, r1
10002e18: 2180         	movs	r1, #0x80
10002e1a: 0004         	movs	r4, r0
10002e1c: 0032         	movs	r2, r6
10002e1e: 003b         	movs	r3, r7
10002e20: 2000         	movs	r0, #0x0
10002e22: 05c9         	lsls	r1, r1, #0x17
10002e24: f7fe fe15    	bl	0x10001a52 <__wrap___aeabi_dsub> @ imm = #-0x13d6
10002e28: 0002         	movs	r2, r0
10002e2a: 000b         	movs	r3, r1
10002e2c: 0020         	movs	r0, r4
10002e2e: 0029         	movs	r1, r5
10002e30: f7fe fe18    	bl	0x10001a64 <__wrap___aeabi_dadd> @ imm = #-0x13d0
10002e34: 0002         	movs	r2, r0
10002e36: 000b         	movs	r3, r1
10002e38: 980e         	ldr	r0, [sp, #0x38]
10002e3a: 990f         	ldr	r1, [sp, #0x3c]
10002e3c: f7fe fe1b    	bl	0x10001a76 <__wrap___aeabi_ddiv> @ imm = #-0x13ca
10002e40: 2200         	movs	r2, #0x0
10002e42: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x10003010 <_etoa+0x530>
10002e44: f7fe fe0e    	bl	0x10001a64 <__wrap___aeabi_dadd> @ imm = #-0x13e4
;         conv.U = (uint64_t) (exp2 + 1023) << 52U;
10002e48: 4b7f         	ldr	r3, [pc, #0x1fc]        @ 0x10003048 <_etoa+0x568>
10002e4a: 9c0c         	ldr	r4, [sp, #0x30]
10002e4c: 469c         	mov	r12, r3
10002e4e: 4464         	add	r4, r12
10002e50: 2200         	movs	r2, #0x0
10002e52: 0523         	lsls	r3, r4, #0x14
;         conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
10002e54: f7fe fe2d    	bl	0x10001ab2 <ddiv_dsub_nan_helper> @ imm = #-0x13a6
10002e58: 0006         	movs	r6, r0
10002e5a: 000f         	movs	r7, r1
;         if (value < conv.F) {
10002e5c: 0002         	movs	r2, r0
10002e5e: 000b         	movs	r3, r1
10002e60: 9808         	ldr	r0, [sp, #0x20]
10002e62: 9909         	ldr	r1, [sp, #0x24]
10002e64: f7fe fe68    	bl	0x10001b38 <__wrap___aeabi_dcmplt> @ imm = #-0x1330
10002e68: 2800         	cmp	r0, #0x0
10002e6a: d00a         	beq	0x10002e82 <_etoa+0x3a2> @ imm = #0x14
;             expval--;
10002e6c: 9b0a         	ldr	r3, [sp, #0x28]
;             conv.F /= 10;
10002e6e: 0030         	movs	r0, r6
;             expval--;
10002e70: 3b01         	subs	r3, #0x1
;             conv.F /= 10;
10002e72: 0039         	movs	r1, r7
;             expval--;
10002e74: 930a         	str	r3, [sp, #0x28]
;             conv.F /= 10;
10002e76: 2200         	movs	r2, #0x0
10002e78: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x10003040 <_etoa+0x560>
10002e7a: f7fe fdfc    	bl	0x10001a76 <__wrap___aeabi_ddiv> @ imm = #-0x1408
10002e7e: 0006         	movs	r6, r0
10002e80: 000f         	movs	r7, r1
;     unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
10002e82: 9a0a         	ldr	r2, [sp, #0x28]
;             conv.F /= 10;
10002e84: 0033         	movs	r3, r6
;     unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
10002e86: 3263         	adds	r2, #0x63
;             conv.F /= 10;
10002e88: 0039         	movs	r1, r7
;     unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
10002e8a: 2ac6         	cmp	r2, #0xc6
10002e8c: d812         	bhi	0x10002eb4 <_etoa+0x3d4> @ imm = #0x24
;     if ((flags & FLAGS_LEFT) && minwidth) {
10002e8e: 2202         	movs	r2, #0x2
10002e90: 9826         	ldr	r0, [sp, #0x98]
10002e92: 2504         	movs	r5, #0x4
10002e94: 4010         	ands	r0, r2
;     if (flags & FLAGS_ADAPT_EXP) {
10002e96: 9a0b         	ldr	r2, [sp, #0x2c]
;     if ((flags & FLAGS_LEFT) && minwidth) {
10002e98: 900c         	str	r0, [sp, #0x30]
;     if (flags & FLAGS_ADAPT_EXP) {
10002e9a: 2a00         	cmp	r2, #0x0
10002e9c: d125         	bne	0x10002eea <_etoa+0x40a> @ imm = #0x4a
;     if (width > minwidth) {
10002e9e: 9b25         	ldr	r3, [sp, #0x94]
10002ea0: 2b04         	cmp	r3, #0x4
10002ea2: d905         	bls	0x10002eb0 <_etoa+0x3d0> @ imm = #0xa
;     if ((flags & FLAGS_LEFT) && minwidth) {
10002ea4: 2800         	cmp	r0, #0x0
10002ea6: d000         	beq	0x10002eaa <_etoa+0x3ca> @ imm = #0x0
10002ea8: e0a1         	b	0x10002fee <_etoa+0x50e> @ imm = #0x142
;         fwidth -= minwidth;
10002eaa: 9b25         	ldr	r3, [sp, #0x94]
10002eac: 3b04         	subs	r3, #0x4
10002eae: 930b         	str	r3, [sp, #0x2c]
10002eb0: 2504         	movs	r5, #0x4
10002eb2: e041         	b	0x10002f38 <_etoa+0x458> @ imm = #0x82
;     if ((flags & FLAGS_LEFT) && minwidth) {
10002eb4: 2202         	movs	r2, #0x2
10002eb6: 9826         	ldr	r0, [sp, #0x98]
10002eb8: 4010         	ands	r0, r2
;     if (flags & FLAGS_ADAPT_EXP) {
10002eba: 9a0b         	ldr	r2, [sp, #0x2c]
;     if ((flags & FLAGS_LEFT) && minwidth) {
10002ebc: 900c         	str	r0, [sp, #0x30]
;     if (flags & FLAGS_ADAPT_EXP) {
10002ebe: 2a00         	cmp	r2, #0x0
10002ec0: d112         	bne	0x10002ee8 <_etoa+0x408> @ imm = #0x24
;     if (width > minwidth) {
10002ec2: 9b25         	ldr	r3, [sp, #0x94]
10002ec4: 2b05         	cmp	r3, #0x5
10002ec6: d976         	bls	0x10002fb6 <_etoa+0x4d6> @ imm = #0xec
;     if ((flags & FLAGS_LEFT) && minwidth) {
10002ec8: 2800         	cmp	r0, #0x0
10002eca: d172         	bne	0x10002fb2 <_etoa+0x4d2> @ imm = #0xe4
;         fwidth -= minwidth;
10002ecc: 9b25         	ldr	r3, [sp, #0x94]
;     unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
10002ece: 2505         	movs	r5, #0x5
;         fwidth -= minwidth;
10002ed0: 3b05         	subs	r3, #0x5
10002ed2: 930b         	str	r3, [sp, #0x2c]
;     if (expval) {
10002ed4: e034         	b	0x10002f40 <_etoa+0x460> @ imm = #0x68
;         value = -value;
10002ed6: 2280         	movs	r2, #0x80
10002ed8: 0612         	lsls	r2, r2, #0x18
10002eda: 4694         	mov	r12, r2
10002edc: 9b22         	ldr	r3, [sp, #0x88]
10002ede: 9308         	str	r3, [sp, #0x20]
10002ee0: 9b23         	ldr	r3, [sp, #0x8c]
10002ee2: 4463         	add	r3, r12
10002ee4: 9309         	str	r3, [sp, #0x24]
10002ee6: e630         	b	0x10002b4a <_etoa+0x6a> @ imm = #-0x3a0
;     unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
10002ee8: 2505         	movs	r5, #0x5
;         if ((conv.U == 0) || ((value >= 1e-4) && (value < 1e6))) {
10002eea: 430b         	orrs	r3, r1
10002eec: d100         	bne	0x10002ef0 <_etoa+0x410> @ imm = #0x0
10002eee: e6f6         	b	0x10002cde <_etoa+0x1fe> @ imm = #-0x214
10002ef0: 9808         	ldr	r0, [sp, #0x20]
10002ef2: 9909         	ldr	r1, [sp, #0x24]
10002ef4: 4a55         	ldr	r2, [pc, #0x154]        @ 0x1000304c <_etoa+0x56c>
10002ef6: 4b56         	ldr	r3, [pc, #0x158]        @ 0x10003050 <_etoa+0x570>
10002ef8: f7fe fe2c    	bl	0x10001b54 <__wrap___aeabi_dcmpge> @ imm = #-0x13a8
10002efc: 2800         	cmp	r0, #0x0
10002efe: d008         	beq	0x10002f12 <_etoa+0x432> @ imm = #0x10
10002f00: 9808         	ldr	r0, [sp, #0x20]
10002f02: 9909         	ldr	r1, [sp, #0x24]
10002f04: 2200         	movs	r2, #0x0
10002f06: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x10003054 <_etoa+0x574>
10002f08: f7fe fe16    	bl	0x10001b38 <__wrap___aeabi_dcmplt> @ imm = #-0x13d4
10002f0c: 2800         	cmp	r0, #0x0
10002f0e: d000         	beq	0x10002f12 <_etoa+0x432> @ imm = #0x0
10002f10: e6e5         	b	0x10002cde <_etoa+0x1fe> @ imm = #-0x236
;             if ((prec > 0) && (flags & FLAGS_PRECISION)) {
10002f12: 9b24         	ldr	r3, [sp, #0x90]
10002f14: 2b00         	cmp	r3, #0x0
10002f16: d01c         	beq	0x10002f52 <_etoa+0x472> @ imm = #0x38
10002f18: 9b0d         	ldr	r3, [sp, #0x34]
10002f1a: 2b00         	cmp	r3, #0x0
10002f1c: d019         	beq	0x10002f52 <_etoa+0x472> @ imm = #0x32
;                 --prec;
10002f1e: 9b24         	ldr	r3, [sp, #0x90]
10002f20: 3b01         	subs	r3, #0x1
10002f22: 9324         	str	r3, [sp, #0x90]
;     if (width > minwidth) {
10002f24: 9b25         	ldr	r3, [sp, #0x94]
10002f26: 42ab         	cmp	r3, r5
10002f28: d904         	bls	0x10002f34 <_etoa+0x454> @ imm = #0x8
;     if ((flags & FLAGS_LEFT) && minwidth) {
10002f2a: 9b0c         	ldr	r3, [sp, #0x30]
10002f2c: 2b00         	cmp	r3, #0x0
10002f2e: d05a         	beq	0x10002fe6 <_etoa+0x506> @ imm = #0xb4
10002f30: 2302         	movs	r3, #0x2
10002f32: 930c         	str	r3, [sp, #0x30]
;         fwidth = 0U;
10002f34: 2300         	movs	r3, #0x0
10002f36: 930b         	str	r3, [sp, #0x2c]
;     if (expval) {
10002f38: 9b0a         	ldr	r3, [sp, #0x28]
10002f3a: 2b00         	cmp	r3, #0x0
10002f3c: d100         	bne	0x10002f40 <_etoa+0x460> @ imm = #0x0
10002f3e: e631         	b	0x10002ba4 <_etoa+0xc4> @ imm = #-0x39e
;         value /= conv.F;
10002f40: 9808         	ldr	r0, [sp, #0x20]
10002f42: 9909         	ldr	r1, [sp, #0x24]
10002f44: 0032         	movs	r2, r6
10002f46: 003b         	movs	r3, r7
10002f48: f7fe fd95    	bl	0x10001a76 <__wrap___aeabi_ddiv> @ imm = #-0x14d6
10002f4c: 9008         	str	r0, [sp, #0x20]
10002f4e: 9109         	str	r1, [sp, #0x24]
10002f50: e628         	b	0x10002ba4 <_etoa+0xc4> @ imm = #-0x3b0
;     if (width > minwidth) {
10002f52: 9b25         	ldr	r3, [sp, #0x94]
10002f54: 42ab         	cmp	r3, r5
10002f56: d9ed         	bls	0x10002f34 <_etoa+0x454> @ imm = #-0x26
;     if ((flags & FLAGS_LEFT) && minwidth) {
10002f58: 9b0c         	ldr	r3, [sp, #0x30]
10002f5a: 2b00         	cmp	r3, #0x0
10002f5c: d043         	beq	0x10002fe6 <_etoa+0x506> @ imm = #0x86
;         fwidth = 0U;
10002f5e: 2300         	movs	r3, #0x0
10002f60: 930b         	str	r3, [sp, #0x2c]
;     if ((flags & FLAGS_LEFT) && minwidth) {
10002f62: 3302         	adds	r3, #0x2
10002f64: 930c         	str	r3, [sp, #0x30]
10002f66: e7e7         	b	0x10002f38 <_etoa+0x458> @ imm = #-0x32
;     idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
10002f68: 2080         	movs	r0, #0x80
10002f6a: 9b26         	ldr	r3, [sp, #0x98]
10002f6c: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x10003058 <_etoa+0x578>
10002f6e: 0600         	lsls	r0, r0, #0x18
10002f70: 401a         	ands	r2, r3
10002f72: 2380         	movs	r3, #0x80
10002f74: 4684         	mov	r12, r0
10002f76: 9402         	str	r4, [sp, #0x8]
10002f78: 9c08         	ldr	r4, [sp, #0x20]
10002f7a: 9d09         	ldr	r5, [sp, #0x24]
10002f7c: 0029         	movs	r1, r5
10002f7e: 00db         	lsls	r3, r3, #0x3
10002f80: 4313         	orrs	r3, r2
10002f82: 9304         	str	r3, [sp, #0x10]
10002f84: 9b25         	ldr	r3, [sp, #0x94]
10002f86: 4461         	add	r1, r12
10002f88: 0022         	movs	r2, r4
10002f8a: 9303         	str	r3, [sp, #0xc]
10002f8c: 000b         	movs	r3, r1
10002f8e: 9200         	str	r2, [sp]
10002f90: 9301         	str	r3, [sp, #0x4]
10002f92: e68e         	b	0x10002cb2 <_etoa+0x1d2> @ imm = #-0x2e4
;     if (flags & FLAGS_ADAPT_EXP) {
10002f94: 2405         	movs	r4, #0x5
;                 prec = (unsigned) ((int) prec - expval - 1);
10002f96: e6a8         	b	0x10002cea <_etoa+0x20a> @ imm = #-0x2b0
;         fwidth = 0U;
10002f98: 2300         	movs	r3, #0x0
10002f9a: 930b         	str	r3, [sp, #0x2c]
10002f9c: 930a         	str	r3, [sp, #0x28]
10002f9e: 3302         	adds	r3, #0x2
10002fa0: 2504         	movs	r5, #0x4
10002fa2: 930c         	str	r3, [sp, #0x30]
10002fa4: e5fe         	b	0x10002ba4 <_etoa+0xc4> @ imm = #-0x404
10002fa6: 4653         	mov	r3, r10
10002fa8: 468c         	mov	r12, r1
10002faa: 3b01         	subs	r3, #0x1
10002fac: 4463         	add	r3, r12
10002fae: 1a1b         	subs	r3, r3, r0
10002fb0: e672         	b	0x10002c98 <_etoa+0x1b8> @ imm = #-0x31c
;     if ((flags & FLAGS_LEFT) && minwidth) {
10002fb2: 2302         	movs	r3, #0x2
10002fb4: 930c         	str	r3, [sp, #0x30]
;     unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
10002fb6: 2505         	movs	r5, #0x5
10002fb8: e7c2         	b	0x10002f40 <_etoa+0x460> @ imm = #-0x7c
;     if (width > minwidth) {
10002fba: 2304         	movs	r3, #0x4
10002fbc: e5ed         	b	0x10002b9a <_etoa+0xba> @ imm = #-0x426
;     idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
10002fbe: 2080         	movs	r0, #0x80
10002fc0: 9e08         	ldr	r6, [sp, #0x20]
10002fc2: 9f09         	ldr	r7, [sp, #0x24]
10002fc4: 0600         	lsls	r0, r0, #0x18
10002fc6: 0039         	movs	r1, r7
10002fc8: 4684         	mov	r12, r0
10002fca: 9a26         	ldr	r2, [sp, #0x98]
10002fcc: 4b22         	ldr	r3, [pc, #0x88]         @ 0x10003058 <_etoa+0x578>
10002fce: 4461         	add	r1, r12
10002fd0: 4013         	ands	r3, r2
10002fd2: 9304         	str	r3, [sp, #0x10]
10002fd4: 9b0b         	ldr	r3, [sp, #0x2c]
10002fd6: 0032         	movs	r2, r6
10002fd8: 9303         	str	r3, [sp, #0xc]
10002fda: 9b24         	ldr	r3, [sp, #0x90]
10002fdc: 9302         	str	r3, [sp, #0x8]
10002fde: 000b         	movs	r3, r1
10002fe0: 9200         	str	r2, [sp]
10002fe2: 9301         	str	r3, [sp, #0x4]
10002fe4: e5f3         	b	0x10002bce <_etoa+0xee> @ imm = #-0x41a
;         fwidth -= minwidth;
10002fe6: 9b25         	ldr	r3, [sp, #0x94]
10002fe8: 1b5b         	subs	r3, r3, r5
10002fea: 930b         	str	r3, [sp, #0x2c]
10002fec: e7a4         	b	0x10002f38 <_etoa+0x458> @ imm = #-0xb8
;     if ((flags & FLAGS_LEFT) && minwidth) {
10002fee: 2302         	movs	r3, #0x2
10002ff0: 2504         	movs	r5, #0x4
10002ff2: 930c         	str	r3, [sp, #0x30]
10002ff4: e7a0         	b	0x10002f38 <_etoa+0x458> @ imm = #-0xc0
;                 prec = (unsigned) ((int) prec - expval - 1);
10002ff6: 1a9c         	subs	r4, r3, r2
10002ff8: 3c01         	subs	r4, #0x1
10002ffa: e676         	b	0x10002cea <_etoa+0x20a> @ imm = #-0x314
10002ffc: 01 fc ff ff  	.word	0xfffffc01
10003000: fb 79 9f 50  	.word	0x509f79fb
10003004: 13 44 d3 3f  	.word	0x3fd34413
10003008: b3 c8 60 8b  	.word	0x8b60c8b3
1000300c: 28 8a c6 3f  	.word	0x3fc68a28
10003010: 00 00 f0 3f  	.word	0x3ff00000
10003014: 00 00 f8 3f  	.word	0x3ff80000
10003018: 61 43 6f 63  	.word	0x636f4361
1000301c: a7 87 d2 3f  	.word	0x3fd287a7
10003020: 71 a3 79 09  	.word	0x0979a371
10003024: 4f 93 0a 40  	.word	0x400a934f
10003028: 00 00 e0 3f  	.word	0x3fe00000
1000302c: 16 55 b5 bb  	.word	0xbbb55516
10003030: b1 6b 02 40  	.word	0x40026bb1
10003034: ef 39 fa fe  	.word	0xfefa39ef
10003038: 42 2e e6 3f  	.word	0x3fe62e42
1000303c: 00 00 2c 40  	.word	0x402c0000
10003040: 00 00 24 40  	.word	0x40240000
10003044: 00 00 18 40  	.word	0x40180000
10003048: ff 03 00 00  	.word	0x000003ff
1000304c: 2d 43 1c eb  	.word	0xeb1c432d
10003050: e2 36 1a 3f  	.word	0x3f1a36e2
10003054: 80 84 2e 41  	.word	0x412e8480
10003058: ff f7 ff ff  	.word	0xfffff7ff

1000305c <_vsnprintf>:
; static int _vsnprintf(out_fct_type out, char *buffer, const size_t maxlen, const char *format, va_list va) {
1000305c: b5f0         	push	{r4, r5, r6, r7, lr}
1000305e: 46de         	mov	lr, r11
10003060: 4657         	mov	r7, r10
10003062: 464e         	mov	r6, r9
10003064: 4645         	mov	r5, r8
10003066: b5e0         	push	{r5, r6, r7, lr}
10003068: b0a5         	sub	sp, #0x94
1000306a: 001e         	movs	r6, r3
1000306c: 9b2e         	ldr	r3, [sp, #0xb8]
1000306e: 4692         	mov	r10, r2
10003070: 930c         	str	r3, [sp, #0x30]
;     lazy_vsnprintf = _vsnprintf;
10003072: 4acd         	ldr	r2, [pc, #0x334]        @ 0x100033a8 <_vsnprintf+0x34c>
10003074: 4bcd         	ldr	r3, [pc, #0x334]        @ 0x100033ac <_vsnprintf+0x350>
; static int _vsnprintf(out_fct_type out, char *buffer, const size_t maxlen, const char *format, va_list va) {
10003076: 4680         	mov	r8, r0
10003078: 468b         	mov	r11, r1
;     lazy_vsnprintf = _vsnprintf;
1000307a: 601a         	str	r2, [r3]
;     if (!buffer) {
1000307c: 2900         	cmp	r1, #0x0
1000307e: d100         	bne	0x10003082 <_vsnprintf+0x26> @ imm = #0x0
10003080: e1ea         	b	0x10003458 <_vsnprintf+0x3fc> @ imm = #0x3d4
;     while (*format) {
10003082: 2300         	movs	r3, #0x0
10003084: 7830         	ldrb	r0, [r6]
10003086: 4699         	mov	r9, r3
10003088: 2800         	cmp	r0, #0x0
1000308a: d100         	bne	0x1000308e <_vsnprintf+0x32> @ imm = #0x0
1000308c: e1ec         	b	0x10003468 <_vsnprintf+0x40c> @ imm = #0x3d8
;             switch (*format) {
1000308e: 4bc8         	ldr	r3, [pc, #0x320]        @ 0x100033b0 <_vsnprintf+0x354>
10003090: 464c         	mov	r4, r9
10003092: 930b         	str	r3, [sp, #0x2c]
;         switch (*format) {
10003094: 4bc7         	ldr	r3, [pc, #0x31c]        @ 0x100033b4 <_vsnprintf+0x358>
10003096: 4645         	mov	r5, r8
10003098: 4657         	mov	r7, r10
1000309a: 930e         	str	r3, [sp, #0x38]
1000309c: e00a         	b	0x100030b4 <_vsnprintf+0x58> @ imm = #0x14
;                 out(*format, buffer, idx++, maxlen);
1000309e: 1c63         	adds	r3, r4, #0x1
100030a0: 4698         	mov	r8, r3
100030a2: 0022         	movs	r2, r4
100030a4: 003b         	movs	r3, r7
100030a6: 4659         	mov	r1, r11
100030a8: 47a8         	blx	r5
100030aa: 4644         	mov	r4, r8
;     while (*format) {
100030ac: 7830         	ldrb	r0, [r6]
100030ae: 2800         	cmp	r0, #0x0
100030b0: d100         	bne	0x100030b4 <_vsnprintf+0x58> @ imm = #0x0
100030b2: e087         	b	0x100031c4 <_vsnprintf+0x168> @ imm = #0x10e
;             format++;
100030b4: 3601         	adds	r6, #0x1
;         if (*format != '%') {
100030b6: 2825         	cmp	r0, #0x25
100030b8: d1f1         	bne	0x1000309e <_vsnprintf+0x42> @ imm = #-0x1e
;                     flags |= FLAGS_SPACE;
100030ba: 2308         	movs	r3, #0x8
100030bc: 469a         	mov	r10, r3
;                     flags |= FLAGS_PLUS;
100030be: 3b04         	subs	r3, #0x4
100030c0: 4699         	mov	r9, r3
;                     flags |= FLAGS_LEFT;
100030c2: 3b02         	subs	r3, #0x2
100030c4: 4698         	mov	r8, r3
;                     flags |= FLAGS_ZEROPAD;
100030c6: 3b01         	subs	r3, #0x1
;         flags = 0U;
100030c8: 2200         	movs	r2, #0x0
;                     flags |= FLAGS_ZEROPAD;
100030ca: 469c         	mov	r12, r3
100030cc: 940d         	str	r4, [sp, #0x34]
;             switch (*format) {
100030ce: 7830         	ldrb	r0, [r6]
;             format++;
100030d0: 1c71         	adds	r1, r6, #0x1
;             switch (*format) {
100030d2: 0003         	movs	r3, r0
100030d4: 3b20         	subs	r3, #0x20
100030d6: b2db         	uxtb	r3, r3
100030d8: 2b10         	cmp	r3, #0x10
100030da: d803         	bhi	0x100030e4 <_vsnprintf+0x88> @ imm = #0x6
100030dc: 9c0b         	ldr	r4, [sp, #0x2c]
100030de: 009b         	lsls	r3, r3, #0x2
100030e0: 58e3         	ldr	r3, [r4, r3]
100030e2: 469f         	mov	pc, r3
;         if (_is_digit(*format)) {
100030e4: 0003         	movs	r3, r0
100030e6: 3b30         	subs	r3, #0x30
100030e8: 4689         	mov	r9, r1
100030ea: 9c0d         	ldr	r4, [sp, #0x34]
100030ec: 2b09         	cmp	r3, #0x9
100030ee: d93a         	bls	0x10003166 <_vsnprintf+0x10a> @ imm = #0x74
;         width = 0U;
100030f0: 2300         	movs	r3, #0x0
100030f2: 4698         	mov	r8, r3
;         } else if (*format == '*') {
100030f4: 282a         	cmp	r0, #0x2a
100030f6: d100         	bne	0x100030fa <_vsnprintf+0x9e> @ imm = #0x0
100030f8: e0c1         	b	0x1000327e <_vsnprintf+0x222> @ imm = #0x182
;         precision = 0U;
100030fa: 2300         	movs	r3, #0x0
100030fc: 469a         	mov	r10, r3
;         if (*format == '.') {
100030fe: 282e         	cmp	r0, #0x2e
10003100: d04b         	beq	0x1000319a <_vsnprintf+0x13e> @ imm = #0x96
;         switch (*format) {
10003102: 0003         	movs	r3, r0
10003104: 3b68         	subs	r3, #0x68
10003106: b2db         	uxtb	r3, r3
10003108: 2b12         	cmp	r3, #0x12
1000310a: d81e         	bhi	0x1000314a <_vsnprintf+0xee> @ imm = #0x3c
1000310c: 990e         	ldr	r1, [sp, #0x38]
1000310e: 009b         	lsls	r3, r3, #0x2
10003110: 58cb         	ldr	r3, [r1, r3]
10003112: 469f         	mov	pc, r3
;                     flags |= FLAGS_ZEROPAD;
10003114: 4663         	mov	r3, r12
;     while (*format) {
10003116: 000e         	movs	r6, r1
;                     flags |= FLAGS_ZEROPAD;
10003118: 431a         	orrs	r2, r3
;                     break;
1000311a: e7d8         	b	0x100030ce <_vsnprintf+0x72> @ imm = #-0x50
;                     flags |= FLAGS_LEFT;
1000311c: 4643         	mov	r3, r8
;     while (*format) {
1000311e: 000e         	movs	r6, r1
;                     flags |= FLAGS_LEFT;
10003120: 431a         	orrs	r2, r3
;                     break;
10003122: e7d4         	b	0x100030ce <_vsnprintf+0x72> @ imm = #-0x58
;                     flags |= FLAGS_PLUS;
10003124: 464b         	mov	r3, r9
;     while (*format) {
10003126: 000e         	movs	r6, r1
;                     flags |= FLAGS_PLUS;
10003128: 431a         	orrs	r2, r3
;                     break;
1000312a: e7d0         	b	0x100030ce <_vsnprintf+0x72> @ imm = #-0x60
;                     flags |= FLAGS_HASH;
1000312c: 2310         	movs	r3, #0x10
;     while (*format) {
1000312e: 000e         	movs	r6, r1
;                     flags |= FLAGS_HASH;
10003130: 431a         	orrs	r2, r3
;                     break;
10003132: e7cc         	b	0x100030ce <_vsnprintf+0x72> @ imm = #-0x68
;                     flags |= FLAGS_SPACE;
10003134: 4653         	mov	r3, r10
;     while (*format) {
10003136: 000e         	movs	r6, r1
;                     flags |= FLAGS_SPACE;
10003138: 431a         	orrs	r2, r3
;                     break;
1000313a: e7c8         	b	0x100030ce <_vsnprintf+0x72> @ imm = #-0x70
;                 flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
1000313c: 2380         	movs	r3, #0x80
1000313e: 005b         	lsls	r3, r3, #0x1
10003140: 431a         	orrs	r2, r3
;                 break;
10003142: 3bff         	subs	r3, #0xff
10003144: 469c         	mov	r12, r3
;                 if (*format == 'l') {
10003146: 7870         	ldrb	r0, [r6, #0x1]
10003148: 44e1         	add	r9, r12
;                 format++;
1000314a: 464e         	mov	r6, r9
;         switch (*format) {
1000314c: 2867         	cmp	r0, #0x67
1000314e: d84f         	bhi	0x100031f0 <_vsnprintf+0x194> @ imm = #0x9e
10003150: 2824         	cmp	r0, #0x24
10003152: d9a4         	bls	0x1000309e <_vsnprintf+0x42> @ imm = #-0xb8
10003154: 0003         	movs	r3, r0
10003156: 3b25         	subs	r3, #0x25
10003158: b2db         	uxtb	r3, r3
1000315a: 2b42         	cmp	r3, #0x42
1000315c: d89f         	bhi	0x1000309e <_vsnprintf+0x42> @ imm = #-0xc2
1000315e: 4996         	ldr	r1, [pc, #0x258]        @ 0x100033b8 <_vsnprintf+0x35c>
10003160: 009b         	lsls	r3, r3, #0x2
10003162: 58cb         	ldr	r3, [r1, r3]
10003164: 469f         	mov	pc, r3
;     unsigned int i = 0U;
10003166: 2300         	movs	r3, #0x0
10003168: 4694         	mov	r12, r2
1000316a: 001e         	movs	r6, r3
1000316c: e000         	b	0x10003170 <_vsnprintf+0x114> @ imm = #0x0
1000316e: 3101         	adds	r1, #0x1
;         i = i * 10U + (unsigned int) (*((*str)++) - '0');
10003170: 00b3         	lsls	r3, r6, #0x2
10003172: 199b         	adds	r3, r3, r6
10003174: 005b         	lsls	r3, r3, #0x1
10003176: 181e         	adds	r6, r3, r0
;     while (_is_digit(**str)) {
10003178: 7808         	ldrb	r0, [r1]
;         i = i * 10U + (unsigned int) (*((*str)++) - '0');
1000317a: 3e30         	subs	r6, #0x30
;     while (_is_digit(**str)) {
1000317c: 0003         	movs	r3, r0
1000317e: 3b30         	subs	r3, #0x30
10003180: 2b09         	cmp	r3, #0x9
10003182: d9f4         	bls	0x1000316e <_vsnprintf+0x112> @ imm = #-0x18
10003184: 2301         	movs	r3, #0x1
10003186: 4662         	mov	r2, r12
10003188: 4689         	mov	r9, r1
1000318a: 469c         	mov	r12, r3
;         precision = 0U;
1000318c: 2300         	movs	r3, #0x0
1000318e: 46b0         	mov	r8, r6
10003190: 469a         	mov	r10, r3
10003192: 000e         	movs	r6, r1
10003194: 44e1         	add	r9, r12
;         if (*format == '.') {
10003196: 282e         	cmp	r0, #0x2e
10003198: d1b3         	bne	0x10003102 <_vsnprintf+0xa6> @ imm = #-0x9a
;             if (_is_digit(*format)) {
1000319a: 2130         	movs	r1, #0x30
;             flags |= FLAGS_PRECISION;
1000319c: 2080         	movs	r0, #0x80
;             if (_is_digit(*format)) {
1000319e: 4249         	rsbs	r1, r1, #0
100031a0: 468c         	mov	r12, r1
;             flags |= FLAGS_PRECISION;
100031a2: 00c0         	lsls	r0, r0, #0x3
100031a4: 4302         	orrs	r2, r0
;             if (_is_digit(*format)) {
100031a6: 7870         	ldrb	r0, [r6, #0x1]
;             format++;
100031a8: 464b         	mov	r3, r9
;             if (_is_digit(*format)) {
100031aa: 4484         	add	r12, r0
100031ac: 4661         	mov	r1, r12
100031ae: 2909         	cmp	r1, #0x9
100031b0: d800         	bhi	0x100031b4 <_vsnprintf+0x158> @ imm = #0x0
100031b2: e16c         	b	0x1000348e <_vsnprintf+0x432> @ imm = #0x2d8
;             } else if (*format == '*') {
100031b4: 282a         	cmp	r0, #0x2a
100031b6: d100         	bne	0x100031ba <_vsnprintf+0x15e> @ imm = #0x0
100031b8: e17a         	b	0x100034b0 <_vsnprintf+0x454> @ imm = #0x2f4
100031ba: 2301         	movs	r3, #0x1
100031bc: 469c         	mov	r12, r3
;             format++;
100031be: 464e         	mov	r6, r9
100031c0: 44e1         	add	r9, r12
100031c2: e79e         	b	0x10003102 <_vsnprintf+0xa6> @ imm = #-0xc4
;     return (int) idx;
100031c4: 46a1         	mov	r9, r4
100031c6: 46a8         	mov	r8, r5
100031c8: 46ba         	mov	r10, r7
;     out((char) 0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
100031ca: 45ca         	cmp	r10, r9
100031cc: d803         	bhi	0x100031d6 <_vsnprintf+0x17a> @ imm = #0x6
100031ce: 2301         	movs	r3, #0x1
100031d0: 425b         	rsbs	r3, r3, #0
100031d2: 4453         	add	r3, r10
100031d4: 4699         	mov	r9, r3
100031d6: 4653         	mov	r3, r10
100031d8: 464a         	mov	r2, r9
100031da: 4659         	mov	r1, r11
100031dc: 2000         	movs	r0, #0x0
100031de: 47c0         	blx	r8
; }
100031e0: 0020         	movs	r0, r4
100031e2: b025         	add	sp, #0x94
100031e4: bcf0         	pop	{r4, r5, r6, r7}
100031e6: 46bb         	mov	r11, r7
100031e8: 46b2         	mov	r10, r6
100031ea: 46a9         	mov	r9, r5
100031ec: 46a0         	mov	r8, r4
100031ee: bdf0         	pop	{r4, r5, r6, r7, pc}
;         switch (*format) {
100031f0: 0003         	movs	r3, r0
100031f2: 3b69         	subs	r3, #0x69
100031f4: b2db         	uxtb	r3, r3
100031f6: 930d         	str	r3, [sp, #0x34]
100031f8: 2b0f         	cmp	r3, #0xf
100031fa: d900         	bls	0x100031fe <_vsnprintf+0x1a2> @ imm = #0x0
100031fc: e74f         	b	0x1000309e <_vsnprintf+0x42> @ imm = #-0x162
100031fe: 2101         	movs	r1, #0x1
10003200: 4099         	lsls	r1, r3
10003202: 468c         	mov	r12, r1
10003204: 496d         	ldr	r1, [pc, #0x1b4]        @ 0x100033bc <_vsnprintf+0x360>
10003206: 4689         	mov	r9, r1
10003208: 4661         	mov	r1, r12
1000320a: 464b         	mov	r3, r9
1000320c: 4019         	ands	r1, r3
1000320e: 910f         	str	r1, [sp, #0x3c]
10003210: 4663         	mov	r3, r12
10003212: 4649         	mov	r1, r9
10003214: 420b         	tst	r3, r1
10003216: d000         	beq	0x1000321a <_vsnprintf+0x1be> @ imm = #0x0
10003218: e128         	b	0x1000346c <_vsnprintf+0x410> @ imm = #0x250
1000321a: 9b0d         	ldr	r3, [sp, #0x34]
1000321c: 2b0a         	cmp	r3, #0xa
1000321e: d03a         	beq	0x10003296 <_vsnprintf+0x23a> @ imm = #0x74
10003220: 2b07         	cmp	r3, #0x7
10003222: d000         	beq	0x10003226 <_vsnprintf+0x1ca> @ imm = #0x0
10003224: e73b         	b	0x1000309e <_vsnprintf+0x42> @ imm = #-0x18a
;                     idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long) ((uintptr_t) va_arg(va, void*)), false,
10003226: 9b0c         	ldr	r3, [sp, #0x30]
10003228: 0019         	movs	r1, r3
1000322a: c908         	ldm	r1!, {r3}
1000322c: 4688         	mov	r8, r1
;     if (!value) {
1000322e: 2b00         	cmp	r3, #0x0
10003230: d100         	bne	0x10003234 <_vsnprintf+0x1d8> @ imm = #0x0
10003232: e14b         	b	0x100034cc <_vsnprintf+0x470> @ imm = #0x296
;                 flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
10003234: 2021         	movs	r0, #0x21
10003236: 4302         	orrs	r2, r0
10003238: 4691         	mov	r9, r2
1000323a: a914         	add	r1, sp, #0x50
1000323c: 468c         	mov	r12, r1
1000323e: 221f         	movs	r2, #0x1f
;             const char digit = (char) (value % base);
10003240: 210f         	movs	r1, #0xf
10003242: 4462         	add	r2, r12
10003244: 468c         	mov	r12, r1
10003246: 4651         	mov	r1, r10
10003248: 950d         	str	r5, [sp, #0x34]
1000324a: 910c         	str	r1, [sp, #0x30]
1000324c: 46a2         	mov	r10, r4
1000324e: 0015         	movs	r5, r2
10003250: 990f         	ldr	r1, [sp, #0x3c]
10003252: e002         	b	0x1000325a <_vsnprintf+0x1fe> @ imm = #0x4
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
10003254: 2920         	cmp	r1, #0x20
10003256: d00c         	beq	0x10003272 <_vsnprintf+0x216> @ imm = #0x18
;             value /= base;
10003258: 0013         	movs	r3, r2
;             const char digit = (char) (value % base);
1000325a: 4664         	mov	r4, r12
1000325c: 401c         	ands	r4, r3
;             buf[len++] = (char)(digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10);
1000325e: 0020         	movs	r0, r4
10003260: 3037         	adds	r0, #0x37
10003262: 2c09         	cmp	r4, #0x9
10003264: d800         	bhi	0x10003268 <_vsnprintf+0x20c> @ imm = #0x0
10003266: 3807         	subs	r0, #0x7
10003268: 3101         	adds	r1, #0x1
1000326a: 5468         	strb	r0, [r5, r1]
;             value /= base;
1000326c: 091a         	lsrs	r2, r3, #0x4
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
1000326e: 2b0f         	cmp	r3, #0xf
10003270: d8f0         	bhi	0x10003254 <_vsnprintf+0x1f8> @ imm = #-0x20
10003272: 9b0c         	ldr	r3, [sp, #0x30]
10003274: 4654         	mov	r4, r10
10003276: 9d0d         	ldr	r5, [sp, #0x34]
10003278: 469a         	mov	r10, r3
1000327a: 910f         	str	r1, [sp, #0x3c]
1000327c: e133         	b	0x100034e6 <_vsnprintf+0x48a> @ imm = #0x266
;             const int w = va_arg(va, int);
1000327e: 9b0c         	ldr	r3, [sp, #0x30]
10003280: cb02         	ldm	r3!, {r1}
10003282: 4688         	mov	r8, r1
;             if (w < 0) {
10003284: 2900         	cmp	r1, #0x0
10003286: db47         	blt	0x10003318 <_vsnprintf+0x2bc> @ imm = #0x8e
;             const int w = va_arg(va, int);
10003288: 930c         	str	r3, [sp, #0x30]
1000328a: 2301         	movs	r3, #0x1
1000328c: 469c         	mov	r12, r3
;         if (*format == '.') {
1000328e: 7870         	ldrb	r0, [r6, #0x1]
;             format++;
10003290: 464e         	mov	r6, r9
10003292: 44e1         	add	r9, r12
10003294: e731         	b	0x100030fa <_vsnprintf+0x9e> @ imm = #-0x19e
;                 const char *p = va_arg(va, char*);
10003296: 9b0c         	ldr	r3, [sp, #0x30]
10003298: cb02         	ldm	r3!, {r1}
1000329a: 9314         	str	r3, [sp, #0x50]
;                 unsigned int l = _strnlen_s(p, precision ? precision : (size_t) -1);
1000329c: 4653         	mov	r3, r10
1000329e: 2b00         	cmp	r3, #0x0
100032a0: d100         	bne	0x100032a4 <_vsnprintf+0x248> @ imm = #0x0
100032a2: e138         	b	0x10003516 <_vsnprintf+0x4ba> @ imm = #0x270
;     for (s = str; *s && maxsize--; ++s);
100032a4: 469c         	mov	r12, r3
100032a6: 7808         	ldrb	r0, [r1]
100032a8: 000b         	movs	r3, r1
100032aa: 900c         	str	r0, [sp, #0x30]
100032ac: 448c         	add	r12, r1
100032ae: 2800         	cmp	r0, #0x0
100032b0: d101         	bne	0x100032b6 <_vsnprintf+0x25a> @ imm = #0x2
100032b2: f000 fc98    	bl	0x10003be6 <_vsnprintf+0xb8a> @ imm = #0x930
100032b6: 4689         	mov	r9, r1
100032b8: 4661         	mov	r1, r12
100032ba: 4694         	mov	r12, r2
100032bc: e003         	b	0x100032c6 <_vsnprintf+0x26a> @ imm = #0x6
100032be: 785a         	ldrb	r2, [r3, #0x1]
100032c0: 3301         	adds	r3, #0x1
100032c2: 2a00         	cmp	r2, #0x0
100032c4: d001         	beq	0x100032ca <_vsnprintf+0x26e> @ imm = #0x2
100032c6: 428b         	cmp	r3, r1
100032c8: d1f9         	bne	0x100032be <_vsnprintf+0x262> @ imm = #-0xe
;     return (unsigned int) (s - str);
100032ca: 4649         	mov	r1, r9
100032cc: 4662         	mov	r2, r12
100032ce: 1a5b         	subs	r3, r3, r1
100032d0: 900c         	str	r0, [sp, #0x30]
100032d2: 930f         	str	r3, [sp, #0x3c]
;                 if (flags & FLAGS_PRECISION) {
100032d4: 0553         	lsls	r3, r2, #0x15
100032d6: d500         	bpl	0x100032da <_vsnprintf+0x27e> @ imm = #0x0
100032d8: e120         	b	0x1000351c <_vsnprintf+0x4c0> @ imm = #0x240
;                 if (!(flags & FLAGS_LEFT)) {
100032da: 2302         	movs	r3, #0x2
100032dc: 0018         	movs	r0, r3
100032de: 4010         	ands	r0, r2
100032e0: 900d         	str	r0, [sp, #0x34]
100032e2: 4213         	tst	r3, r2
100032e4: d100         	bne	0x100032e8 <_vsnprintf+0x28c> @ imm = #0x0
100032e6: e3cb         	b	0x10003a80 <_vsnprintf+0xa24> @ imm = #0x796
100032e8: 930d         	str	r3, [sp, #0x34]
100032ea: 1b0b         	subs	r3, r1, r4
100032ec: 46b1         	mov	r9, r6
100032ee: 469a         	mov	r10, r3
100032f0: 465e         	mov	r6, r11
100032f2: 980c         	ldr	r0, [sp, #0x30]
;                     out(*(p++), buffer, idx++, maxlen);
100032f4: 0022         	movs	r2, r4
100032f6: 003b         	movs	r3, r7
100032f8: 0031         	movs	r1, r6
100032fa: 47a8         	blx	r5
;                 while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
100032fc: 4653         	mov	r3, r10
;                     out(*(p++), buffer, idx++, maxlen);
100032fe: 3401         	adds	r4, #0x1
;                 while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
10003300: 5d18         	ldrb	r0, [r3, r4]
10003302: 2800         	cmp	r0, #0x0
10003304: d1f6         	bne	0x100032f4 <_vsnprintf+0x298> @ imm = #-0x14
10003306: 46b3         	mov	r11, r6
10003308: 464e         	mov	r6, r9
;                 if (flags & FLAGS_LEFT) {
1000330a: 9b0d         	ldr	r3, [sp, #0x34]
1000330c: 2b00         	cmp	r3, #0x0
1000330e: d000         	beq	0x10003312 <_vsnprintf+0x2b6> @ imm = #0x0
10003310: e1c7         	b	0x100036a2 <_vsnprintf+0x646> @ imm = #0x38e
;                 const char *p = va_arg(va, char*);
10003312: 9b14         	ldr	r3, [sp, #0x50]
10003314: 930c         	str	r3, [sp, #0x30]
;                 break;
10003316: e6c9         	b	0x100030ac <_vsnprintf+0x50> @ imm = #-0x26e
;             const int w = va_arg(va, int);
10003318: 930c         	str	r3, [sp, #0x30]
1000331a: 2301         	movs	r3, #0x1
1000331c: 469c         	mov	r12, r3
;                 flags |= FLAGS_LEFT;    // reverse padding
1000331e: 3828         	subs	r0, #0x28
;                 width = (unsigned int) -w;
10003320: 4249         	rsbs	r1, r1, #0
;                 flags |= FLAGS_LEFT;    // reverse padding
10003322: 4302         	orrs	r2, r0
;                 width = (unsigned int) -w;
10003324: 4688         	mov	r8, r1
;         if (*format == '.') {
10003326: 7870         	ldrb	r0, [r6, #0x1]
;             format++;
10003328: 464e         	mov	r6, r9
1000332a: 44e1         	add	r9, r12
1000332c: e6e5         	b	0x100030fa <_vsnprintf+0x9e> @ imm = #-0x236
;                 if (*format == 'l') {
1000332e: 7870         	ldrb	r0, [r6, #0x1]
10003330: 286c         	cmp	r0, #0x6c
10003332: d100         	bne	0x10003336 <_vsnprintf+0x2da> @ imm = #0x0
10003334: e17f         	b	0x10003636 <_vsnprintf+0x5da> @ imm = #0x2fe
;                 flags |= FLAGS_LONG;
10003336: 2380         	movs	r3, #0x80
10003338: 005b         	lsls	r3, r3, #0x1
1000333a: 431a         	orrs	r2, r3
1000333c: 3bff         	subs	r3, #0xff
1000333e: 469c         	mov	r12, r3
10003340: 44e1         	add	r9, r12
10003342: e702         	b	0x1000314a <_vsnprintf+0xee> @ imm = #-0x1fc
;                 flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
10003344: 2380         	movs	r3, #0x80
10003346: 009b         	lsls	r3, r3, #0x2
10003348: 431a         	orrs	r2, r3
;                 break;
1000334a: 2301         	movs	r3, #0x1
1000334c: 469c         	mov	r12, r3
;                 if (*format == 'l') {
1000334e: 7870         	ldrb	r0, [r6, #0x1]
10003350: 44e1         	add	r9, r12
;                 break;
10003352: e6fa         	b	0x1000314a <_vsnprintf+0xee> @ imm = #-0x20c
;                 if (*format == 'h') {
10003354: 7870         	ldrb	r0, [r6, #0x1]
10003356: 2868         	cmp	r0, #0x68
10003358: d100         	bne	0x1000335c <_vsnprintf+0x300> @ imm = #0x0
1000335a: e173         	b	0x10003644 <_vsnprintf+0x5e8> @ imm = #0x2e6
;                 flags |= FLAGS_SHORT;
1000335c: 2380         	movs	r3, #0x80
1000335e: 431a         	orrs	r2, r3
10003360: 3b7f         	subs	r3, #0x7f
10003362: 469c         	mov	r12, r3
10003364: 44e1         	add	r9, r12
10003366: e6f0         	b	0x1000314a <_vsnprintf+0xee> @ imm = #-0x220
;                 if ((*format == 'g') || (*format == 'G')) flags |= FLAGS_ADAPT_EXP;
10003368: 2867         	cmp	r0, #0x67
1000336a: d100         	bne	0x1000336e <_vsnprintf+0x312> @ imm = #0x0
1000336c: e103         	b	0x10003576 <_vsnprintf+0x51a> @ imm = #0x206
1000336e: 2847         	cmp	r0, #0x47
10003370: d100         	bne	0x10003374 <_vsnprintf+0x318> @ imm = #0x0
10003372: e15a         	b	0x1000362a <_vsnprintf+0x5ce> @ imm = #0x2b4
;                 if ((*format == 'E') || (*format == 'G')) flags |= FLAGS_UPPERCASE;
10003374: 2845         	cmp	r0, #0x45
10003376: d100         	bne	0x1000337a <_vsnprintf+0x31e> @ imm = #0x0
10003378: e15a         	b	0x10003630 <_vsnprintf+0x5d4> @ imm = #0x2b4
;                 idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
1000337a: 9204         	str	r2, [sp, #0x10]
1000337c: 2107         	movs	r1, #0x7
1000337e: 4642         	mov	r2, r8
10003380: 9b0c         	ldr	r3, [sp, #0x30]
10003382: 9203         	str	r2, [sp, #0xc]
10003384: 3307         	adds	r3, #0x7
10003386: 4652         	mov	r2, r10
10003388: 438b         	bics	r3, r1
1000338a: 0019         	movs	r1, r3
1000338c: 9202         	str	r2, [sp, #0x8]
1000338e: c90c         	ldm	r1!, {r2, r3}
10003390: 0028         	movs	r0, r5
10003392: 9200         	str	r2, [sp]
10003394: 9301         	str	r3, [sp, #0x4]
10003396: 910c         	str	r1, [sp, #0x30]
10003398: 0022         	movs	r2, r4
1000339a: 003b         	movs	r3, r7
1000339c: 4659         	mov	r1, r11
1000339e: f7ff fb9f    	bl	0x10002ae0 <_etoa>      @ imm = #-0x8c2
100033a2: 0004         	movs	r4, r0
;                 break;
100033a4: e682         	b	0x100030ac <_vsnprintf+0x50> @ imm = #-0x2fc
100033a6: 46c0         	mov	r8, r8
100033a8: 5d 30 00 10  	.word	0x1000305d
100033ac: 9c 05 00 20  	.word	0x2000059c
100033b0: 94 44 00 10  	.word	0x10004494
100033b4: d8 44 00 10  	.word	0x100044d8
100033b8: 24 45 00 10  	.word	0x10004524
100033bc: 41 90 00 00  	.word	0x00009041
;                 if (*format == 'F') flags |= FLAGS_UPPERCASE;
100033c0: 2846         	cmp	r0, #0x46
100033c2: d100         	bne	0x100033c6 <_vsnprintf+0x36a> @ imm = #0x0
100033c4: e0db         	b	0x1000357e <_vsnprintf+0x522> @ imm = #0x1b6
;                 idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
100033c6: 9204         	str	r2, [sp, #0x10]
100033c8: 2107         	movs	r1, #0x7
100033ca: 4642         	mov	r2, r8
100033cc: 9b0c         	ldr	r3, [sp, #0x30]
100033ce: 9203         	str	r2, [sp, #0xc]
100033d0: 3307         	adds	r3, #0x7
100033d2: 4652         	mov	r2, r10
100033d4: 438b         	bics	r3, r1
100033d6: 0019         	movs	r1, r3
100033d8: 9202         	str	r2, [sp, #0x8]
100033da: c90c         	ldm	r1!, {r2, r3}
100033dc: 0028         	movs	r0, r5
100033de: 9200         	str	r2, [sp]
100033e0: 9301         	str	r3, [sp, #0x4]
100033e2: 910c         	str	r1, [sp, #0x30]
100033e4: 0022         	movs	r2, r4
100033e6: 003b         	movs	r3, r7
100033e8: 4659         	mov	r1, r11
100033ea: f7ff f925    	bl	0x10002638 <_ftoa>      @ imm = #-0xdb6
100033ee: 0004         	movs	r4, r0
;                 break;
100033f0: e65c         	b	0x100030ac <_vsnprintf+0x50> @ imm = #-0x348
;                 out('%', buffer, idx++, maxlen);
100033f2: 1c63         	adds	r3, r4, #0x1
100033f4: 4698         	mov	r8, r3
100033f6: 0022         	movs	r2, r4
100033f8: 003b         	movs	r3, r7
100033fa: 4659         	mov	r1, r11
100033fc: 2025         	movs	r0, #0x25
100033fe: 47a8         	blx	r5
10003400: 4644         	mov	r4, r8
;                 break;
10003402: e653         	b	0x100030ac <_vsnprintf+0x50> @ imm = #-0x35a
;                         const long value = va_arg(va, long);
10003404: 9b0c         	ldr	r3, [sp, #0x30]
10003406: 3304         	adds	r3, #0x4
10003408: 930d         	str	r3, [sp, #0x34]
;             out(*format, buffer, idx++, maxlen);
1000340a: 1c63         	adds	r3, r4, #0x1
1000340c: 4699         	mov	r9, r3
;                 if (!(flags & FLAGS_LEFT)) {
1000340e: 0792         	lsls	r2, r2, #0x1e
10003410: d400         	bmi	0x10003414 <_vsnprintf+0x3b8> @ imm = #0x0
10003412: e122         	b	0x1000365a <_vsnprintf+0x5fe> @ imm = #0x244
;                 out((char) va_arg(va, int), buffer, idx++, maxlen);
10003414: 9b0c         	ldr	r3, [sp, #0x30]
10003416: 0022         	movs	r2, r4
10003418: 7818         	ldrb	r0, [r3]
1000341a: 4659         	mov	r1, r11
1000341c: 003b         	movs	r3, r7
1000341e: 47a8         	blx	r5
;                     while (l++ < width) {
10003420: 4643         	mov	r3, r8
10003422: 4444         	add	r4, r8
10003424: 2b01         	cmp	r3, #0x1
10003426: d800         	bhi	0x1000342a <_vsnprintf+0x3ce> @ imm = #0x0
10003428: e285         	b	0x10003936 <_vsnprintf+0x8da> @ imm = #0x50a
1000342a: 0033         	movs	r3, r6
1000342c: 46b8         	mov	r8, r7
1000342e: 002e         	movs	r6, r5
10003430: 465f         	mov	r7, r11
10003432: 0025         	movs	r5, r4
10003434: 464c         	mov	r4, r9
10003436: 4699         	mov	r9, r3
;                         out(' ', buffer, idx++, maxlen);
10003438: 0022         	movs	r2, r4
1000343a: 4643         	mov	r3, r8
1000343c: 3401         	adds	r4, #0x1
1000343e: 0039         	movs	r1, r7
10003440: 2020         	movs	r0, #0x20
10003442: 47b0         	blx	r6
;                     while (l++ < width) {
10003444: 42ac         	cmp	r4, r5
10003446: d1f7         	bne	0x10003438 <_vsnprintf+0x3dc> @ imm = #-0x12
10003448: 002c         	movs	r4, r5
1000344a: 46bb         	mov	r11, r7
1000344c: 0035         	movs	r5, r6
1000344e: 4647         	mov	r7, r8
10003450: 464e         	mov	r6, r9
;                 out((char) va_arg(va, int), buffer, idx++, maxlen);
10003452: 9b0d         	ldr	r3, [sp, #0x34]
10003454: 930c         	str	r3, [sp, #0x30]
;                 break;
10003456: e629         	b	0x100030ac <_vsnprintf+0x50> @ imm = #-0x3ae
;         out = _out_null;
10003458: 4bdb         	ldr	r3, [pc, #0x36c]        @ 0x100037c8 <_vsnprintf+0x76c>
;     while (*format) {
1000345a: 7830         	ldrb	r0, [r6]
;         out = _out_null;
1000345c: 4698         	mov	r8, r3
;     while (*format) {
1000345e: 2300         	movs	r3, #0x0
10003460: 4699         	mov	r9, r3
10003462: 2800         	cmp	r0, #0x0
10003464: d000         	beq	0x10003468 <_vsnprintf+0x40c> @ imm = #0x0
10003466: e612         	b	0x1000308e <_vsnprintf+0x32> @ imm = #-0x3dc
10003468: 2400         	movs	r4, #0x0
1000346a: e6ae         	b	0x100031ca <_vsnprintf+0x16e> @ imm = #-0x2a4
;                 if (*format == 'x' || *format == 'X') {
1000346c: 286f         	cmp	r0, #0x6f
1000346e: d100         	bne	0x10003472 <_vsnprintf+0x416> @ imm = #0x0
10003470: e088         	b	0x10003584 <_vsnprintf+0x528> @ imm = #0x110
10003472: d800         	bhi	0x10003476 <_vsnprintf+0x41a> @ imm = #0x0
10003474: e30b         	b	0x10003a8e <_vsnprintf+0xa32> @ imm = #0x616
;                     flags &= ~FLAGS_HASH;   // no hash for dec format
10003476: 2310         	movs	r3, #0x10
10003478: 2878         	cmp	r0, #0x78
1000347a: d100         	bne	0x1000347e <_vsnprintf+0x422> @ imm = #0x0
1000347c: e0cf         	b	0x1000361e <_vsnprintf+0x5c2> @ imm = #0x19e
1000347e: 439a         	bics	r2, r3
;                 if ((*format != 'i') && (*format != 'd')) {
10003480: 230a         	movs	r3, #0xa
10003482: 469c         	mov	r12, r3
10003484: 2300         	movs	r3, #0x0
10003486: 930f         	str	r3, [sp, #0x3c]
10003488: 330a         	adds	r3, #0xa
1000348a: 930d         	str	r3, [sp, #0x34]
1000348c: e080         	b	0x10003590 <_vsnprintf+0x534> @ imm = #0x100
1000348e: 4656         	mov	r6, r10
;         i = i * 10U + (unsigned int) (*((*str)++) - '0');
10003490: 00b1         	lsls	r1, r6, #0x2
10003492: 1989         	adds	r1, r1, r6
10003494: 0049         	lsls	r1, r1, #0x1
10003496: 3301         	adds	r3, #0x1
10003498: 180e         	adds	r6, r1, r0
;     while (_is_digit(**str)) {
1000349a: 7818         	ldrb	r0, [r3]
;         i = i * 10U + (unsigned int) (*((*str)++) - '0');
1000349c: 3e30         	subs	r6, #0x30
;     while (_is_digit(**str)) {
1000349e: 0001         	movs	r1, r0
100034a0: 3930         	subs	r1, #0x30
100034a2: 2909         	cmp	r1, #0x9
100034a4: d9f4         	bls	0x10003490 <_vsnprintf+0x434> @ imm = #-0x18
100034a6: 46b2         	mov	r10, r6
100034a8: 001e         	movs	r6, r3
100034aa: 3301         	adds	r3, #0x1
100034ac: 4699         	mov	r9, r3
100034ae: e628         	b	0x10003102 <_vsnprintf+0xa6> @ imm = #-0x3b0
;                 const int prec = (int) va_arg(va, int);
100034b0: 9b0c         	ldr	r3, [sp, #0x30]
;                 format++;
100034b2: 3602         	adds	r6, #0x2
;                 precision = prec > 0 ? (unsigned int) prec : 0U;
100034b4: cb02         	ldm	r3!, {r1}
100034b6: 468a         	mov	r10, r1
100034b8: 43c9         	mvns	r1, r1
100034ba: 4650         	mov	r0, r10
100034bc: 17c9         	asrs	r1, r1, #0x1f
100034be: 4008         	ands	r0, r1
100034c0: 4682         	mov	r10, r0
;                 const int prec = (int) va_arg(va, int);
100034c2: 930c         	str	r3, [sp, #0x30]
;         switch (*format) {
100034c4: 7830         	ldrb	r0, [r6]
100034c6: 1c73         	adds	r3, r6, #0x1
100034c8: 4699         	mov	r9, r3
100034ca: e61a         	b	0x10003102 <_vsnprintf+0xa6> @ imm = #-0x3cc
;         flags &= ~FLAGS_HASH;
100034cc: 2310         	movs	r3, #0x10
100034ce: 0010         	movs	r0, r2
100034d0: 4398         	bics	r0, r3
100034d2: 3311         	adds	r3, #0x11
100034d4: 4318         	orrs	r0, r3
100034d6: 4681         	mov	r9, r0
;     if (!(flags & FLAGS_PRECISION) || value) {
100034d8: 2080         	movs	r0, #0x80
100034da: 0013         	movs	r3, r2
100034dc: 00c0         	lsls	r0, r0, #0x3
100034de: 4003         	ands	r3, r0
100034e0: 4202         	tst	r2, r0
100034e2: d100         	bne	0x100034e6 <_vsnprintf+0x48a> @ imm = #0x0
100034e4: e6a9         	b	0x1000323a <_vsnprintf+0x1de> @ imm = #-0x2ae
;     return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int) base, prec, width, flags);
100034e6: 464b         	mov	r3, r9
100034e8: 9306         	str	r3, [sp, #0x18]
100034ea: 2308         	movs	r3, #0x8
100034ec: 9305         	str	r3, [sp, #0x14]
100034ee: 4653         	mov	r3, r10
100034f0: 9304         	str	r3, [sp, #0x10]
100034f2: 2310         	movs	r3, #0x10
100034f4: 9303         	str	r3, [sp, #0xc]
100034f6: 2300         	movs	r3, #0x0
100034f8: 9302         	str	r3, [sp, #0x8]
100034fa: 9b0f         	ldr	r3, [sp, #0x3c]
100034fc: 0022         	movs	r2, r4
100034fe: 9301         	str	r3, [sp, #0x4]
10003500: ab1c         	add	r3, sp, #0x70
10003502: 9300         	str	r3, [sp]
10003504: 4659         	mov	r1, r11
10003506: 003b         	movs	r3, r7
10003508: 0028         	movs	r0, r5
1000350a: f7fe ff9f    	bl	0x1000244c <_ntoa_format> @ imm = #-0x10c2
;                     idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long) ((uintptr_t) va_arg(va, void*)), false,
1000350e: 4643         	mov	r3, r8
;     return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int) base, prec, width, flags);
10003510: 0004         	movs	r4, r0
;                     idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long) ((uintptr_t) va_arg(va, void*)), false,
10003512: 930c         	str	r3, [sp, #0x30]
;                 break;
10003514: e5ca         	b	0x100030ac <_vsnprintf+0x50> @ imm = #-0x46c
;                 unsigned int l = _strnlen_s(p, precision ? precision : (size_t) -1);
10003516: 2301         	movs	r3, #0x1
10003518: 425b         	rsbs	r3, r3, #0
1000351a: e6c3         	b	0x100032a4 <_vsnprintf+0x248> @ imm = #-0x27a
;                     l = (l < precision ? l : precision);
1000351c: 9b0f         	ldr	r3, [sp, #0x3c]
1000351e: 4553         	cmp	r3, r10
10003520: d901         	bls	0x10003526 <_vsnprintf+0x4ca> @ imm = #0x2
10003522: 4653         	mov	r3, r10
10003524: 930f         	str	r3, [sp, #0x3c]
;                 if (!(flags & FLAGS_LEFT)) {
10003526: 2302         	movs	r3, #0x2
10003528: 0018         	movs	r0, r3
1000352a: 4010         	ands	r0, r2
1000352c: 900d         	str	r0, [sp, #0x34]
1000352e: 4213         	tst	r3, r2
10003530: d100         	bne	0x10003534 <_vsnprintf+0x4d8> @ imm = #0x0
10003532: e1b7         	b	0x100038a4 <_vsnprintf+0x848> @ imm = #0x36e
;                 while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
10003534: 930d         	str	r3, [sp, #0x34]
10003536: 46d1         	mov	r9, r10
10003538: 1b0b         	subs	r3, r1, r4
1000353a: 469a         	mov	r10, r3
1000353c: 0033         	movs	r3, r6
1000353e: 44a1         	add	r9, r4
10003540: 002e         	movs	r6, r5
;                 if (!(flags & FLAGS_LEFT)) {
10003542: 0022         	movs	r2, r4
10003544: 464d         	mov	r5, r9
10003546: 980c         	ldr	r0, [sp, #0x30]
10003548: 46b9         	mov	r9, r7
1000354a: 465f         	mov	r7, r11
1000354c: 469b         	mov	r11, r3
1000354e: e008         	b	0x10003562 <_vsnprintf+0x506> @ imm = #0x10
;                     out(*(p++), buffer, idx++, maxlen);
10003550: 464b         	mov	r3, r9
10003552: 0039         	movs	r1, r7
10003554: 1c54         	adds	r4, r2, #0x1
10003556: 47b0         	blx	r6
;                 while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
10003558: 4653         	mov	r3, r10
1000355a: 5d18         	ldrb	r0, [r3, r4]
1000355c: 2800         	cmp	r0, #0x0
1000355e: d077         	beq	0x10003650 <_vsnprintf+0x5f4> @ imm = #0xee
;                     out(*(p++), buffer, idx++, maxlen);
10003560: 0022         	movs	r2, r4
;                 while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
10003562: 4295         	cmp	r5, r2
10003564: d1f4         	bne	0x10003550 <_vsnprintf+0x4f4> @ imm = #-0x18
10003566: 465b         	mov	r3, r11
10003568: 46bb         	mov	r11, r7
1000356a: 464f         	mov	r7, r9
1000356c: 46a9         	mov	r9, r5
1000356e: 0035         	movs	r5, r6
10003570: 464c         	mov	r4, r9
10003572: 001e         	movs	r6, r3
10003574: e6c9         	b	0x1000330a <_vsnprintf+0x2ae> @ imm = #-0x26e
;                 if ((*format == 'g') || (*format == 'G')) flags |= FLAGS_ADAPT_EXP;
10003576: 2380         	movs	r3, #0x80
10003578: 011b         	lsls	r3, r3, #0x4
1000357a: 431a         	orrs	r2, r3
;                 if ((*format == 'E') || (*format == 'G')) flags |= FLAGS_UPPERCASE;
1000357c: e6fd         	b	0x1000337a <_vsnprintf+0x31e> @ imm = #-0x206
;                 if (*format == 'F') flags |= FLAGS_UPPERCASE;
1000357e: 2320         	movs	r3, #0x20
10003580: 431a         	orrs	r2, r3
10003582: e720         	b	0x100033c6 <_vsnprintf+0x36a> @ imm = #-0x1c0
;         switch (*format) {
10003584: 2308         	movs	r3, #0x8
10003586: 469c         	mov	r12, r3
10003588: 2300         	movs	r3, #0x0
1000358a: 930f         	str	r3, [sp, #0x3c]
1000358c: 3308         	adds	r3, #0x8
1000358e: 930d         	str	r3, [sp, #0x34]
;                 if (flags & FLAGS_PRECISION) {
10003590: 2380         	movs	r3, #0x80
10003592: 0011         	movs	r1, r2
10003594: 00db         	lsls	r3, r3, #0x3
10003596: 4019         	ands	r1, r3
10003598: 421a         	tst	r2, r3
1000359a: d100         	bne	0x1000359e <_vsnprintf+0x542> @ imm = #0x0
1000359c: e116         	b	0x100037cc <_vsnprintf+0x770> @ imm = #0x22c
;                     flags &= ~FLAGS_ZEROPAD;
1000359e: 230d         	movs	r3, #0xd
100035a0: 439a         	bics	r2, r3
100035a2: 0010         	movs	r0, r2
;                     if (flags & FLAGS_LONG_LONG) {
100035a4: 2380         	movs	r3, #0x80
100035a6: 0002         	movs	r2, r0
100035a8: 009b         	lsls	r3, r3, #0x2
100035aa: 401a         	ands	r2, r3
100035ac: 9214         	str	r2, [sp, #0x50]
100035ae: 4218         	tst	r0, r3
100035b0: d000         	beq	0x100035b4 <_vsnprintf+0x558> @ imm = #0x0
100035b2: e1c2         	b	0x1000393a <_vsnprintf+0x8de> @ imm = #0x384
;                     } else if (flags & FLAGS_LONG) {
100035b4: 2380         	movs	r3, #0x80
100035b6: 0002         	movs	r2, r0
100035b8: 005b         	lsls	r3, r3, #0x1
100035ba: 401a         	ands	r2, r3
100035bc: 4691         	mov	r9, r2
;                         const long value = va_arg(va, long);
100035be: 9a0c         	ldr	r2, [sp, #0x30]
100035c0: 3204         	adds	r2, #0x4
100035c2: 920f         	str	r2, [sp, #0x3c]
;                     } else if (flags & FLAGS_LONG) {
100035c4: 4218         	tst	r0, r3
100035c6: d000         	beq	0x100035ca <_vsnprintf+0x56e> @ imm = #0x0
100035c8: e2b7         	b	0x10003b3a <_vsnprintf+0xade> @ imm = #0x56e
;                                                                         : (flags & FLAGS_SHORT)
100035ca: 0643         	lsls	r3, r0, #0x19
100035cc: d500         	bpl	0x100035d0 <_vsnprintf+0x574> @ imm = #0x0
100035ce: e19f         	b	0x10003910 <_vsnprintf+0x8b4> @ imm = #0x33e
;                                                                           : va_arg(va, unsigned int);
100035d0: 0603         	lsls	r3, r0, #0x18
100035d2: d400         	bmi	0x100035d6 <_vsnprintf+0x57a> @ imm = #0x0
100035d4: e319         	b	0x10003c0a <_vsnprintf+0xbae> @ imm = #0x632
100035d6: 9b0c         	ldr	r3, [sp, #0x30]
100035d8: 881b         	ldrh	r3, [r3]
100035da: 9309         	str	r3, [sp, #0x24]
;     if (!value) {
100035dc: 2b00         	cmp	r3, #0x0
100035de: d000         	beq	0x100035e2 <_vsnprintf+0x586> @ imm = #0x0
100035e0: e1fc         	b	0x100039dc <_vsnprintf+0x980> @ imm = #0x3f8
;         flags &= ~FLAGS_HASH;
100035e2: 3310         	adds	r3, #0x10
100035e4: 4398         	bics	r0, r3
;     if (!(flags & FLAGS_PRECISION) || value) {
100035e6: 2900         	cmp	r1, #0x0
100035e8: d100         	bne	0x100035ec <_vsnprintf+0x590> @ imm = #0x0
100035ea: e1f7         	b	0x100039dc <_vsnprintf+0x980> @ imm = #0x3ee
;     size_t len = 0U;
100035ec: 2300         	movs	r3, #0x0
100035ee: 4699         	mov	r9, r3
;     return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int) base, prec, width, flags);
100035f0: 4643         	mov	r3, r8
100035f2: 9305         	str	r3, [sp, #0x14]
100035f4: 4653         	mov	r3, r10
100035f6: 9304         	str	r3, [sp, #0x10]
100035f8: 9b0d         	ldr	r3, [sp, #0x34]
100035fa: 9006         	str	r0, [sp, #0x18]
100035fc: 9303         	str	r3, [sp, #0xc]
100035fe: 2300         	movs	r3, #0x0
10003600: e0d2         	b	0x100037a8 <_vsnprintf+0x74c> @ imm = #0x1a4
10003602: 2858         	cmp	r0, #0x58
10003604: d008         	beq	0x10003618 <_vsnprintf+0x5bc> @ imm = #0x10
10003606: 2862         	cmp	r0, #0x62
10003608: d167         	bne	0x100036da <_vsnprintf+0x67e> @ imm = #0xce
;         switch (*format) {
1000360a: 2302         	movs	r3, #0x2
1000360c: 469c         	mov	r12, r3
1000360e: 2300         	movs	r3, #0x0
10003610: 930f         	str	r3, [sp, #0x3c]
10003612: 3302         	adds	r3, #0x2
10003614: 930d         	str	r3, [sp, #0x34]
10003616: e7bb         	b	0x10003590 <_vsnprintf+0x534> @ imm = #-0x8a
;                     flags |= FLAGS_UPPERCASE;
10003618: 2320         	movs	r3, #0x20
1000361a: 431a         	orrs	r2, r3
1000361c: 3b10         	subs	r3, #0x10
;         switch (*format) {
1000361e: 469c         	mov	r12, r3
10003620: 2300         	movs	r3, #0x0
10003622: 930f         	str	r3, [sp, #0x3c]
10003624: 3310         	adds	r3, #0x10
10003626: 930d         	str	r3, [sp, #0x34]
10003628: e7b2         	b	0x10003590 <_vsnprintf+0x534> @ imm = #-0x9c
;                 if ((*format == 'g') || (*format == 'G')) flags |= FLAGS_ADAPT_EXP;
1000362a: 2380         	movs	r3, #0x80
1000362c: 011b         	lsls	r3, r3, #0x4
1000362e: 431a         	orrs	r2, r3
;                 if ((*format == 'E') || (*format == 'G')) flags |= FLAGS_UPPERCASE;
10003630: 2320         	movs	r3, #0x20
10003632: 431a         	orrs	r2, r3
10003634: e6a1         	b	0x1000337a <_vsnprintf+0x31e> @ imm = #-0x2be
;                     flags |= FLAGS_LONG_LONG;
10003636: 23c0         	movs	r3, #0xc0
10003638: 009b         	lsls	r3, r3, #0x2
1000363a: 431a         	orrs	r2, r3
;                     format++;
1000363c: 1cf3         	adds	r3, r6, #0x3
1000363e: 4699         	mov	r9, r3
;         switch (*format) {
10003640: 78b0         	ldrb	r0, [r6, #0x2]
10003642: e582         	b	0x1000314a <_vsnprintf+0xee> @ imm = #-0x4fc
;                     flags |= FLAGS_CHAR;
10003644: 23c0         	movs	r3, #0xc0
10003646: 431a         	orrs	r2, r3
;                     format++;
10003648: 1cf3         	adds	r3, r6, #0x3
1000364a: 4699         	mov	r9, r3
;         switch (*format) {
1000364c: 78b0         	ldrb	r0, [r6, #0x2]
1000364e: e57c         	b	0x1000314a <_vsnprintf+0xee> @ imm = #-0x508
10003650: 0035         	movs	r5, r6
10003652: 465e         	mov	r6, r11
10003654: 46bb         	mov	r11, r7
10003656: 464f         	mov	r7, r9
10003658: e657         	b	0x1000330a <_vsnprintf+0x2ae> @ imm = #-0x352
;                     while (l++ < width) {
1000365a: 4643         	mov	r3, r8
1000365c: 2b01         	cmp	r3, #0x1
1000365e: d800         	bhi	0x10003662 <_vsnprintf+0x606> @ imm = #0x0
10003660: e163         	b	0x1000392a <_vsnprintf+0x8ce> @ imm = #0x2c6
10003662: 1e63         	subs	r3, r4, #0x1
10003664: 4443         	add	r3, r8
10003666: 469a         	mov	r10, r3
10003668: 0033         	movs	r3, r6
1000366a: 46b9         	mov	r9, r7
1000366c: 002e         	movs	r6, r5
1000366e: 465f         	mov	r7, r11
10003670: 4655         	mov	r5, r10
10003672: 469b         	mov	r11, r3
10003674: 46a2         	mov	r10, r4
;                         out(' ', buffer, idx++, maxlen);
10003676: 0022         	movs	r2, r4
10003678: 464b         	mov	r3, r9
1000367a: 3401         	adds	r4, #0x1
1000367c: 0039         	movs	r1, r7
1000367e: 2020         	movs	r0, #0x20
10003680: 47b0         	blx	r6
;                     while (l++ < width) {
10003682: 42ac         	cmp	r4, r5
10003684: d1f7         	bne	0x10003676 <_vsnprintf+0x61a> @ imm = #-0x12
;                 out((char) va_arg(va, int), buffer, idx++, maxlen);
10003686: 0035         	movs	r5, r6
10003688: 465e         	mov	r6, r11
1000368a: 46bb         	mov	r11, r7
1000368c: 464f         	mov	r7, r9
1000368e: 46a1         	mov	r9, r4
10003690: 4654         	mov	r4, r10
10003692: 9b0c         	ldr	r3, [sp, #0x30]
10003694: 464a         	mov	r2, r9
10003696: 7818         	ldrb	r0, [r3]
10003698: 4659         	mov	r1, r11
1000369a: 003b         	movs	r3, r7
1000369c: 4444         	add	r4, r8
1000369e: 47a8         	blx	r5
;                 if (flags & FLAGS_LEFT) {
100036a0: e6d7         	b	0x10003452 <_vsnprintf+0x3f6> @ imm = #-0x252
100036a2: 46a1         	mov	r9, r4
;                     while (l++ < width) {
100036a4: 9b0f         	ldr	r3, [sp, #0x3c]
100036a6: 4598         	cmp	r8, r3
100036a8: d800         	bhi	0x100036ac <_vsnprintf+0x650> @ imm = #0x0
100036aa: e632         	b	0x10003312 <_vsnprintf+0x2b6> @ imm = #-0x39c
100036ac: 4444         	add	r4, r8
100036ae: 1ae4         	subs	r4, r4, r3
100036b0: 0033         	movs	r3, r6
100036b2: 46b8         	mov	r8, r7
100036b4: 002e         	movs	r6, r5
100036b6: 465f         	mov	r7, r11
100036b8: 0025         	movs	r5, r4
100036ba: 464c         	mov	r4, r9
100036bc: 4699         	mov	r9, r3
;                         out(' ', buffer, idx++, maxlen);
100036be: 0022         	movs	r2, r4
100036c0: 4643         	mov	r3, r8
100036c2: 3401         	adds	r4, #0x1
100036c4: 0039         	movs	r1, r7
100036c6: 2020         	movs	r0, #0x20
100036c8: 47b0         	blx	r6
;                     while (l++ < width) {
100036ca: 42ac         	cmp	r4, r5
100036cc: d1f7         	bne	0x100036be <_vsnprintf+0x662> @ imm = #-0x12
100036ce: 002c         	movs	r4, r5
100036d0: 46bb         	mov	r11, r7
100036d2: 0035         	movs	r5, r6
100036d4: 4647         	mov	r7, r8
100036d6: 464e         	mov	r6, r9
100036d8: e61b         	b	0x10003312 <_vsnprintf+0x2b6> @ imm = #-0x3ca
;                 if (flags & FLAGS_PRECISION) {
100036da: 2380         	movs	r3, #0x80
100036dc: 0010         	movs	r0, r2
100036de: 00db         	lsls	r3, r3, #0x3
100036e0: 4018         	ands	r0, r3
100036e2: 421a         	tst	r2, r3
100036e4: d100         	bne	0x100036e8 <_vsnprintf+0x68c> @ imm = #0x0
100036e6: e10f         	b	0x10003908 <_vsnprintf+0x8ac> @ imm = #0x21e
;                     flags &= ~FLAGS_ZEROPAD;
100036e8: 2111         	movs	r1, #0x11
100036ea: 0018         	movs	r0, r3
100036ec: 438a         	bics	r2, r1
100036ee: 920d         	str	r2, [sp, #0x34]
;                     if (flags & FLAGS_LONG_LONG) {
100036f0: 9a0d         	ldr	r2, [sp, #0x34]
100036f2: 2380         	movs	r3, #0x80
100036f4: 0011         	movs	r1, r2
100036f6: 009b         	lsls	r3, r3, #0x2
100036f8: 4019         	ands	r1, r3
100036fa: 468c         	mov	r12, r1
100036fc: 421a         	tst	r2, r3
100036fe: d169         	bne	0x100037d4 <_vsnprintf+0x778> @ imm = #0xd2
;                     } else if (flags & FLAGS_LONG) {
10003700: 2380         	movs	r3, #0x80
10003702: 0011         	movs	r1, r2
10003704: 005b         	lsls	r3, r3, #0x1
10003706: 4019         	ands	r1, r3
10003708: 4689         	mov	r9, r1
;                         const long value = va_arg(va, long);
1000370a: 990c         	ldr	r1, [sp, #0x30]
1000370c: 3104         	adds	r1, #0x4
1000370e: 910f         	str	r1, [sp, #0x3c]
;                     } else if (flags & FLAGS_LONG) {
10003710: 421a         	tst	r2, r3
10003712: d000         	beq	0x10003716 <_vsnprintf+0x6ba> @ imm = #0x0
10003714: e1ca         	b	0x10003aac <_vsnprintf+0xa50> @ imm = #0x394
10003716: 0013         	movs	r3, r2
;                         const int value = (flags & FLAGS_CHAR) ? (char) va_arg(va, int) : (flags & FLAGS_SHORT)
10003718: 065b         	lsls	r3, r3, #0x19
1000371a: d500         	bpl	0x1000371e <_vsnprintf+0x6c2> @ imm = #0x0
1000371c: e0f0         	b	0x10003900 <_vsnprintf+0x8a4> @ imm = #0x1e0
1000371e: 0013         	movs	r3, r2
;                                                                                           : va_arg(va, int);
10003720: 061b         	lsls	r3, r3, #0x18
10003722: d400         	bmi	0x10003726 <_vsnprintf+0x6ca> @ imm = #0x0
10003724: e259         	b	0x10003bda <_vsnprintf+0xb7e> @ imm = #0x4b2
10003726: 9b0c         	ldr	r3, [sp, #0x30]
10003728: 2200         	movs	r2, #0x0
1000372a: 5e9b         	ldrsh	r3, [r3, r2]
;                         idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int) (value > 0 ? value : 0 - value),
1000372c: 17d9         	asrs	r1, r3, #0x1f
1000372e: 185a         	adds	r2, r3, r1
10003730: 404a         	eors	r2, r1
10003732: b292         	uxth	r2, r2
10003734: 0fd9         	lsrs	r1, r3, #0x1f
10003736: 910c         	str	r1, [sp, #0x30]
;     if (!value) {
10003738: 2b00         	cmp	r3, #0x0
1000373a: d100         	bne	0x1000373e <_vsnprintf+0x6e2> @ imm = #0x0
1000373c: e1f9         	b	0x10003b32 <_vsnprintf+0xad6> @ imm = #0x3f2
;                         idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int) (value > 0 ? value : 0 - value),
1000373e: 0010         	movs	r0, r2
10003740: aa14         	add	r2, sp, #0x50
10003742: 4694         	mov	r12, r2
10003744: 4642         	mov	r2, r8
10003746: 231f         	movs	r3, #0x1f
10003748: 9214         	str	r2, [sp, #0x50]
1000374a: 4652         	mov	r2, r10
1000374c: 4463         	add	r3, r12
1000374e: 46a8         	mov	r8, r5
10003750: 9416         	str	r4, [sp, #0x58]
10003752: 464d         	mov	r5, r9
10003754: 0004         	movs	r4, r0
10003756: 46b9         	mov	r9, r7
10003758: 46b2         	mov	r10, r6
1000375a: 001f         	movs	r7, r3
1000375c: 9215         	str	r2, [sp, #0x54]
1000375e: e001         	b	0x10003764 <_vsnprintf+0x708> @ imm = #0x2
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
10003760: 2d20         	cmp	r5, #0x20
10003762: d00f         	beq	0x10003784 <_vsnprintf+0x728> @ imm = #0x1e
;             const char digit = (char) (value % base);
10003764: 0020         	movs	r0, r4
10003766: 210a         	movs	r1, #0xa
10003768: f7fd ff38    	bl	0x100015dc <divmod_u32u32> @ imm = #-0x2190
;             buf[len++] = (char)(digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10);
1000376c: 3501         	adds	r5, #0x1
1000376e: 197e         	adds	r6, r7, r5
10003770: 3130         	adds	r1, #0x30
10003772: 7031         	strb	r1, [r6]
;             value /= base;
10003774: 0020         	movs	r0, r4
10003776: 210a         	movs	r1, #0xa
10003778: f7fd ff30    	bl	0x100015dc <divmod_u32u32> @ imm = #-0x21a0
1000377c: 0026         	movs	r6, r4
1000377e: 0004         	movs	r4, r0
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
10003780: 2e09         	cmp	r6, #0x9
10003782: d8ed         	bhi	0x10003760 <_vsnprintf+0x704> @ imm = #-0x26
10003784: 9b14         	ldr	r3, [sp, #0x50]
10003786: 464f         	mov	r7, r9
10003788: 46a9         	mov	r9, r5
1000378a: 4645         	mov	r5, r8
1000378c: 4698         	mov	r8, r3
1000378e: 9b15         	ldr	r3, [sp, #0x54]
10003790: 4656         	mov	r6, r10
10003792: 469a         	mov	r10, r3
10003794: 9c16         	ldr	r4, [sp, #0x58]
;     return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int) base, prec, width, flags);
10003796: 9b0d         	ldr	r3, [sp, #0x34]
10003798: 9306         	str	r3, [sp, #0x18]
1000379a: 4643         	mov	r3, r8
1000379c: 9305         	str	r3, [sp, #0x14]
1000379e: 4653         	mov	r3, r10
100037a0: 9304         	str	r3, [sp, #0x10]
100037a2: 230a         	movs	r3, #0xa
100037a4: 9303         	str	r3, [sp, #0xc]
100037a6: 9b0c         	ldr	r3, [sp, #0x30]
100037a8: 9302         	str	r3, [sp, #0x8]
100037aa: 464b         	mov	r3, r9
100037ac: 9301         	str	r3, [sp, #0x4]
100037ae: ab1c         	add	r3, sp, #0x70
100037b0: 0022         	movs	r2, r4
100037b2: 9300         	str	r3, [sp]
100037b4: 4659         	mov	r1, r11
100037b6: 003b         	movs	r3, r7
100037b8: 0028         	movs	r0, r5
100037ba: f7fe fe47    	bl	0x1000244c <_ntoa_format> @ imm = #-0x1372
100037be: 9b0f         	ldr	r3, [sp, #0x3c]
100037c0: 0004         	movs	r4, r0
100037c2: 930c         	str	r3, [sp, #0x30]
;                 break;
100037c4: e472         	b	0x100030ac <_vsnprintf+0x50> @ imm = #-0x71c
100037c6: 46c0         	mov	r8, r8
100037c8: 9d 23 00 10  	.word	0x1000239d
;                     flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
100037cc: 230c         	movs	r3, #0xc
100037ce: 439a         	bics	r2, r3
100037d0: 0010         	movs	r0, r2
100037d2: e6e7         	b	0x100035a4 <_vsnprintf+0x548> @ imm = #-0x232
;                         const long long value = va_arg(va, long long);
100037d4: 2207         	movs	r2, #0x7
100037d6: 9b0c         	ldr	r3, [sp, #0x30]
100037d8: 3307         	adds	r3, #0x7
100037da: 4393         	bics	r3, r2
100037dc: 3201         	adds	r2, #0x1
100037de: 4694         	mov	r12, r2
100037e0: 449c         	add	r12, r3
100037e2: 4662         	mov	r2, r12
100037e4: 920c         	str	r2, [sp, #0x30]
100037e6: cb0c         	ldm	r3, {r2, r3}
;                         idx = _ntoa_long_long(out, buffer, idx, maxlen,
100037e8: 0fd9         	lsrs	r1, r3, #0x1f
100037ea: 910f         	str	r1, [sp, #0x3c]
;     if (!value) {
100037ec: 0011         	movs	r1, r2
100037ee: 4319         	orrs	r1, r3
100037f0: d100         	bne	0x100037f4 <_vsnprintf+0x798> @ imm = #0x0
100037f2: e091         	b	0x10003918 <_vsnprintf+0x8bc> @ imm = #0x122
;                                               (unsigned long long) (value > 0 ? value : 0 - value), value < 0, base,
100037f4: 17d9         	asrs	r1, r3, #0x1f
100037f6: 9113         	str	r1, [sp, #0x4c]
100037f8: 9112         	str	r1, [sp, #0x48]
100037fa: 4051         	eors	r1, r2
100037fc: 9110         	str	r1, [sp, #0x40]
100037fe: 9913         	ldr	r1, [sp, #0x4c]
10003800: 4059         	eors	r1, r3
10003802: 9111         	str	r1, [sp, #0x44]
10003804: 9810         	ldr	r0, [sp, #0x40]
10003806: 9911         	ldr	r1, [sp, #0x44]
10003808: 9a12         	ldr	r2, [sp, #0x48]
1000380a: 9b13         	ldr	r3, [sp, #0x4c]
1000380c: 1a80         	subs	r0, r0, r2
1000380e: 4199         	sbcs	r1, r3
10003810: 9010         	str	r0, [sp, #0x40]
10003812: 9111         	str	r1, [sp, #0x44]
10003814: aa14         	add	r2, sp, #0x50
;     if (!(flags & FLAGS_PRECISION) || value) {
10003816: 2300         	movs	r3, #0x0
10003818: 4694         	mov	r12, r2
1000381a: 4642         	mov	r2, r8
1000381c: 4699         	mov	r9, r3
1000381e: 9214         	str	r2, [sp, #0x50]
10003820: 4652         	mov	r2, r10
10003822: 331f         	adds	r3, #0x1f
10003824: 4463         	add	r3, r12
10003826: 46a8         	mov	r8, r5
10003828: 46b2         	mov	r10, r6
1000382a: 9416         	str	r4, [sp, #0x58]
1000382c: 464e         	mov	r6, r9
1000382e: 9c10         	ldr	r4, [sp, #0x40]
10003830: 9d11         	ldr	r5, [sp, #0x44]
10003832: 46b9         	mov	r9, r7
10003834: 9215         	str	r2, [sp, #0x54]
10003836: 001f         	movs	r7, r3
10003838: e001         	b	0x1000383e <_vsnprintf+0x7e2> @ imm = #0x2
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
1000383a: 2e20         	cmp	r6, #0x20
1000383c: d010         	beq	0x10003860 <_vsnprintf+0x804> @ imm = #0x20
;             const char digit = (char) (value % base);
1000383e: 0020         	movs	r0, r4
10003840: 0029         	movs	r1, r5
10003842: 220a         	movs	r2, #0xa
10003844: 2300         	movs	r3, #0x0
10003846: f7fd ff07    	bl	0x10001658 <divmod_u64u64> @ imm = #-0x21f2
;             buf[len++] = (char)(digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10);
1000384a: 3601         	adds	r6, #0x1
1000384c: 3230         	adds	r2, #0x30
1000384e: 002b         	movs	r3, r5
10003850: 55ba         	strb	r2, [r7, r6]
;             value /= base;
10003852: 000d         	movs	r5, r1
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
10003854: 0022         	movs	r2, r4
;             value /= base;
10003856: 0004         	movs	r4, r0
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
10003858: 2b00         	cmp	r3, #0x0
1000385a: d1ee         	bne	0x1000383a <_vsnprintf+0x7de> @ imm = #-0x24
1000385c: 2a09         	cmp	r2, #0x9
1000385e: d8ec         	bhi	0x1000383a <_vsnprintf+0x7de> @ imm = #-0x28
10003860: 9b14         	ldr	r3, [sp, #0x50]
10003862: 9410         	str	r4, [sp, #0x40]
10003864: 9511         	str	r5, [sp, #0x44]
10003866: 4645         	mov	r5, r8
10003868: 4698         	mov	r8, r3
1000386a: 9b15         	ldr	r3, [sp, #0x54]
1000386c: 464f         	mov	r7, r9
1000386e: 46b1         	mov	r9, r6
10003870: 4656         	mov	r6, r10
10003872: 469a         	mov	r10, r3
10003874: 9c16         	ldr	r4, [sp, #0x58]
;     return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int) base, prec, width, flags);
10003876: 9b0d         	ldr	r3, [sp, #0x34]
10003878: 9306         	str	r3, [sp, #0x18]
1000387a: 4643         	mov	r3, r8
1000387c: 9305         	str	r3, [sp, #0x14]
1000387e: 4653         	mov	r3, r10
10003880: 9304         	str	r3, [sp, #0x10]
10003882: 230a         	movs	r3, #0xa
10003884: 9303         	str	r3, [sp, #0xc]
10003886: 9b0f         	ldr	r3, [sp, #0x3c]
10003888: 9302         	str	r3, [sp, #0x8]
1000388a: 464b         	mov	r3, r9
1000388c: 9301         	str	r3, [sp, #0x4]
1000388e: ab1c         	add	r3, sp, #0x70
10003890: 0022         	movs	r2, r4
10003892: 9300         	str	r3, [sp]
10003894: 4659         	mov	r1, r11
10003896: 003b         	movs	r3, r7
10003898: 0028         	movs	r0, r5
1000389a: f7fe fdd7    	bl	0x1000244c <_ntoa_format> @ imm = #-0x1452
1000389e: 0004         	movs	r4, r0
100038a0: f7ff fc04    	bl	0x100030ac <_vsnprintf+0x50> @ imm = #-0x7f8
;                     while (l++ < width) {
100038a4: 9b0f         	ldr	r3, [sp, #0x3c]
100038a6: 4598         	cmp	r8, r3
100038a8: d800         	bhi	0x100038ac <_vsnprintf+0x850> @ imm = #0x0
100038aa: e1c1         	b	0x10003c30 <_vsnprintf+0xbd4> @ imm = #0x382
100038ac: 2380         	movs	r3, #0x80
100038ae: 00db         	lsls	r3, r3, #0x3
100038b0: 930d         	str	r3, [sp, #0x34]
100038b2: 4643         	mov	r3, r8
100038b4: 9a0f         	ldr	r2, [sp, #0x3c]
100038b6: 191b         	adds	r3, r3, r4
100038b8: 1a9b         	subs	r3, r3, r2
100038ba: 4699         	mov	r9, r3
100038bc: 0033         	movs	r3, r6
100038be: 002e         	movs	r6, r5
100038c0: 464d         	mov	r5, r9
100038c2: 46b9         	mov	r9, r7
100038c4: 465f         	mov	r7, r11
100038c6: 469b         	mov	r11, r3
100038c8: 910c         	str	r1, [sp, #0x30]
;                         out(' ', buffer, idx++, maxlen);
100038ca: 0022         	movs	r2, r4
100038cc: 464b         	mov	r3, r9
100038ce: 3401         	adds	r4, #0x1
100038d0: 0039         	movs	r1, r7
100038d2: 2020         	movs	r0, #0x20
100038d4: 47b0         	blx	r6
;                     while (l++ < width) {
100038d6: 42ac         	cmp	r4, r5
100038d8: d1f7         	bne	0x100038ca <_vsnprintf+0x86e> @ imm = #-0x12
100038da: 4643         	mov	r3, r8
100038dc: 990c         	ldr	r1, [sp, #0x30]
100038de: 3301         	adds	r3, #0x1
100038e0: 930f         	str	r3, [sp, #0x3c]
;                 while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
100038e2: 780b         	ldrb	r3, [r1]
100038e4: 0035         	movs	r5, r6
100038e6: 930c         	str	r3, [sp, #0x30]
100038e8: 465e         	mov	r6, r11
100038ea: 46bb         	mov	r11, r7
100038ec: 464f         	mov	r7, r9
100038ee: 2b00         	cmp	r3, #0x0
100038f0: d100         	bne	0x100038f4 <_vsnprintf+0x898> @ imm = #0x0
100038f2: e50e         	b	0x10003312 <_vsnprintf+0x2b6> @ imm = #-0x5e4
100038f4: 9b0d         	ldr	r3, [sp, #0x34]
100038f6: 2b00         	cmp	r3, #0x0
100038f8: d100         	bne	0x100038fc <_vsnprintf+0x8a0> @ imm = #0x0
100038fa: e4f6         	b	0x100032ea <_vsnprintf+0x28e> @ imm = #-0x614
100038fc: 2300         	movs	r3, #0x0
100038fe: e619         	b	0x10003534 <_vsnprintf+0x4d8> @ imm = #-0x3ce
10003900: 9b0c         	ldr	r3, [sp, #0x30]
10003902: 781b         	ldrb	r3, [r3]
10003904: 001a         	movs	r2, r3
10003906: e715         	b	0x10003734 <_vsnprintf+0x6d8> @ imm = #-0x1d6
;                     flags &= ~FLAGS_HASH;   // no hash for dec format
10003908: 2310         	movs	r3, #0x10
1000390a: 439a         	bics	r2, r3
1000390c: 920d         	str	r2, [sp, #0x34]
1000390e: e6ef         	b	0x100036f0 <_vsnprintf+0x694> @ imm = #-0x222
10003910: 9b0c         	ldr	r3, [sp, #0x30]
10003912: 781b         	ldrb	r3, [r3]
10003914: 9309         	str	r3, [sp, #0x24]
10003916: e661         	b	0x100035dc <_vsnprintf+0x580> @ imm = #-0x33e
;     size_t len = 0U;
10003918: 2300         	movs	r3, #0x0
1000391a: 4699         	mov	r9, r3
;     if (!(flags & FLAGS_PRECISION) || value) {
1000391c: 2800         	cmp	r0, #0x0
1000391e: d1aa         	bne	0x10003876 <_vsnprintf+0x81a> @ imm = #-0xac
10003920: 2200         	movs	r2, #0x0
10003922: 2300         	movs	r3, #0x0
10003924: 9210         	str	r2, [sp, #0x40]
10003926: 9311         	str	r3, [sp, #0x44]
10003928: e774         	b	0x10003814 <_vsnprintf+0x7b8> @ imm = #-0x118
;                 out((char) va_arg(va, int), buffer, idx++, maxlen);
1000392a: 9b0c         	ldr	r3, [sp, #0x30]
1000392c: 0022         	movs	r2, r4
1000392e: 7818         	ldrb	r0, [r3]
10003930: 4659         	mov	r1, r11
10003932: 003b         	movs	r3, r7
10003934: 47a8         	blx	r5
10003936: 464c         	mov	r4, r9
10003938: e58b         	b	0x10003452 <_vsnprintf+0x3f6> @ imm = #-0x4ea
;                         idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base,
1000393a: 9a0c         	ldr	r2, [sp, #0x30]
1000393c: 3bfa         	subs	r3, #0xfa
1000393e: 3bff         	subs	r3, #0xff
10003940: 3207         	adds	r2, #0x7
10003942: 439a         	bics	r2, r3
10003944: 3301         	adds	r3, #0x1
10003946: 4699         	mov	r9, r3
10003948: 4491         	add	r9, r2
1000394a: 464b         	mov	r3, r9
1000394c: 930c         	str	r3, [sp, #0x30]
1000394e: 6813         	ldr	r3, [r2]
10003950: 6852         	ldr	r2, [r2, #0x4]
10003952: 9215         	str	r2, [sp, #0x54]
;     if (!value) {
10003954: 431a         	orrs	r2, r3
10003956: d106         	bne	0x10003966 <_vsnprintf+0x90a> @ imm = #0xc
;         flags &= ~FLAGS_HASH;
10003958: 3210         	adds	r2, #0x10
1000395a: 4390         	bics	r0, r2
;     size_t len = 0U;
1000395c: 2200         	movs	r2, #0x0
1000395e: 9209         	str	r2, [sp, #0x24]
;     if (!(flags & FLAGS_PRECISION) || value) {
10003960: 2900         	cmp	r1, #0x0
10003962: d000         	beq	0x10003966 <_vsnprintf+0x90a> @ imm = #0x0
10003964: e081         	b	0x10003a6a <_vsnprintf+0xa0e> @ imm = #0x102
10003966: 2261         	movs	r2, #0x61
10003968: 0681         	lsls	r1, r0, #0x1a
1000396a: d500         	bpl	0x1000396e <_vsnprintf+0x912> @ imm = #0x0
1000396c: 2241         	movs	r2, #0x41
1000396e: b2d2         	uxtb	r2, r2
10003970: 920a         	str	r2, [sp, #0x28]
10003972: aa14         	add	r2, sp, #0x50
10003974: 4691         	mov	r9, r2
;             buf[len++] = (char)(digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10);
10003976: 9a0a         	ldr	r2, [sp, #0x28]
10003978: 2100         	movs	r1, #0x0
1000397a: 3a0a         	subs	r2, #0xa
1000397c: 9214         	str	r2, [sp, #0x50]
1000397e: 4642         	mov	r2, r8
10003980: 9217         	str	r2, [sp, #0x5c]
10003982: 4652         	mov	r2, r10
10003984: 9218         	str	r2, [sp, #0x60]
10003986: 465a         	mov	r2, r11
10003988: 9109         	str	r1, [sp, #0x24]
1000398a: 46b3         	mov	r11, r6
1000398c: 311f         	adds	r1, #0x1f
1000398e: 001e         	movs	r6, r3
10003990: 9b0f         	ldr	r3, [sp, #0x3c]
10003992: 4449         	add	r1, r9
10003994: 46ba         	mov	r10, r7
10003996: 9419         	str	r4, [sp, #0x64]
10003998: 951a         	str	r5, [sp, #0x68]
1000399a: 2400         	movs	r4, #0x0
1000399c: 4667         	mov	r7, r12
1000399e: 4698         	mov	r8, r3
100039a0: 4689         	mov	r9, r1
100039a2: 9d15         	ldr	r5, [sp, #0x54]
100039a4: 9016         	str	r0, [sp, #0x58]
100039a6: 921b         	str	r2, [sp, #0x6c]
100039a8: e00a         	b	0x100039c0 <_vsnprintf+0x964> @ imm = #0x14
100039aa: 3230         	adds	r2, #0x30
100039ac: b2d2         	uxtb	r2, r2
100039ae: 464b         	mov	r3, r9
100039b0: 3401         	adds	r4, #0x1
100039b2: 551a         	strb	r2, [r3, r4]
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
100039b4: 45a8         	cmp	r8, r5
100039b6: d04a         	beq	0x10003a4e <_vsnprintf+0x9f2> @ imm = #0x94
100039b8: 2c20         	cmp	r4, #0x20
100039ba: d04a         	beq	0x10003a52 <_vsnprintf+0x9f6> @ imm = #0x94
;             value /= base;
100039bc: 0006         	movs	r6, r0
100039be: 000d         	movs	r5, r1
;             const char digit = (char) (value % base);
100039c0: 003a         	movs	r2, r7
100039c2: 2300         	movs	r3, #0x0
100039c4: 0030         	movs	r0, r6
100039c6: 0029         	movs	r1, r5
100039c8: f7fd fe46    	bl	0x10001658 <divmod_u64u64> @ imm = #-0x2374
100039cc: b2d2         	uxtb	r2, r2
;             buf[len++] = (char)(digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10);
100039ce: 2a09         	cmp	r2, #0x9
100039d0: d9eb         	bls	0x100039aa <_vsnprintf+0x94e> @ imm = #-0x2a
100039d2: 9b14         	ldr	r3, [sp, #0x50]
100039d4: 469c         	mov	r12, r3
100039d6: 4462         	add	r2, r12
100039d8: b2d2         	uxtb	r2, r2
100039da: e7e8         	b	0x100039ae <_vsnprintf+0x952> @ imm = #-0x30
100039dc: 2361         	movs	r3, #0x61
100039de: 0682         	lsls	r2, r0, #0x1a
100039e0: d500         	bpl	0x100039e4 <_vsnprintf+0x988> @ imm = #0x0
100039e2: 2341         	movs	r3, #0x41
100039e4: b2db         	uxtb	r3, r3
;             buf[len++] = (char)(digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10);
100039e6: 3b0a         	subs	r3, #0xa
100039e8: 930c         	str	r3, [sp, #0x30]
100039ea: 4643         	mov	r3, r8
100039ec: a914         	add	r1, sp, #0x50
100039ee: 221f         	movs	r2, #0x1f
100039f0: 468c         	mov	r12, r1
100039f2: 9315         	str	r3, [sp, #0x54]
100039f4: 4653         	mov	r3, r10
100039f6: 4462         	add	r2, r12
100039f8: 46a0         	mov	r8, r4
100039fa: 46b2         	mov	r10, r6
100039fc: 464c         	mov	r4, r9
100039fe: 9717         	str	r7, [sp, #0x5c]
10003a00: 46a9         	mov	r9, r5
10003a02: 0017         	movs	r7, r2
10003a04: 9d09         	ldr	r5, [sp, #0x24]
10003a06: 9e0d         	ldr	r6, [sp, #0x34]
10003a08: 9014         	str	r0, [sp, #0x50]
10003a0a: 9316         	str	r3, [sp, #0x58]
10003a0c: e008         	b	0x10003a20 <_vsnprintf+0x9c4> @ imm = #0x10
10003a0e: 3330         	adds	r3, #0x30
10003a10: b2db         	uxtb	r3, r3
10003a12: 3401         	adds	r4, #0x1
10003a14: 553b         	strb	r3, [r7, r4]
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
10003a16: 42b5         	cmp	r5, r6
10003a18: d30e         	blo	0x10003a38 <_vsnprintf+0x9dc> @ imm = #0x1c
10003a1a: 2c20         	cmp	r4, #0x20
10003a1c: d00c         	beq	0x10003a38 <_vsnprintf+0x9dc> @ imm = #0x18
;             value /= base;
10003a1e: 0005         	movs	r5, r0
;             const char digit = (char) (value % base);
10003a20: 0031         	movs	r1, r6
10003a22: 0028         	movs	r0, r5
10003a24: f7fd fdda    	bl	0x100015dc <divmod_u32u32> @ imm = #-0x244c
10003a28: b2cb         	uxtb	r3, r1
;             buf[len++] = (char)(digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10);
10003a2a: 2909         	cmp	r1, #0x9
10003a2c: d9ef         	bls	0x10003a0e <_vsnprintf+0x9b2> @ imm = #-0x22
10003a2e: 9a0c         	ldr	r2, [sp, #0x30]
10003a30: 4694         	mov	r12, r2
10003a32: 4463         	add	r3, r12
10003a34: b2db         	uxtb	r3, r3
10003a36: e7ec         	b	0x10003a12 <_vsnprintf+0x9b6> @ imm = #-0x28
10003a38: 9b15         	ldr	r3, [sp, #0x54]
10003a3a: 464d         	mov	r5, r9
10003a3c: 46a1         	mov	r9, r4
10003a3e: 4644         	mov	r4, r8
10003a40: 4698         	mov	r8, r3
10003a42: 9b16         	ldr	r3, [sp, #0x58]
10003a44: 4656         	mov	r6, r10
10003a46: 9814         	ldr	r0, [sp, #0x50]
10003a48: 469a         	mov	r10, r3
10003a4a: 9f17         	ldr	r7, [sp, #0x5c]
10003a4c: e5d0         	b	0x100035f0 <_vsnprintf+0x594> @ imm = #-0x460
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
10003a4e: 42b7         	cmp	r7, r6
10003a50: d9b2         	bls	0x100039b8 <_vsnprintf+0x95c> @ imm = #-0x9c
10003a52: 9b17         	ldr	r3, [sp, #0x5c]
10003a54: 4657         	mov	r7, r10
10003a56: 4698         	mov	r8, r3
10003a58: 9b18         	ldr	r3, [sp, #0x60]
10003a5a: 465e         	mov	r6, r11
10003a5c: 469a         	mov	r10, r3
10003a5e: 9b1b         	ldr	r3, [sp, #0x6c]
10003a60: 9409         	str	r4, [sp, #0x24]
10003a62: 469b         	mov	r11, r3
10003a64: 9816         	ldr	r0, [sp, #0x58]
10003a66: 9c19         	ldr	r4, [sp, #0x64]
10003a68: 9d1a         	ldr	r5, [sp, #0x68]
;     return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int) base, prec, width, flags);
10003a6a: 4643         	mov	r3, r8
10003a6c: 9305         	str	r3, [sp, #0x14]
10003a6e: 4653         	mov	r3, r10
10003a70: 9304         	str	r3, [sp, #0x10]
10003a72: 9b0d         	ldr	r3, [sp, #0x34]
10003a74: 9006         	str	r0, [sp, #0x18]
10003a76: 9303         	str	r3, [sp, #0xc]
10003a78: 2300         	movs	r3, #0x0
10003a7a: 9302         	str	r3, [sp, #0x8]
10003a7c: 9b09         	ldr	r3, [sp, #0x24]
10003a7e: e705         	b	0x1000388c <_vsnprintf+0x830> @ imm = #-0x1f6
;                     while (l++ < width) {
10003a80: 9b0f         	ldr	r3, [sp, #0x3c]
10003a82: 4598         	cmp	r8, r3
10003a84: d900         	bls	0x10003a88 <_vsnprintf+0xa2c> @ imm = #0x0
10003a86: e714         	b	0x100038b2 <_vsnprintf+0x856> @ imm = #-0x1d8
10003a88: 3301         	adds	r3, #0x1
10003a8a: 930f         	str	r3, [sp, #0x3c]
10003a8c: e42d         	b	0x100032ea <_vsnprintf+0x28e> @ imm = #-0x7a6
;                     flags &= ~FLAGS_HASH;   // no hash for dec format
10003a8e: 2310         	movs	r3, #0x10
10003a90: 0011         	movs	r1, r2
10003a92: 4399         	bics	r1, r3
10003a94: 910d         	str	r1, [sp, #0x34]
;                 if ((*format != 'i') && (*format != 'd')) {
10003a96: 2869         	cmp	r0, #0x69
10003a98: d000         	beq	0x10003a9c <_vsnprintf+0xa40> @ imm = #0x0
10003a9a: e0ba         	b	0x10003c12 <_vsnprintf+0xbb6> @ imm = #0x174
;                 if (flags & FLAGS_PRECISION) {
10003a9c: 2380         	movs	r3, #0x80
10003a9e: 0010         	movs	r0, r2
10003aa0: 00db         	lsls	r3, r3, #0x3
10003aa2: 4018         	ands	r0, r3
10003aa4: 421a         	tst	r2, r3
10003aa6: d100         	bne	0x10003aaa <_vsnprintf+0xa4e> @ imm = #0x0
10003aa8: e622         	b	0x100036f0 <_vsnprintf+0x694> @ imm = #-0x3bc
10003aaa: e61d         	b	0x100036e8 <_vsnprintf+0x68c> @ imm = #-0x3c6
;                         const long value = va_arg(va, long);
10003aac: 9b0c         	ldr	r3, [sp, #0x30]
10003aae: 681b         	ldr	r3, [r3]
;                         idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long) (value > 0 ? value : 0 - value),
10003ab0: 0fda         	lsrs	r2, r3, #0x1f
10003ab2: 0011         	movs	r1, r2
;     if (!value) {
10003ab4: 2b00         	cmp	r3, #0x0
10003ab6: d100         	bne	0x10003aba <_vsnprintf+0xa5e> @ imm = #0x0
10003ab8: e08c         	b	0x10003bd4 <_vsnprintf+0xb78> @ imm = #0x118
;                         idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long) (value > 0 ? value : 0 - value),
10003aba: 17da         	asrs	r2, r3, #0x1f
10003abc: 1898         	adds	r0, r3, r2
10003abe: 4050         	eors	r0, r2
10003ac0: aa14         	add	r2, sp, #0x50
10003ac2: 4691         	mov	r9, r2
10003ac4: 4642         	mov	r2, r8
10003ac6: 231f         	movs	r3, #0x1f
10003ac8: 9214         	str	r2, [sp, #0x50]
10003aca: 4652         	mov	r2, r10
10003acc: 444b         	add	r3, r9
10003ace: 46a0         	mov	r8, r4
10003ad0: 46a9         	mov	r9, r5
10003ad2: 9716         	str	r7, [sp, #0x58]
10003ad4: 0004         	movs	r4, r0
10003ad6: 4665         	mov	r5, r12
10003ad8: 46b2         	mov	r10, r6
10003ada: 001f         	movs	r7, r3
10003adc: 910c         	str	r1, [sp, #0x30]
10003ade: 9215         	str	r2, [sp, #0x54]
10003ae0: e001         	b	0x10003ae6 <_vsnprintf+0xa8a> @ imm = #0x2
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
10003ae2: 2d20         	cmp	r5, #0x20
10003ae4: d00f         	beq	0x10003b06 <_vsnprintf+0xaaa> @ imm = #0x1e
;             const char digit = (char) (value % base);
10003ae6: 0020         	movs	r0, r4
10003ae8: 210a         	movs	r1, #0xa
10003aea: f7fd fd77    	bl	0x100015dc <divmod_u32u32> @ imm = #-0x2512
;             buf[len++] = (char)(digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10);
10003aee: 3501         	adds	r5, #0x1
10003af0: 197e         	adds	r6, r7, r5
10003af2: 3130         	adds	r1, #0x30
10003af4: 7031         	strb	r1, [r6]
;             value /= base;
10003af6: 0020         	movs	r0, r4
10003af8: 210a         	movs	r1, #0xa
10003afa: f7fd fd6f    	bl	0x100015dc <divmod_u32u32> @ imm = #-0x2522
10003afe: 0026         	movs	r6, r4
10003b00: 0004         	movs	r4, r0
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
10003b02: 2e09         	cmp	r6, #0x9
10003b04: d8ed         	bhi	0x10003ae2 <_vsnprintf+0xa86> @ imm = #-0x26
10003b06: 9b14         	ldr	r3, [sp, #0x50]
10003b08: 4644         	mov	r4, r8
10003b0a: 4698         	mov	r8, r3
10003b0c: 9b0c         	ldr	r3, [sp, #0x30]
10003b0e: 46ac         	mov	r12, r5
10003b10: 0019         	movs	r1, r3
10003b12: 9b15         	ldr	r3, [sp, #0x54]
10003b14: 4656         	mov	r6, r10
10003b16: 464d         	mov	r5, r9
10003b18: 469a         	mov	r10, r3
10003b1a: 9f16         	ldr	r7, [sp, #0x58]
;     return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int) base, prec, width, flags);
10003b1c: 9b0d         	ldr	r3, [sp, #0x34]
10003b1e: 9102         	str	r1, [sp, #0x8]
10003b20: 9306         	str	r3, [sp, #0x18]
10003b22: 4643         	mov	r3, r8
10003b24: 9305         	str	r3, [sp, #0x14]
10003b26: 4653         	mov	r3, r10
10003b28: 9304         	str	r3, [sp, #0x10]
10003b2a: 230a         	movs	r3, #0xa
10003b2c: 9303         	str	r3, [sp, #0xc]
10003b2e: 4663         	mov	r3, r12
10003b30: e63c         	b	0x100037ac <_vsnprintf+0x750> @ imm = #-0x388
;     if (!(flags & FLAGS_PRECISION) || value) {
10003b32: 2800         	cmp	r0, #0x0
10003b34: d000         	beq	0x10003b38 <_vsnprintf+0xadc> @ imm = #0x0
10003b36: e62e         	b	0x10003796 <_vsnprintf+0x73a> @ imm = #-0x3a4
10003b38: e602         	b	0x10003740 <_vsnprintf+0x6e4> @ imm = #-0x3fc
;                         idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision,
10003b3a: 9b0c         	ldr	r3, [sp, #0x30]
10003b3c: 681b         	ldr	r3, [r3]
10003b3e: 4699         	mov	r9, r3
;     if (!value) {
10003b40: 2b00         	cmp	r3, #0x0
10003b42: d103         	bne	0x10003b4c <_vsnprintf+0xaf0> @ imm = #0x6
;         flags &= ~FLAGS_HASH;
10003b44: 3310         	adds	r3, #0x10
10003b46: 4398         	bics	r0, r3
;     if (!(flags & FLAGS_PRECISION) || value) {
10003b48: 2900         	cmp	r1, #0x0
10003b4a: d138         	bne	0x10003bbe <_vsnprintf+0xb62> @ imm = #0x70
10003b4c: 2361         	movs	r3, #0x61
10003b4e: 0682         	lsls	r2, r0, #0x1a
10003b50: d500         	bpl	0x10003b54 <_vsnprintf+0xaf8> @ imm = #0x0
10003b52: 2341         	movs	r3, #0x41
10003b54: b2db         	uxtb	r3, r3
;             buf[len++] = (char)(digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10);
10003b56: 3b0a         	subs	r3, #0xa
10003b58: 930c         	str	r3, [sp, #0x30]
10003b5a: 4643         	mov	r3, r8
10003b5c: 9316         	str	r3, [sp, #0x58]
10003b5e: 4653         	mov	r3, r10
10003b60: a914         	add	r1, sp, #0x50
10003b62: 221f         	movs	r2, #0x1f
10003b64: 468c         	mov	r12, r1
10003b66: 9317         	str	r3, [sp, #0x5c]
10003b68: 002b         	movs	r3, r5
10003b6a: 4462         	add	r2, r12
10003b6c: 46a0         	mov	r8, r4
10003b6e: 464d         	mov	r5, r9
10003b70: 46b2         	mov	r10, r6
10003b72: 9718         	str	r7, [sp, #0x60]
10003b74: 4699         	mov	r9, r3
10003b76: 0017         	movs	r7, r2
10003b78: 9c14         	ldr	r4, [sp, #0x50]
10003b7a: 9e0d         	ldr	r6, [sp, #0x34]
10003b7c: 9015         	str	r0, [sp, #0x54]
10003b7e: e008         	b	0x10003b92 <_vsnprintf+0xb36> @ imm = #0x10
10003b80: 3330         	adds	r3, #0x30
10003b82: b2db         	uxtb	r3, r3
10003b84: 3401         	adds	r4, #0x1
10003b86: 553b         	strb	r3, [r7, r4]
;         } while (value && (len < PICO_PRINTF_NTOA_BUFFER_SIZE));
10003b88: 42b5         	cmp	r5, r6
10003b8a: d30e         	blo	0x10003baa <_vsnprintf+0xb4e> @ imm = #0x1c
10003b8c: 2c20         	cmp	r4, #0x20
10003b8e: d00c         	beq	0x10003baa <_vsnprintf+0xb4e> @ imm = #0x18
;             value /= base;
10003b90: 0005         	movs	r5, r0
;             const char digit = (char) (value % base);
10003b92: 0031         	movs	r1, r6
10003b94: 0028         	movs	r0, r5
10003b96: f7fd fd21    	bl	0x100015dc <divmod_u32u32> @ imm = #-0x25be
10003b9a: b2cb         	uxtb	r3, r1
;             buf[len++] = (char)(digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10);
10003b9c: 2909         	cmp	r1, #0x9
10003b9e: d9ef         	bls	0x10003b80 <_vsnprintf+0xb24> @ imm = #-0x22
10003ba0: 9a0c         	ldr	r2, [sp, #0x30]
10003ba2: 4694         	mov	r12, r2
10003ba4: 4463         	add	r3, r12
10003ba6: b2db         	uxtb	r3, r3
10003ba8: e7ec         	b	0x10003b84 <_vsnprintf+0xb28> @ imm = #-0x28
10003baa: 9b16         	ldr	r3, [sp, #0x58]
10003bac: 9414         	str	r4, [sp, #0x50]
10003bae: 4644         	mov	r4, r8
10003bb0: 4698         	mov	r8, r3
10003bb2: 9b17         	ldr	r3, [sp, #0x5c]
10003bb4: 4656         	mov	r6, r10
10003bb6: 464d         	mov	r5, r9
10003bb8: 469a         	mov	r10, r3
10003bba: 9815         	ldr	r0, [sp, #0x54]
10003bbc: 9f18         	ldr	r7, [sp, #0x60]
;     return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int) base, prec, width, flags);
10003bbe: 4643         	mov	r3, r8
10003bc0: 9305         	str	r3, [sp, #0x14]
10003bc2: 4653         	mov	r3, r10
10003bc4: 9304         	str	r3, [sp, #0x10]
10003bc6: 9b0d         	ldr	r3, [sp, #0x34]
10003bc8: 9006         	str	r0, [sp, #0x18]
10003bca: 9303         	str	r3, [sp, #0xc]
10003bcc: 2300         	movs	r3, #0x0
10003bce: 9302         	str	r3, [sp, #0x8]
10003bd0: 9b14         	ldr	r3, [sp, #0x50]
10003bd2: e5eb         	b	0x100037ac <_vsnprintf+0x750> @ imm = #-0x42a
;     if (!(flags & FLAGS_PRECISION) || value) {
10003bd4: 2800         	cmp	r0, #0x0
10003bd6: d1a1         	bne	0x10003b1c <_vsnprintf+0xac0> @ imm = #-0xbe
10003bd8: e772         	b	0x10003ac0 <_vsnprintf+0xa64> @ imm = #-0x11c
;                                                                                           : va_arg(va, int);
10003bda: 9b0c         	ldr	r3, [sp, #0x30]
10003bdc: 681b         	ldr	r3, [r3]
;                         idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int) (value > 0 ? value : 0 - value),
10003bde: 17d9         	asrs	r1, r3, #0x1f
10003be0: 185a         	adds	r2, r3, r1
10003be2: 404a         	eors	r2, r1
10003be4: e5a6         	b	0x10003734 <_vsnprintf+0x6d8> @ imm = #-0x4b4
;                 if (flags & FLAGS_PRECISION) {
10003be6: 2380         	movs	r3, #0x80
10003be8: 0010         	movs	r0, r2
10003bea: 00db         	lsls	r3, r3, #0x3
10003bec: 4018         	ands	r0, r3
10003bee: 469c         	mov	r12, r3
10003bf0: 900f         	str	r0, [sp, #0x3c]
10003bf2: 421a         	tst	r2, r3
10003bf4: d00f         	beq	0x10003c16 <_vsnprintf+0xbba> @ imm = #0x1e
;                 if (!(flags & FLAGS_LEFT)) {
10003bf6: 2002         	movs	r0, #0x2
10003bf8: 0003         	movs	r3, r0
10003bfa: 4013         	ands	r3, r2
10003bfc: 930f         	str	r3, [sp, #0x3c]
10003bfe: 4210         	tst	r0, r2
10003c00: d019         	beq	0x10003c36 <_vsnprintf+0xbda> @ imm = #0x32
;                 unsigned int l = _strnlen_s(p, precision ? precision : (size_t) -1);
10003c02: 2300         	movs	r3, #0x0
;                 if (!(flags & FLAGS_LEFT)) {
10003c04: 46a1         	mov	r9, r4
;                 unsigned int l = _strnlen_s(p, precision ? precision : (size_t) -1);
10003c06: 930f         	str	r3, [sp, #0x3c]
10003c08: e54c         	b	0x100036a4 <_vsnprintf+0x648> @ imm = #-0x568
;                                                                           : va_arg(va, unsigned int);
10003c0a: 9b0c         	ldr	r3, [sp, #0x30]
10003c0c: 681b         	ldr	r3, [r3]
10003c0e: 9309         	str	r3, [sp, #0x24]
10003c10: e4e4         	b	0x100035dc <_vsnprintf+0x580> @ imm = #-0x638
10003c12: 000a         	movs	r2, r1
10003c14: e434         	b	0x10003480 <_vsnprintf+0x424> @ imm = #-0x798
;                 if (!(flags & FLAGS_LEFT)) {
10003c16: 2302         	movs	r3, #0x2
10003c18: 0018         	movs	r0, r3
10003c1a: 4010         	ands	r0, r2
10003c1c: 900d         	str	r0, [sp, #0x34]
10003c1e: 4213         	tst	r3, r2
10003c20: d000         	beq	0x10003c24 <_vsnprintf+0xbc8> @ imm = #0x0
10003c22: e53e         	b	0x100036a2 <_vsnprintf+0x646> @ imm = #-0x584
;                     while (l++ < width) {
10003c24: 4643         	mov	r3, r8
10003c26: 2b00         	cmp	r3, #0x0
10003c28: d000         	beq	0x10003c2c <_vsnprintf+0xbd0> @ imm = #0x0
10003c2a: e642         	b	0x100038b2 <_vsnprintf+0x856> @ imm = #-0x37c
10003c2c: f7ff fb71    	bl	0x10003312 <_vsnprintf+0x2b6> @ imm = #-0x91e
10003c30: 3301         	adds	r3, #0x1
10003c32: 930f         	str	r3, [sp, #0x3c]
10003c34: e47f         	b	0x10003536 <_vsnprintf+0x4da> @ imm = #-0x702
;                 if (flags & FLAGS_PRECISION) {
10003c36: 4663         	mov	r3, r12
10003c38: 930d         	str	r3, [sp, #0x34]
10003c3a: e7f3         	b	0x10003c24 <_vsnprintf+0xbc8> @ imm = #-0x1a

10003c3c <vfctprintf>:
; int vfctprintf(void (*out)(char character, void *arg), void *arg, const char *format, va_list va) {
10003c3c: b510         	push	{r4, lr}
10003c3e: 000c         	movs	r4, r1
10003c40: b084         	sub	sp, #0x10
;     const out_fct_wrap_type out_fct_wrap = {out, arg};
10003c42: 9403         	str	r4, [sp, #0xc]
;     return _vsnprintf(_out_fct, (char *) (uintptr_t) &out_fct_wrap, (size_t) -1, format, va);
10003c44: 2401         	movs	r4, #0x1
;     const out_fct_wrap_type out_fct_wrap = {out, arg};
10003c46: a902         	add	r1, sp, #0x8
10003c48: 9002         	str	r0, [sp, #0x8]
;     return _vsnprintf(_out_fct, (char *) (uintptr_t) &out_fct_wrap, (size_t) -1, format, va);
10003c4a: 9300         	str	r3, [sp]
10003c4c: 4803         	ldr	r0, [pc, #0xc]          @ 0x10003c5c <vfctprintf+0x20>
10003c4e: 0013         	movs	r3, r2
10003c50: 4262         	rsbs	r2, r4, #0
10003c52: f7ff fa03    	bl	0x1000305c <_vsnprintf> @ imm = #-0xbfa
; }
10003c56: b004         	add	sp, #0x10
10003c58: bd10         	pop	{r4, pc}
10003c5a: 46c0         	mov	r8, r8
10003c5c: 29 26 00 10  	.word	0x10002629

10003c60 <weak_raw_vprintf>:
; bool weak_raw_vprintf(const char *fmt, va_list args) {
10003c60: b510         	push	{r4, lr}
;     if (lazy_vsnprintf) {
10003c62: 4a09         	ldr	r2, [pc, #0x24]         @ 0x10003c88 <weak_raw_vprintf+0x28>
; bool weak_raw_vprintf(const char *fmt, va_list args) {
10003c64: 0003         	movs	r3, r0
;     if (lazy_vsnprintf) {
10003c66: 6814         	ldr	r4, [r2]
; bool weak_raw_vprintf(const char *fmt, va_list args) {
10003c68: b084         	sub	sp, #0x10
;     if (lazy_vsnprintf) {
10003c6a: 2c00         	cmp	r4, #0x0
10003c6c: d008         	beq	0x10003c80 <weak_raw_vprintf+0x20> @ imm = #0x10
;         lazy_vsnprintf(_out_char, buffer, (size_t) -1, fmt, args);
10003c6e: 2201         	movs	r2, #0x1
10003c70: 9100         	str	r1, [sp]
10003c72: 4806         	ldr	r0, [pc, #0x18]         @ 0x10003c8c <weak_raw_vprintf+0x2c>
10003c74: 4252         	rsbs	r2, r2, #0
10003c76: a903         	add	r1, sp, #0xc
10003c78: 47a0         	blx	r4
;         return true;
10003c7a: 2001         	movs	r0, #0x1
; }
10003c7c: b004         	add	sp, #0x10
10003c7e: bd10         	pop	{r4, pc}
;         puts(fmt);
10003c80: f000 f97e    	bl	0x10003f80 <stdio_puts> @ imm = #0x2fc
;         return false;
10003c84: 2000         	movs	r0, #0x0
10003c86: e7f9         	b	0x10003c7c <weak_raw_vprintf+0x1c> @ imm = #-0xe
10003c88: 9c 05 00 20  	.word	0x2000059c
10003c8c: 19 26 00 10  	.word	0x10002619

10003c90 <_exit>:
;     pico_default_asm_volatile ("bkpt #0" : : : "memory");
10003c90: be00         	bkpt	#0x0
;     while (1) {
10003c92: e7fd         	b	0x10003c90 <_exit>      @ imm = #-0x6

10003c94 <exit>:
; void exit(int status) {
10003c94: b510         	push	{r4, lr}
;     _exit(status);
10003c96: f7ff fffb    	bl	0x10003c90 <_exit>      @ imm = #-0xa
10003c9a: 46c0         	mov	r8, r8

10003c9c <runtime_init>:
; void runtime_init(void) {
10003c9c: b570         	push	{r4, r5, r6, lr}
;     runtime_run_initializers();
10003c9e: f7fd fb9d    	bl	0x100013dc <runtime_run_initializers> @ imm = #-0x28c6
;     for (void (**p)(void) = &__init_array_start; p < &__init_array_end; ++p) {
10003ca2: 4d07         	ldr	r5, [pc, #0x1c]         @ 0x10003cc0 <runtime_init+0x24>
10003ca4: 4e07         	ldr	r6, [pc, #0x1c]         @ 0x10003cc4 <runtime_init+0x28>
10003ca6: 42b5         	cmp	r5, r6
10003ca8: d209         	bhs	0x10003cbe <runtime_init+0x22> @ imm = #0x12
10003caa: 2400         	movs	r4, #0x0
10003cac: 3e01         	subs	r6, #0x1
10003cae: 1b76         	subs	r6, r6, r5
10003cb0: 08b6         	lsrs	r6, r6, #0x2
;         (*p)();
10003cb2: cd08         	ldm	r5!, {r3}
10003cb4: 4798         	blx	r3
;     for (void (**p)(void) = &__init_array_start; p < &__init_array_end; ++p) {
10003cb6: 0023         	movs	r3, r4
10003cb8: 3401         	adds	r4, #0x1
10003cba: 42b3         	cmp	r3, r6
10003cbc: d1f9         	bne	0x10003cb2 <runtime_init+0x16> @ imm = #-0xe
; }
10003cbe: bd70         	pop	{r4, r5, r6, pc}
10003cc0: 7c 41 00 10  	.word	0x1000417c
10003cc4: 80 41 00 10  	.word	0x10004180

10003cc8 <stdio_out_chars_no_crlf>:
; static void stdio_out_chars_no_crlf(stdio_driver_t *driver, const char *s, int len) {
10003cc8: 0003         	movs	r3, r0
10003cca: b510         	push	{r4, lr}
10003ccc: 0008         	movs	r0, r1
10003cce: 0011         	movs	r1, r2
;     driver->out_chars(s, len);
10003cd0: 681b         	ldr	r3, [r3]
10003cd2: 4798         	blx	r3
; }
10003cd4: bd10         	pop	{r4, pc}
10003cd6: 46c0         	mov	r8, r8

10003cd8 <stdio_out_chars_crlf>:
; static void stdio_out_chars_crlf(stdio_driver_t *driver, const char *s, int len) {
10003cd8: b5f0         	push	{r4, r5, r6, r7, lr}
10003cda: 46c6         	mov	lr, r8
10003cdc: b500         	push	{lr}
;     if (!driver->crlf_enabled) {
10003cde: 7d43         	ldrb	r3, [r0, #0x15]
; static void stdio_out_chars_crlf(stdio_driver_t *driver, const char *s, int len) {
10003ce0: 0007         	movs	r7, r0
10003ce2: 000c         	movs	r4, r1
10003ce4: 0016         	movs	r6, r2
;     if (!driver->crlf_enabled) {
10003ce6: 2b00         	cmp	r3, #0x0
10003ce8: d046         	beq	0x10003d78 <stdio_out_chars_crlf+0xa0> @ imm = #0x8c
;     for (int i = 0; i < len; i++) {
10003cea: 2a00         	cmp	r2, #0x0
10003cec: dd17         	ble	0x10003d1e <stdio_out_chars_crlf+0x46> @ imm = #0x2e
;         if (s[i] == '\n' && !prev_char_was_cr) {
10003cee: 780b         	ldrb	r3, [r1]
10003cf0: 2b0a         	cmp	r3, #0xa
10003cf2: d024         	beq	0x10003d3e <stdio_out_chars_crlf+0x66> @ imm = #0x48
10003cf4: 2300         	movs	r3, #0x0
10003cf6: 4698         	mov	r8, r3
10003cf8: 2e01         	cmp	r6, #0x1
10003cfa: d013         	beq	0x10003d24 <stdio_out_chars_crlf+0x4c> @ imm = #0x26
10003cfc: 2501         	movs	r5, #0x1
;         bool prev_char_was_cr = i > 0 ? s[i - 1] == '\r' : driver->last_ended_with_cr;
10003cfe: 0029         	movs	r1, r5
;         if (s[i] == '\n' && !prev_char_was_cr) {
10003d00: 5c63         	ldrb	r3, [r4, r1]
10003d02: 3501         	adds	r5, #0x1
10003d04: 2b0a         	cmp	r3, #0xa
10003d06: d026         	beq	0x10003d56 <stdio_out_chars_crlf+0x7e> @ imm = #0x4c
;     for (int i = 0; i < len; i++) {
10003d08: 42b5         	cmp	r5, r6
10003d0a: d1f8         	bne	0x10003cfe <stdio_out_chars_crlf+0x26> @ imm = #-0x10
;     if (first_of_chunk < len) {
10003d0c: 4546         	cmp	r6, r8
10003d0e: dc09         	bgt	0x10003d24 <stdio_out_chars_crlf+0x4c> @ imm = #0x12
;         driver->last_ended_with_cr = s[len - 1] == '\r';
10003d10: 19a4         	adds	r4, r4, r6
10003d12: 3c01         	subs	r4, #0x1
10003d14: 7823         	ldrb	r3, [r4]
10003d16: 3b0d         	subs	r3, #0xd
10003d18: 425a         	rsbs	r2, r3, #0
10003d1a: 4153         	adcs	r3, r2
10003d1c: 753b         	strb	r3, [r7, #0x14]
; }
10003d1e: bc80         	pop	{r7}
10003d20: 46b8         	mov	r8, r7
10003d22: bdf0         	pop	{r4, r5, r6, r7, pc}
;         driver->out_chars(&s[first_of_chunk], len - first_of_chunk);
10003d24: 4643         	mov	r3, r8
10003d26: 18e0         	adds	r0, r4, r3
;         driver->last_ended_with_cr = s[len - 1] == '\r';
10003d28: 19a4         	adds	r4, r4, r6
;         driver->out_chars(&s[first_of_chunk], len - first_of_chunk);
10003d2a: 1af1         	subs	r1, r6, r3
;         driver->last_ended_with_cr = s[len - 1] == '\r';
10003d2c: 3c01         	subs	r4, #0x1
;         driver->out_chars(&s[first_of_chunk], len - first_of_chunk);
10003d2e: 683b         	ldr	r3, [r7]
10003d30: 4798         	blx	r3
;         driver->last_ended_with_cr = s[len - 1] == '\r';
10003d32: 7823         	ldrb	r3, [r4]
10003d34: 3b0d         	subs	r3, #0xd
10003d36: 425a         	rsbs	r2, r3, #0
10003d38: 4153         	adcs	r3, r2
10003d3a: 753b         	strb	r3, [r7, #0x14]
10003d3c: e7ef         	b	0x10003d1e <stdio_out_chars_crlf+0x46> @ imm = #-0x22
;         if (s[i] == '\n' && !prev_char_was_cr) {
10003d3e: 7d03         	ldrb	r3, [r0, #0x14]
10003d40: 2b00         	cmp	r3, #0x0
10003d42: d1d7         	bne	0x10003cf4 <stdio_out_chars_crlf+0x1c> @ imm = #-0x52
;             driver->out_chars(crlf_str, 2);
10003d44: 2102         	movs	r1, #0x2
10003d46: 480f         	ldr	r0, [pc, #0x3c]         @ 0x10003d84 <stdio_out_chars_crlf+0xac>
10003d48: 683b         	ldr	r3, [r7]
10003d4a: 4798         	blx	r3
;     for (int i = 0; i < len; i++) {
10003d4c: 2e01         	cmp	r6, #0x1
10003d4e: d0df         	beq	0x10003d10 <stdio_out_chars_crlf+0x38> @ imm = #-0x42
;             first_of_chunk = i + 1;
10003d50: 2301         	movs	r3, #0x1
10003d52: 4698         	mov	r8, r3
10003d54: e7d2         	b	0x10003cfc <stdio_out_chars_crlf+0x24> @ imm = #-0x5c
;         bool prev_char_was_cr = i > 0 ? s[i - 1] == '\r' : driver->last_ended_with_cr;
10003d56: 1e63         	subs	r3, r4, #0x1
;         if (s[i] == '\n' && !prev_char_was_cr) {
10003d58: 5c5b         	ldrb	r3, [r3, r1]
10003d5a: 2b0d         	cmp	r3, #0xd
10003d5c: d0d4         	beq	0x10003d08 <stdio_out_chars_crlf+0x30> @ imm = #-0x58
;             if (i > first_of_chunk) {
10003d5e: 4588         	cmp	r8, r1
10003d60: da04         	bge	0x10003d6c <stdio_out_chars_crlf+0x94> @ imm = #0x8
;                 driver->out_chars(&s[first_of_chunk], i - first_of_chunk);
10003d62: 4643         	mov	r3, r8
10003d64: 1ac9         	subs	r1, r1, r3
10003d66: 18e0         	adds	r0, r4, r3
10003d68: 683b         	ldr	r3, [r7]
10003d6a: 4798         	blx	r3
;             driver->out_chars(crlf_str, 2);
10003d6c: 2102         	movs	r1, #0x2
10003d6e: 4805         	ldr	r0, [pc, #0x14]         @ 0x10003d84 <stdio_out_chars_crlf+0xac>
10003d70: 683b         	ldr	r3, [r7]
;             first_of_chunk = i + 1;
10003d72: 46a8         	mov	r8, r5
;             driver->out_chars(crlf_str, 2);
10003d74: 4798         	blx	r3
;             first_of_chunk = i + 1;
10003d76: e7c7         	b	0x10003d08 <stdio_out_chars_crlf+0x30> @ imm = #-0x72
;         driver->out_chars(s, len);
10003d78: 6803         	ldr	r3, [r0]
10003d7a: 0011         	movs	r1, r2
10003d7c: 0020         	movs	r0, r4
10003d7e: 4798         	blx	r3
;         return;
10003d80: e7cd         	b	0x10003d1e <stdio_out_chars_crlf+0x46> @ imm = #-0x66
10003d82: 46c0         	mov	r8, r8
10003d84: 80 46 00 10  	.word	0x10004680

10003d88 <stdio_buffered_printer>:
; static void stdio_buffered_printer(char c, void *arg) {
10003d88: b5f0         	push	{r4, r5, r6, r7, lr}
10003d8a: 46c6         	mov	lr, r8
;     if (buffer->used == PICO_STDIO_STACK_BUFFER_SIZE) {
10003d8c: 680b         	ldr	r3, [r1]
; static void stdio_buffered_printer(char c, void *arg) {
10003d8e: 0006         	movs	r6, r0
10003d90: 000c         	movs	r4, r1
10003d92: b500         	push	{lr}
;     if (buffer->used == PICO_STDIO_STACK_BUFFER_SIZE) {
10003d94: 2b80         	cmp	r3, #0x80
10003d96: d006         	beq	0x10003da6 <stdio_buffered_printer+0x1e> @ imm = #0xc
;     buffer->buf[buffer->used++] = c;
10003d98: 1c5a         	adds	r2, r3, #0x1
10003d9a: 6022         	str	r2, [r4]
10003d9c: 18e4         	adds	r4, r4, r3
10003d9e: 7126         	strb	r6, [r4, #0x4]
; }
10003da0: bc80         	pop	{r7}
10003da2: 46b8         	mov	r8, r7
10003da4: bdf0         	pop	{r4, r5, r6, r7, pc}
;         for (stdio_driver_t *d = drivers; d; d = d->next) {
10003da6: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x10003de4 <stdio_buffered_printer+0x5c>
10003da8: 681d         	ldr	r5, [r3]
10003daa: 2d00         	cmp	r5, #0x0
10003dac: d016         	beq	0x10003ddc <stdio_buffered_printer+0x54> @ imm = #0x2c
;             stdio_out_chars_crlf(d, buffer->buf, buffer->used);
10003dae: 1d0b         	adds	r3, r1, #0x4
10003db0: 4698         	mov	r8, r3
;             if (filter && filter != d) continue;
10003db2: 4f0d         	ldr	r7, [pc, #0x34]         @ 0x10003de8 <stdio_buffered_printer+0x60>
10003db4: e002         	b	0x10003dbc <stdio_buffered_printer+0x34> @ imm = #0x4
;         for (stdio_driver_t *d = drivers; d; d = d->next) {
10003db6: 692d         	ldr	r5, [r5, #0x10]
10003db8: 2d00         	cmp	r5, #0x0
10003dba: d00f         	beq	0x10003ddc <stdio_buffered_printer+0x54> @ imm = #0x1e
;             if (!d->out_chars) continue;
10003dbc: 682b         	ldr	r3, [r5]
10003dbe: 2b00         	cmp	r3, #0x0
10003dc0: d0f9         	beq	0x10003db6 <stdio_buffered_printer+0x2e> @ imm = #-0xe
;             if (filter && filter != d) continue;
10003dc2: 683b         	ldr	r3, [r7]
10003dc4: 2b00         	cmp	r3, #0x0
10003dc6: d001         	beq	0x10003dcc <stdio_buffered_printer+0x44> @ imm = #0x2
10003dc8: 42ab         	cmp	r3, r5
10003dca: d1f4         	bne	0x10003db6 <stdio_buffered_printer+0x2e> @ imm = #-0x18
;             stdio_out_chars_crlf(d, buffer->buf, buffer->used);
10003dcc: 0028         	movs	r0, r5
10003dce: 4641         	mov	r1, r8
10003dd0: 6822         	ldr	r2, [r4]
10003dd2: f7ff ff81    	bl	0x10003cd8 <stdio_out_chars_crlf> @ imm = #-0xfe
;         for (stdio_driver_t *d = drivers; d; d = d->next) {
10003dd6: 692d         	ldr	r5, [r5, #0x10]
10003dd8: 2d00         	cmp	r5, #0x0
10003dda: d1ef         	bne	0x10003dbc <stdio_buffered_printer+0x34> @ imm = #-0x22
; }
10003ddc: 2201         	movs	r2, #0x1
10003dde: 2300         	movs	r3, #0x0
10003de0: e7db         	b	0x10003d9a <stdio_buffered_printer+0x12> @ imm = #-0x4a
10003de2: 46c0         	mov	r8, r8
10003de4: 94 05 00 20  	.word	0x20000594
10003de8: 98 05 00 20  	.word	0x20000598

10003dec <stdio_put_string>:
; int stdio_put_string(const char *s, int len, bool newline, bool cr_translation) {
10003dec: b5f0         	push	{r4, r5, r6, r7, lr}
10003dee: 4645         	mov	r5, r8
10003df0: 46de         	mov	lr, r11
10003df2: 464e         	mov	r6, r9
10003df4: 4657         	mov	r7, r10
10003df6: b5e0         	push	{r5, r6, r7, lr}
10003df8: b083         	sub	sp, #0xc
10003dfa: 4691         	mov	r9, r2
10003dfc: 001c         	movs	r4, r3
10003dfe: 4680         	mov	r8, r0
10003e00: 000d         	movs	r5, r1
;     update_us_since_boot(&t, time_us_64());
10003e02: f7fd f935    	bl	0x10001070 <time_us_64> @ imm = #-0x2d96
;     uint64_t delayed = base + ms * 1000ull;
10003e06: 2300         	movs	r3, #0x0
10003e08: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x10003ecc <stdio_put_string+0xe0>
10003e0a: 1812         	adds	r2, r2, r0
10003e0c: 414b         	adcs	r3, r1
;     return mutex_try_enter_block_until(&print_mutex, make_timeout_time_ms(PICO_STDIO_DEADLOCK_TIMEOUT_MS));
10003e0e: 2b00         	cmp	r3, #0x0
10003e10: da02         	bge	0x10003e18 <stdio_put_string+0x2c> @ imm = #0x4
10003e12: 2201         	movs	r2, #0x1
10003e14: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x10003ed0 <stdio_put_string+0xe4>
10003e16: 4252         	rsbs	r2, r2, #0
10003e18: 492e         	ldr	r1, [pc, #0xb8]         @ 0x10003ed4 <stdio_put_string+0xe8>
10003e1a: 0008         	movs	r0, r1
10003e1c: 468a         	mov	r10, r1
10003e1e: f000 f987    	bl	0x10004130 <__mutex_try_enter_block_until_veneer> @ imm = #0x30e
10003e22: 0007         	movs	r7, r0
;     if (len == -1) len = (int)strlen(s);
10003e24: 1c6b         	adds	r3, r5, #0x1
10003e26: d103         	bne	0x10003e30 <stdio_put_string+0x44> @ imm = #0x6
10003e28: 4640         	mov	r0, r8
10003e2a: f000 f939    	bl	0x100040a0 <strlen>     @ imm = #0x272
10003e2e: 0005         	movs	r5, r0
;     void (*out_func)(stdio_driver_t *, const char *, int) = cr_translation ? stdio_out_chars_crlf : stdio_out_chars_no_crlf;
10003e30: 2c00         	cmp	r4, #0x0
10003e32: d027         	beq	0x10003e84 <stdio_put_string+0x98> @ imm = #0x4e
10003e34: 4e28         	ldr	r6, [pc, #0xa0]         @ 0x10003ed8 <stdio_put_string+0xec>
;     for (stdio_driver_t *driver = drivers; driver; driver = driver->next) {
10003e36: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x10003edc <stdio_put_string+0xf0>
10003e38: 681c         	ldr	r4, [r3]
10003e3a: 2c00         	cmp	r4, #0x0
10003e3c: d018         	beq	0x10003e70 <stdio_put_string+0x84> @ imm = #0x30
10003e3e: 464b         	mov	r3, r9
10003e40: 2b00         	cmp	r3, #0x0
10003e42: d121         	bne	0x10003e88 <stdio_put_string+0x9c> @ imm = #0x42
;         if (filter && filter != driver) continue;
10003e44: 4b26         	ldr	r3, [pc, #0x98]         @ 0x10003ee0 <stdio_put_string+0xf4>
10003e46: 4699         	mov	r9, r3
10003e48: e002         	b	0x10003e50 <stdio_put_string+0x64> @ imm = #0x4
;     for (stdio_driver_t *driver = drivers; driver; driver = driver->next) {
10003e4a: 6924         	ldr	r4, [r4, #0x10]
10003e4c: 2c00         	cmp	r4, #0x0
10003e4e: d00f         	beq	0x10003e70 <stdio_put_string+0x84> @ imm = #0x1e
;         if (!driver->out_chars) continue;
10003e50: 6823         	ldr	r3, [r4]
10003e52: 2b00         	cmp	r3, #0x0
10003e54: d0f9         	beq	0x10003e4a <stdio_put_string+0x5e> @ imm = #-0xe
;         if (filter && filter != driver) continue;
10003e56: 464b         	mov	r3, r9
10003e58: 681b         	ldr	r3, [r3]
10003e5a: 2b00         	cmp	r3, #0x0
10003e5c: d001         	beq	0x10003e62 <stdio_put_string+0x76> @ imm = #0x2
10003e5e: 429c         	cmp	r4, r3
10003e60: d1f3         	bne	0x10003e4a <stdio_put_string+0x5e> @ imm = #-0x1a
;         out_func(driver, s, len);
10003e62: 0020         	movs	r0, r4
10003e64: 002a         	movs	r2, r5
10003e66: 4641         	mov	r1, r8
10003e68: 47b0         	blx	r6
;     for (stdio_driver_t *driver = drivers; driver; driver = driver->next) {
10003e6a: 6924         	ldr	r4, [r4, #0x10]
10003e6c: 2c00         	cmp	r4, #0x0
10003e6e: d1ef         	bne	0x10003e50 <stdio_put_string+0x64> @ imm = #-0x22
;     if (serialized) {
10003e70: 2f00         	cmp	r7, #0x0
10003e72: d126         	bne	0x10003ec2 <stdio_put_string+0xd6> @ imm = #0x4c
; }
10003e74: 0028         	movs	r0, r5
10003e76: b003         	add	sp, #0xc
10003e78: bcf0         	pop	{r4, r5, r6, r7}
10003e7a: 46bb         	mov	r11, r7
10003e7c: 46b2         	mov	r10, r6
10003e7e: 46a9         	mov	r9, r5
10003e80: 46a0         	mov	r8, r4
10003e82: bdf0         	pop	{r4, r5, r6, r7, pc}
;     void (*out_func)(stdio_driver_t *, const char *, int) = cr_translation ? stdio_out_chars_crlf : stdio_out_chars_no_crlf;
10003e84: 4e17         	ldr	r6, [pc, #0x5c]         @ 0x10003ee4 <stdio_put_string+0xf8>
10003e86: e7d6         	b	0x10003e36 <stdio_put_string+0x4a> @ imm = #-0x54
;         if (filter && filter != driver) continue;
10003e88: 4b15         	ldr	r3, [pc, #0x54]         @ 0x10003ee0 <stdio_put_string+0xf4>
10003e8a: 4699         	mov	r9, r3
;             const char c = '\n';
10003e8c: 230a         	movs	r3, #0xa
10003e8e: 469b         	mov	r11, r3
10003e90: e002         	b	0x10003e98 <stdio_put_string+0xac> @ imm = #0x4
;     for (stdio_driver_t *driver = drivers; driver; driver = driver->next) {
10003e92: 6924         	ldr	r4, [r4, #0x10]
10003e94: 2c00         	cmp	r4, #0x0
10003e96: d0eb         	beq	0x10003e70 <stdio_put_string+0x84> @ imm = #-0x2a
;         if (!driver->out_chars) continue;
10003e98: 6823         	ldr	r3, [r4]
10003e9a: 2b00         	cmp	r3, #0x0
10003e9c: d0f9         	beq	0x10003e92 <stdio_put_string+0xa6> @ imm = #-0xe
;         if (filter && filter != driver) continue;
10003e9e: 464b         	mov	r3, r9
10003ea0: 681b         	ldr	r3, [r3]
10003ea2: 2b00         	cmp	r3, #0x0
10003ea4: d001         	beq	0x10003eaa <stdio_put_string+0xbe> @ imm = #0x2
10003ea6: 42a3         	cmp	r3, r4
10003ea8: d1f3         	bne	0x10003e92 <stdio_put_string+0xa6> @ imm = #-0x1a
;         out_func(driver, s, len);
10003eaa: 002a         	movs	r2, r5
10003eac: 4641         	mov	r1, r8
10003eae: 0020         	movs	r0, r4
10003eb0: 47b0         	blx	r6
;             const char c = '\n';
10003eb2: 466b         	mov	r3, sp
10003eb4: 465a         	mov	r2, r11
;             out_func(driver, &c, 1);
10003eb6: 0020         	movs	r0, r4
;             const char c = '\n';
10003eb8: 71da         	strb	r2, [r3, #0x7]
;             out_func(driver, &c, 1);
10003eba: 1dd9         	adds	r1, r3, #0x7
10003ebc: 2201         	movs	r2, #0x1
10003ebe: 47b0         	blx	r6
10003ec0: e7e7         	b	0x10003e92 <stdio_put_string+0xa6> @ imm = #-0x32
;     mutex_exit(&print_mutex);
10003ec2: 4650         	mov	r0, r10
10003ec4: f000 f91c    	bl	0x10004100 <__mutex_exit_veneer> @ imm = #0x238
; }
10003ec8: e7d4         	b	0x10003e74 <stdio_put_string+0x88> @ imm = #-0x58
10003eca: 46c0         	mov	r8, r8
10003ecc: 40 42 0f 00  	.word	0x000f4240
10003ed0: ff ff ff 7f  	.word	0x7fffffff
10003ed4: e0 01 00 20  	.word	0x200001e0
10003ed8: d9 3c 00 10  	.word	0x10003cd9
10003edc: 94 05 00 20  	.word	0x20000594
10003ee0: 98 05 00 20  	.word	0x20000598
10003ee4: c9 3c 00 10  	.word	0x10003cc9

10003ee8 <stdio_init_all>:
; }
10003ee8: 2000         	movs	r0, #0x0
10003eea: 4770         	bx	lr

10003eec <stdio_putchar>:
; int PRIMARY_STDIO_FUNC(putchar)(int c) {
10003eec: b5f0         	push	{r4, r5, r6, r7, lr}
10003eee: 46ce         	mov	lr, r9
10003ef0: 4647         	mov	r7, r8
10003ef2: b580         	push	{r7, lr}
10003ef4: b083         	sub	sp, #0xc
;     char cc = (char)c;
10003ef6: 466b         	mov	r3, sp
; int PRIMARY_STDIO_FUNC(putchar)(int c) {
10003ef8: 0006         	movs	r6, r0
;     char cc = (char)c;
10003efa: 1ddd         	adds	r5, r3, #0x7
10003efc: 7028         	strb	r0, [r5]
;     update_us_since_boot(&t, time_us_64());
10003efe: f7fd f8b7    	bl	0x10001070 <time_us_64> @ imm = #-0x2e92
;     uint64_t delayed = base + ms * 1000ull;
10003f02: 2300         	movs	r3, #0x0
10003f04: 4a19         	ldr	r2, [pc, #0x64]         @ 0x10003f6c <stdio_putchar+0x80>
10003f06: 1812         	adds	r2, r2, r0
10003f08: 414b         	adcs	r3, r1
;     return mutex_try_enter_block_until(&print_mutex, make_timeout_time_ms(PICO_STDIO_DEADLOCK_TIMEOUT_MS));
10003f0a: 2b00         	cmp	r3, #0x0
10003f0c: da02         	bge	0x10003f14 <stdio_putchar+0x28> @ imm = #0x4
10003f0e: 2201         	movs	r2, #0x1
10003f10: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x10003f70 <stdio_putchar+0x84>
10003f12: 4252         	rsbs	r2, r2, #0
10003f14: 4917         	ldr	r1, [pc, #0x5c]         @ 0x10003f74 <stdio_putchar+0x88>
10003f16: 0008         	movs	r0, r1
10003f18: 4688         	mov	r8, r1
10003f1a: f000 f909    	bl	0x10004130 <__mutex_try_enter_block_until_veneer> @ imm = #0x212
;     for (stdio_driver_t *driver = drivers; driver; driver = driver->next) {
10003f1e: 4b16         	ldr	r3, [pc, #0x58]         @ 0x10003f78 <stdio_putchar+0x8c>
;     return mutex_try_enter_block_until(&print_mutex, make_timeout_time_ms(PICO_STDIO_DEADLOCK_TIMEOUT_MS));
10003f20: 4681         	mov	r9, r0
;     for (stdio_driver_t *driver = drivers; driver; driver = driver->next) {
10003f22: 681c         	ldr	r4, [r3]
10003f24: 2c00         	cmp	r4, #0x0
10003f26: d014         	beq	0x10003f52 <stdio_putchar+0x66> @ imm = #0x28
;         if (filter && filter != driver) continue;
10003f28: 4f14         	ldr	r7, [pc, #0x50]         @ 0x10003f7c <stdio_putchar+0x90>
10003f2a: e002         	b	0x10003f32 <stdio_putchar+0x46> @ imm = #0x4
;     for (stdio_driver_t *driver = drivers; driver; driver = driver->next) {
10003f2c: 6924         	ldr	r4, [r4, #0x10]
10003f2e: 2c00         	cmp	r4, #0x0
10003f30: d00f         	beq	0x10003f52 <stdio_putchar+0x66> @ imm = #0x1e
;         if (!driver->out_chars) continue;
10003f32: 6823         	ldr	r3, [r4]
10003f34: 2b00         	cmp	r3, #0x0
10003f36: d0f9         	beq	0x10003f2c <stdio_putchar+0x40> @ imm = #-0xe
;         if (filter && filter != driver) continue;
10003f38: 683b         	ldr	r3, [r7]
10003f3a: 2b00         	cmp	r3, #0x0
10003f3c: d001         	beq	0x10003f42 <stdio_putchar+0x56> @ imm = #0x2
10003f3e: 429c         	cmp	r4, r3
10003f40: d1f4         	bne	0x10003f2c <stdio_putchar+0x40> @ imm = #-0x18
;         out_func(driver, s, len);
10003f42: 0020         	movs	r0, r4
10003f44: 2201         	movs	r2, #0x1
10003f46: 0029         	movs	r1, r5
10003f48: f7ff fec6    	bl	0x10003cd8 <stdio_out_chars_crlf> @ imm = #-0x274
;     for (stdio_driver_t *driver = drivers; driver; driver = driver->next) {
10003f4c: 6924         	ldr	r4, [r4, #0x10]
10003f4e: 2c00         	cmp	r4, #0x0
10003f50: d1ef         	bne	0x10003f32 <stdio_putchar+0x46> @ imm = #-0x22
;     if (serialized) {
10003f52: 464b         	mov	r3, r9
10003f54: 2b00         	cmp	r3, #0x0
10003f56: d105         	bne	0x10003f64 <stdio_putchar+0x78> @ imm = #0xa
; }
10003f58: 0030         	movs	r0, r6
10003f5a: b003         	add	sp, #0xc
10003f5c: bcc0         	pop	{r6, r7}
10003f5e: 46b9         	mov	r9, r7
10003f60: 46b0         	mov	r8, r6
10003f62: bdf0         	pop	{r4, r5, r6, r7, pc}
;     mutex_exit(&print_mutex);
10003f64: 4640         	mov	r0, r8
10003f66: f000 f8cb    	bl	0x10004100 <__mutex_exit_veneer> @ imm = #0x196
; }
10003f6a: e7f5         	b	0x10003f58 <stdio_putchar+0x6c> @ imm = #-0x16
10003f6c: 40 42 0f 00  	.word	0x000f4240
10003f70: ff ff ff 7f  	.word	0x7fffffff
10003f74: e0 01 00 20  	.word	0x200001e0
10003f78: 94 05 00 20  	.word	0x20000594
10003f7c: 98 05 00 20  	.word	0x20000598

10003f80 <stdio_puts>:
; int PRIMARY_STDIO_FUNC(puts)(const char *s) {
10003f80: b570         	push	{r4, r5, r6, lr}
10003f82: 0004         	movs	r4, r0
;     int len = (int)strlen(s);
10003f84: f000 f88c    	bl	0x100040a0 <strlen>     @ imm = #0x118
;     stdio_put_string(s, len, true, true);
10003f88: 2301         	movs	r3, #0x1
10003f8a: 0001         	movs	r1, r0
;     int len = (int)strlen(s);
10003f8c: 0005         	movs	r5, r0
;     stdio_put_string(s, len, true, true);
10003f8e: 2201         	movs	r2, #0x1
10003f90: 0020         	movs	r0, r4
10003f92: f7ff ff2b    	bl	0x10003dec <stdio_put_string> @ imm = #-0x1aa
;     for (stdio_driver_t *d = drivers; d; d = d->next) {
10003f96: 4b08         	ldr	r3, [pc, #0x20]         @ 0x10003fb8 <stdio_puts+0x38>
10003f98: 681c         	ldr	r4, [r3]
10003f9a: 2c00         	cmp	r4, #0x0
10003f9c: d006         	beq	0x10003fac <stdio_puts+0x2c> @ imm = #0xc
;         if (d->out_flush) d->out_flush();
10003f9e: 6863         	ldr	r3, [r4, #0x4]
10003fa0: 2b00         	cmp	r3, #0x0
10003fa2: d005         	beq	0x10003fb0 <stdio_puts+0x30> @ imm = #0xa
10003fa4: 4798         	blx	r3
;     for (stdio_driver_t *d = drivers; d; d = d->next) {
10003fa6: 6924         	ldr	r4, [r4, #0x10]
10003fa8: 2c00         	cmp	r4, #0x0
10003faa: d1f8         	bne	0x10003f9e <stdio_puts+0x1e> @ imm = #-0x10
; }
10003fac: 0028         	movs	r0, r5
10003fae: bd70         	pop	{r4, r5, r6, pc}
;     for (stdio_driver_t *d = drivers; d; d = d->next) {
10003fb0: 6924         	ldr	r4, [r4, #0x10]
10003fb2: 2c00         	cmp	r4, #0x0
10003fb4: d1f3         	bne	0x10003f9e <stdio_puts+0x1e> @ imm = #-0x1a
10003fb6: e7f9         	b	0x10003fac <stdio_puts+0x2c> @ imm = #-0xe
10003fb8: 94 05 00 20  	.word	0x20000594

10003fbc <stdio_vprintf>:
; int PRIMARY_STDIO_FUNC(vprintf)(const char *format, va_list va) {
10003fbc: b5f0         	push	{r4, r5, r6, r7, lr}
10003fbe: 46ce         	mov	lr, r9
10003fc0: 4647         	mov	r7, r8
10003fc2: b580         	push	{r7, lr}
10003fc4: b0a3         	sub	sp, #0x8c
10003fc6: 0004         	movs	r4, r0
10003fc8: 000d         	movs	r5, r1
;     update_us_since_boot(&t, time_us_64());
10003fca: f7fd f851    	bl	0x10001070 <time_us_64> @ imm = #-0x2f5e
;     uint64_t delayed = base + ms * 1000ull;
10003fce: 2300         	movs	r3, #0x0
10003fd0: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x10004070 <stdio_vprintf+0xb4>
10003fd2: 1812         	adds	r2, r2, r0
10003fd4: 414b         	adcs	r3, r1
;     return mutex_try_enter_block_until(&print_mutex, make_timeout_time_ms(PICO_STDIO_DEADLOCK_TIMEOUT_MS));
10003fd6: 2b00         	cmp	r3, #0x0
10003fd8: da02         	bge	0x10003fe0 <stdio_vprintf+0x24> @ imm = #0x4
10003fda: 2201         	movs	r2, #0x1
10003fdc: 4b25         	ldr	r3, [pc, #0x94]         @ 0x10004074 <stdio_vprintf+0xb8>
10003fde: 4252         	rsbs	r2, r2, #0
10003fe0: 4e25         	ldr	r6, [pc, #0x94]         @ 0x10004078 <stdio_vprintf+0xbc>
10003fe2: 0030         	movs	r0, r6
10003fe4: f000 f8a4    	bl	0x10004130 <__mutex_try_enter_block_until_veneer> @ imm = #0x148
;     buffer.used = 0;
10003fe8: 2300         	movs	r3, #0x0
;     ret = vfctprintf(stdio_buffered_printer, &buffer, format, va);
10003fea: 0022         	movs	r2, r4
;     buffer.used = 0;
10003fec: 9301         	str	r3, [sp, #0x4]
;     return mutex_try_enter_block_until(&print_mutex, make_timeout_time_ms(PICO_STDIO_DEADLOCK_TIMEOUT_MS));
10003fee: 0007         	movs	r7, r0
;     ret = vfctprintf(stdio_buffered_printer, &buffer, format, va);
10003ff0: 002b         	movs	r3, r5
10003ff2: 4822         	ldr	r0, [pc, #0x88]         @ 0x1000407c <stdio_vprintf+0xc0>
10003ff4: a901         	add	r1, sp, #0x4
10003ff6: f7ff fe21    	bl	0x10003c3c <vfctprintf> @ imm = #-0x3be
;         for (stdio_driver_t *d = drivers; d; d = d->next) {
10003ffa: 4b21         	ldr	r3, [pc, #0x84]         @ 0x10004080 <stdio_vprintf+0xc4>
;     ret = vfctprintf(stdio_buffered_printer, &buffer, format, va);
10003ffc: 4680         	mov	r8, r0
;         for (stdio_driver_t *d = drivers; d; d = d->next) {
10003ffe: 4699         	mov	r9, r3
10004000: 681c         	ldr	r4, [r3]
;     if (buffer->used) {
10004002: 9b01         	ldr	r3, [sp, #0x4]
10004004: 2b00         	cmp	r3, #0x0
10004006: d01a         	beq	0x1000403e <stdio_vprintf+0x82> @ imm = #0x34
;         for (stdio_driver_t *d = drivers; d; d = d->next) {
10004008: 2c00         	cmp	r4, #0x0
1000400a: d02f         	beq	0x1000406c <stdio_vprintf+0xb0> @ imm = #0x5e
;             if (filter && filter != d) continue;
1000400c: 4d1d         	ldr	r5, [pc, #0x74]         @ 0x10004084 <stdio_vprintf+0xc8>
1000400e: e002         	b	0x10004016 <stdio_vprintf+0x5a> @ imm = #0x4
;         for (stdio_driver_t *d = drivers; d; d = d->next) {
10004010: 6924         	ldr	r4, [r4, #0x10]
10004012: 2c00         	cmp	r4, #0x0
10004014: d00f         	beq	0x10004036 <stdio_vprintf+0x7a> @ imm = #0x1e
;             if (!d->out_chars) continue;
10004016: 6823         	ldr	r3, [r4]
10004018: 2b00         	cmp	r3, #0x0
1000401a: d0f9         	beq	0x10004010 <stdio_vprintf+0x54> @ imm = #-0xe
;             if (filter && filter != d) continue;
1000401c: 682b         	ldr	r3, [r5]
1000401e: 2b00         	cmp	r3, #0x0
10004020: d001         	beq	0x10004026 <stdio_vprintf+0x6a> @ imm = #0x2
10004022: 42a3         	cmp	r3, r4
10004024: d1f4         	bne	0x10004010 <stdio_vprintf+0x54> @ imm = #-0x18
;             stdio_out_chars_crlf(d, buffer->buf, buffer->used);
10004026: 0020         	movs	r0, r4
10004028: 9a01         	ldr	r2, [sp, #0x4]
1000402a: a902         	add	r1, sp, #0x8
1000402c: f7ff fe54    	bl	0x10003cd8 <stdio_out_chars_crlf> @ imm = #-0x358
;         for (stdio_driver_t *d = drivers; d; d = d->next) {
10004030: 6924         	ldr	r4, [r4, #0x10]
10004032: 2c00         	cmp	r4, #0x0
10004034: d1ef         	bne	0x10004016 <stdio_vprintf+0x5a> @ imm = #-0x22
;     for (stdio_driver_t *d = drivers; d; d = d->next) {
10004036: 464b         	mov	r3, r9
10004038: 681c         	ldr	r4, [r3]
;         buffer->used = 0;
1000403a: 2300         	movs	r3, #0x0
1000403c: 9301         	str	r3, [sp, #0x4]
;     for (stdio_driver_t *d = drivers; d; d = d->next) {
1000403e: 2c00         	cmp	r4, #0x0
10004040: d006         	beq	0x10004050 <stdio_vprintf+0x94> @ imm = #0xc
;         if (d->out_flush) d->out_flush();
10004042: 6863         	ldr	r3, [r4, #0x4]
10004044: 2b00         	cmp	r3, #0x0
10004046: d00b         	beq	0x10004060 <stdio_vprintf+0xa4> @ imm = #0x16
10004048: 4798         	blx	r3
;     for (stdio_driver_t *d = drivers; d; d = d->next) {
1000404a: 6924         	ldr	r4, [r4, #0x10]
1000404c: 2c00         	cmp	r4, #0x0
1000404e: d1f8         	bne	0x10004042 <stdio_vprintf+0x86> @ imm = #-0x10
;     if (serialzed) {
10004050: 2f00         	cmp	r7, #0x0
10004052: d107         	bne	0x10004064 <stdio_vprintf+0xa8> @ imm = #0xe
; }
10004054: 4640         	mov	r0, r8
10004056: b023         	add	sp, #0x8c
10004058: bcc0         	pop	{r6, r7}
1000405a: 46b9         	mov	r9, r7
1000405c: 46b0         	mov	r8, r6
1000405e: bdf0         	pop	{r4, r5, r6, r7, pc}
;     for (stdio_driver_t *d = drivers; d; d = d->next) {
10004060: 6924         	ldr	r4, [r4, #0x10]
10004062: e7ec         	b	0x1000403e <stdio_vprintf+0x82> @ imm = #-0x28
;     mutex_exit(&print_mutex);
10004064: 0030         	movs	r0, r6
10004066: f000 f84b    	bl	0x10004100 <__mutex_exit_veneer> @ imm = #0x96
;     return ret;
1000406a: e7f3         	b	0x10004054 <stdio_vprintf+0x98> @ imm = #-0x1a
;         buffer->used = 0;
1000406c: 9401         	str	r4, [sp, #0x4]
;     for (stdio_driver_t *d = drivers; d; d = d->next) {
1000406e: e7ef         	b	0x10004050 <stdio_vprintf+0x94> @ imm = #-0x22
10004070: 40 42 0f 00  	.word	0x000f4240
10004074: ff ff ff 7f  	.word	0x7fffffff
10004078: e0 01 00 20  	.word	0x200001e0
1000407c: 89 3d 00 10  	.word	0x10003d89
10004080: 94 05 00 20  	.word	0x20000594
10004084: 98 05 00 20  	.word	0x20000598

10004088 <stdio_printf>:
; {
10004088: b40f         	push	{r0, r1, r2, r3}
1000408a: b500         	push	{lr}
1000408c: b083         	sub	sp, #0xc
1000408e: a904         	add	r1, sp, #0x10
10004090: c901         	ldm	r1!, {r0}
;     va_start(va, format);
10004092: 9101         	str	r1, [sp, #0x4]
;     int ret = vprintf(format, va);
10004094: f7ff ff92    	bl	0x10003fbc <stdio_vprintf> @ imm = #-0xdc
; }
10004098: b003         	add	sp, #0xc
1000409a: bc08         	pop	{r3}
1000409c: b004         	add	sp, #0x10
1000409e: 4718         	bx	r3

100040a0 <strlen>:
100040a0: b510         	push	{r4, lr}
100040a2: 0783         	lsls	r3, r0, #0x1e
100040a4: d00a         	beq	0x100040bc <strlen+0x1c> @ imm = #0x14
100040a6: 0003         	movs	r3, r0
100040a8: 2103         	movs	r1, #0x3
100040aa: e002         	b	0x100040b2 <strlen+0x12> @ imm = #0x4
100040ac: 3301         	adds	r3, #0x1
100040ae: 420b         	tst	r3, r1
100040b0: d005         	beq	0x100040be <strlen+0x1e> @ imm = #0xa
100040b2: 781a         	ldrb	r2, [r3]
100040b4: 2a00         	cmp	r2, #0x0
100040b6: d1f9         	bne	0x100040ac <strlen+0xc> @ imm = #-0xe
100040b8: 1a18         	subs	r0, r3, r0
100040ba: bd10         	pop	{r4, pc}
100040bc: 0003         	movs	r3, r0
100040be: 6819         	ldr	r1, [r3]
100040c0: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x100040f4 <strlen+0x54>
100040c2: 4c0d         	ldr	r4, [pc, #0x34]         @ 0x100040f8 <strlen+0x58>
100040c4: 188a         	adds	r2, r1, r2
100040c6: 438a         	bics	r2, r1
100040c8: 4222         	tst	r2, r4
100040ca: d10f         	bne	0x100040ec <strlen+0x4c> @ imm = #0x1e
100040cc: 6859         	ldr	r1, [r3, #0x4]
100040ce: 4a09         	ldr	r2, [pc, #0x24]         @ 0x100040f4 <strlen+0x54>
100040d0: 3304         	adds	r3, #0x4
100040d2: 188a         	adds	r2, r1, r2
100040d4: 438a         	bics	r2, r1
100040d6: 4222         	tst	r2, r4
100040d8: d108         	bne	0x100040ec <strlen+0x4c> @ imm = #0x10
100040da: 6859         	ldr	r1, [r3, #0x4]
100040dc: 4a05         	ldr	r2, [pc, #0x14]         @ 0x100040f4 <strlen+0x54>
100040de: 3304         	adds	r3, #0x4
100040e0: 188a         	adds	r2, r1, r2
100040e2: 438a         	bics	r2, r1
100040e4: 4222         	tst	r2, r4
100040e6: d0f1         	beq	0x100040cc <strlen+0x2c> @ imm = #-0x1e
100040e8: e000         	b	0x100040ec <strlen+0x4c> @ imm = #0x0
100040ea: 3301         	adds	r3, #0x1
100040ec: 781a         	ldrb	r2, [r3]
100040ee: 2a00         	cmp	r2, #0x0
100040f0: d1fb         	bne	0x100040ea <strlen+0x4a> @ imm = #-0xa
100040f2: e7e1         	b	0x100040b8 <strlen+0x18> @ imm = #-0x3e
100040f4: ff fe fe fe  	.word	0xfefefeff
100040f8: 80 80 80 80  	.word	0x80808080

100040fc <_fini>:
100040fc: b5f8         	push	{r3, r4, r5, r6, r7, lr}
100040fe: 46c0         	mov	r8, r8

10004100 <__mutex_exit_veneer>:
10004100: b401         	push	{r0}
10004102: 4802         	ldr	r0, [pc, #0x8]          @ 0x1000410c <__mutex_exit_veneer+0xc>
10004104: 4684         	mov	r12, r0
10004106: bc01         	pop	{r0}
10004108: 4760         	bx	r12
1000410a: bf00         	nop
1000410c: 59 01 00 20  	.word	0x20000159

10004110 <____aeabi_ldiv0_veneer>:
10004110: b401         	push	{r0}
10004112: 4802         	ldr	r0, [pc, #0x8]          @ 0x1000411c <____aeabi_ldiv0_veneer+0xc>
10004114: 4684         	mov	r12, r0
10004116: bc01         	pop	{r0}
10004118: 4760         	bx	r12
1000411a: bf00         	nop
1000411c: 81 01 00 20  	.word	0x20000181

10004120 <____aeabi_idiv0_veneer>:
10004120: b401         	push	{r0}
10004122: 4802         	ldr	r0, [pc, #0x8]          @ 0x1000412c <____aeabi_idiv0_veneer+0xc>
10004124: 4684         	mov	r12, r0
10004126: bc01         	pop	{r0}
10004128: 4760         	bx	r12
1000412a: bf00         	nop
1000412c: 81 01 00 20  	.word	0x20000181

10004130 <__mutex_try_enter_block_until_veneer>:
10004130: b401         	push	{r0}
10004132: 4802         	ldr	r0, [pc, #0x8]          @ 0x1000413c <__mutex_try_enter_block_until_veneer+0xc>
10004134: 4684         	mov	r12, r0
10004136: bc01         	pop	{r0}
10004138: 4760         	bx	r12
1000413a: bf00         	nop
1000413c: c1 00 00 20  	.word	0x200000c1

10004140 <__preinit_array_start>:
10004140: 05 14 00 10  	.word	0x10001405
10004144: 31 14 00 10  	.word	0x10001431
10004148: 7d 15 00 10  	.word	0x1000157d
1000414c: 81 23 00 10  	.word	0x10002381
10004150: 21 1c 00 10  	.word	0x10001c21
10004154: c1 22 00 10  	.word	0x100022c1
10004158: a5 14 00 10  	.word	0x100014a5
1000415c: 4d 14 00 10  	.word	0x1000144d
10004160: 6d 14 00 10  	.word	0x1000146d
10004164: 81 14 00 10  	.word	0x10001481
10004168: c5 08 00 10  	.word	0x100008c5
1000416c: 89 14 00 10  	.word	0x10001489
10004170: 45 0c 00 10  	.word	0x10000c45
10004174: cd 13 00 10  	.word	0x100013cd
10004178: 19 08 00 10  	.word	0x10000819

1000417c <__preinit_array_end>:
1000417c: b1 02 00 10  	.word	0x100002b1

Disassembly of section .data:

200000c0 <mutex_try_enter_block_until>:
; bool __time_critical_func(mutex_try_enter_block_until)(mutex_t *mtx, absolute_time_t until) {
200000c0: b5f0         	push	{r4, r5, r6, r7, lr}
200000c2: 46c6         	mov	lr, r8
200000c4: 0015         	movs	r5, r2
200000c6: b500         	push	{lr}
200000c8: 0004         	movs	r4, r0
200000ca: 001e         	movs	r6, r3
;     uint32_t save = spin_lock_blocking(mtx->core.spin_lock);
200000cc: 6802         	ldr	r2, [r0]
;     pico_default_asm_volatile (
200000ce: f3ef 8110    	mrs	r1, primask
200000d2: b672         	cpsid i
;     while (__builtin_expect(!*lock, 0)) { // read from spinlock register (tries to acquire the lock)
200000d4: 6813         	ldr	r3, [r2]
200000d6: 2b00         	cmp	r3, #0x0
200000d8: d0fc         	beq	0x200000d4 <mutex_try_enter_block_until+0x14> @ imm = #-0x8
;     pico_default_asm_volatile ("dmb" : : : "memory");
200000da: f3bf 8f5f    	dmb	sy
;     if (!lock_is_owner_id_valid(mtx->owner)) {
200000de: 2304         	movs	r3, #0x4
200000e0: 56e3         	ldrsb	r3, [r4, r3]
;     spin_unlock(mtx->core.spin_lock, save);
200000e2: 6822         	ldr	r2, [r4]
;     if (!lock_is_owner_id_valid(mtx->owner)) {
200000e4: 2b00         	cmp	r3, #0x0
200000e6: db2b         	blt	0x20000140 <mutex_try_enter_block_until+0x80> @ imm = #0x56
;     pico_default_asm_volatile ("dmb" : : : "memory");
200000e8: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
200000ec: 2000         	movs	r0, #0x0
200000ee: 6010         	str	r0, [r2]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
200000f0: f381 8810    	msr	primask, r1
;         if ((lock_owner_id_t)owner == lock_get_caller_owner_id()) return false; // deadlock, so we can never own it
200000f4: 22d0         	movs	r2, #0xd0
200000f6: 0612         	lsls	r2, r2, #0x18
200000f8: 7812         	ldrb	r2, [r2]
;     *lock = 0; // write to spinlock register (release lock)
200000fa: 2700         	movs	r7, #0x0
;         if ((lock_owner_id_t)owner == lock_get_caller_owner_id()) return false; // deadlock, so we can never own it
200000fc: b252         	sxtb	r2, r2
200000fe: 4690         	mov	r8, r2
20000100: 429a         	cmp	r2, r3
20000102: d10e         	bne	0x20000122 <mutex_try_enter_block_until+0x62> @ imm = #0x1c
20000104: 2000         	movs	r0, #0x0
; }
20000106: bc80         	pop	{r7}
20000108: 46b8         	mov	r8, r7
2000010a: bdf0         	pop	{r4, r5, r6, r7, pc}
;     pico_default_asm_volatile ("dmb" : : : "memory");
2000010c: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
20000110: 6017         	str	r7, [r2]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
20000112: f381 8810    	msr	primask, r1
;             if (lock_internal_spin_unlock_with_best_effort_wait_or_timeout(&mtx->core, save, until)) {
20000116: 0028         	movs	r0, r5
20000118: 0031         	movs	r1, r6
2000011a: f000 f835    	bl	0x20000188 <__best_effort_wfe_or_timeout_veneer> @ imm = #0x6a
2000011e: 2800         	cmp	r0, #0x0
20000120: d1f0         	bne	0x20000104 <mutex_try_enter_block_until+0x44> @ imm = #-0x20
;         uint32_t save = spin_lock_blocking(mtx->core.spin_lock);
20000122: 6822         	ldr	r2, [r4]
;     pico_default_asm_volatile (
20000124: f3ef 8110    	mrs	r1, primask
20000128: b672         	cpsid i
;     while (__builtin_expect(!*lock, 0)) { // read from spinlock register (tries to acquire the lock)
2000012a: 6813         	ldr	r3, [r2]
2000012c: 2b00         	cmp	r3, #0x0
2000012e: d0fc         	beq	0x2000012a <mutex_try_enter_block_until+0x6a> @ imm = #-0x8
;     pico_default_asm_volatile ("dmb" : : : "memory");
20000130: f3bf 8f5f    	dmb	sy
;         if (!lock_is_owner_id_valid(mtx->owner)) {
20000134: 7923         	ldrb	r3, [r4, #0x4]
;             spin_unlock(mtx->core.spin_lock, save);
20000136: 6822         	ldr	r2, [r4]
;         if (!lock_is_owner_id_valid(mtx->owner)) {
20000138: 2b7f         	cmp	r3, #0x7f
2000013a: d9e7         	bls	0x2000010c <mutex_try_enter_block_until+0x4c> @ imm = #-0x32
;             mtx->owner = caller;
2000013c: 4643         	mov	r3, r8
2000013e: e002         	b	0x20000146 <mutex_try_enter_block_until+0x86> @ imm = #0x4
;     return (*(uint32_t *) (SIO_BASE + SIO_CPUID_OFFSET));
20000140: 23d0         	movs	r3, #0xd0
20000142: 061b         	lsls	r3, r3, #0x18
;         mtx->owner = lock_get_caller_owner_id();
20000144: 681b         	ldr	r3, [r3]
;             mtx->owner = caller;
20000146: 7123         	strb	r3, [r4, #0x4]
;     pico_default_asm_volatile ("dmb" : : : "memory");
20000148: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
2000014c: 2300         	movs	r3, #0x0
2000014e: 6013         	str	r3, [r2]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
20000150: f381 8810    	msr	primask, r1
;             return true;
20000154: 2001         	movs	r0, #0x1
20000156: e7d6         	b	0x20000106 <mutex_try_enter_block_until+0x46> @ imm = #-0x54

20000158 <mutex_exit>:
;     uint32_t save = spin_lock_blocking(mtx->core.spin_lock);
20000158: 6802         	ldr	r2, [r0]
;     pico_default_asm_volatile (
2000015a: f3ef 8110    	mrs	r1, primask
2000015e: b672         	cpsid i
;     while (__builtin_expect(!*lock, 0)) { // read from spinlock register (tries to acquire the lock)
20000160: 6813         	ldr	r3, [r2]
20000162: 2b00         	cmp	r3, #0x0
20000164: d0fc         	beq	0x20000160 <mutex_exit+0x8> @ imm = #-0x8
;     pico_default_asm_volatile ("dmb" : : : "memory");
20000166: f3bf 8f5f    	dmb	sy
;     mtx->owner = LOCK_INVALID_OWNER_ID;
2000016a: 23ff         	movs	r3, #0xff
2000016c: 7103         	strb	r3, [r0, #0x4]
;     lock_internal_spin_unlock_with_notify(&mtx->core, save);
2000016e: 6803         	ldr	r3, [r0]
;     pico_default_asm_volatile ("dmb" : : : "memory");
20000170: f3bf 8f5f    	dmb	sy
;     *lock = 0; // write to spinlock register (release lock)
20000174: 2200         	movs	r2, #0x0
20000176: 601a         	str	r2, [r3]
;     pico_default_asm_volatile ("msr PRIMASK,%0"::"r" (status) : "memory" );
20000178: f381 8810    	msr	primask, r1
;     pico_default_asm_volatile ("sev");
2000017c: bf40         	sev
; }
2000017e: 4770         	bx	lr

20000180 <__aeabi_ldiv0>:
20000180: 4770         	bx	lr
20000182: 46c0         	mov	r8, r8
20000184: 0000         	movs	r0, r0
20000186: 0000         	movs	r0, r0

20000188 <__best_effort_wfe_or_timeout_veneer>:
20000188: b401         	push	{r0}
2000018a: 4802         	ldr	r0, [pc, #0x8]          @ 0x20000194 <__best_effort_wfe_or_timeout_veneer+0xc>
2000018c: 4684         	mov	r12, r0
2000018e: bc01         	pop	{r0}
20000190: 4760         	bx	r12
20000192: bf00         	nop
20000194: 41 0f 00 10  	.word	0x10000f41
20000198: 10 00 00 00  	.word	0x00000010
2000019c: 00 00 00 00  	.word	0x00000000
200001a0: 00 00 00 00  	.word	0x00000000
200001a4: 00 00 00 00  	.word	0x00000000
200001a8: 00 00 00 00  	.word	0x00000000
200001ac: 00 00 00 00  	.word	0x00000000
200001b0: e8 01 00 20  	.word	0x200001e8
200001b4: 00 00 00 00  	.word	0x00000000
200001b8: 00 00 00 00  	.word	0x00000000
200001bc: 00 00 00 00  	.word	0x00000000

200001c0 <aeabi_bits_funcs>:
200001c0: 50 33 00 00  	.word	0x00003350
200001c4: 4c 33 00 00  	.word	0x0000334c
200001c8: 54 33 00 00  	.word	0x00003354
200001cc: 52 33 00 00  	.word	0x00003352

200001d0 <aeabi_mem_funcs>:
200001d0: 4d 53 00 00  	.word	0x0000534d
200001d4: 4d 43 00 00  	.word	0x0000434d
200001d8: 53 34 00 00  	.word	0x00003453
200001dc: 43 34 00 00  	.word	0x00003443

200001e0 <aeabi_mem_funcs_end>:
200001e0: 00 00 00 00  	.word	0x00000000
200001e4: 00 00 00 00  	.word	0x00000000
